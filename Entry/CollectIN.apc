PROC GLOBAL
{ CAPI for DHS-8 surveys - version 1.0.0 April 10, 2021 }

  { Definitions of working variables }
  alpha(60) wothresp;     { Other answers response }
  numeric   wothcode;     { Other answers code }
  numeric   meth;         { modified method number to be used with calendar }

  string textstr1;        { Alpha variable to get customize text for questions }
  string textstr2;        { Alpha variable to get customize text for questions }
  string event1;          { Alpha variable for 1st event in the calendar }
  string event2;          { Alpha variable for 2nd event in the calendar }																		  
  string mnthstr1;        { Alpha variable to get month's name }
  string mnthstr2;        { Alpha variable to get month's name }
  string childname;       { Child's name to display when asking questions }
  string alphmeth;        { Alpha variable to get method's name }
  string facility;        { Alpha variable for the type of facility }
															 
  string asource;         { source of methods for calendar column 3 }
  string strnotes;        { for editnote at the end of the interview }
  
  string fname;           { String for data filenames }
  string pregstr;         { Pregnancy codes for the calendar }
  string methstr;         { Method codes for the calendar }
  string alphalst;        { The alphabet }
  string q307str;         { string of codes used in Q307 }
  string am439str;        { string of codes for methods used in ZZZQM418 }
  string spec;            { String of special codes WXYZ used in checking alpha vars }
  string calw;            { Working calendar variable }
  string methname;        { method name }
  string relpast;         { whether relation is current or past }
  string rellast;         { whether relation is NULL or past }
  string partype;         { type of partner husband/male partner }
  string lastfield;       { last field application was on - used in onkey function - do not reuse }
  string foodfield;       { name of the last food or drink field that the cursor was on }
  string id;              { questionnaire full ID }
  string partner;         { to customize questions where husband and partenr are used }
  array string orderstr(5);
  
  alpha(1)  calcode;      { one digit code to be used by the calendar }
  alpha(1)  codemar;      { code for marriage to be used in calendar }
  alpha(1)  codeb;        { Code for births }
  alpha(1)  codep;        { Code for pregnancies }
  alpha(1)  codet;        { Code for terminations }
  alpha(1)  onemeth;      { current method to check with calendar }

  array twincode(24);            { Codes for checking twins in birth history }
  array ldc(24);                 { Lower bound of CMC date of birth for children }	
  array udc(24);                 { Upper bound of CMC date of birth for children }
  array calrow(24);              { Row of calendar for pregnancy }
  array birthrow(80);            { number of pregnancy in calendar row, i.e pregnancy 07 is in row 60 }
  array string womevents(20,3);  { women events }
  array string months_array(12);
// = "Dec","Nov","Oct","Sep","Aug","Jul","Jun","May","Apr","Mar","Feb","Jan";
  array string cal_array(72,7);  { used to display calendar from toolbar }
  array string BloodCat(6);
// = "Acceptable range", "At the high end of acceptable range",
 //                            "Above acceptable range", "Moderately high", "High", "Very high";
  array string BloodCon(6);
// = "24 months", "12 months", "2 months",
 //                            "1 month", "7 days", "Today";
  numeric disp1, disp2;          { used for current episode indicators to display calendar }

  numeric i, n, j, t, x, y, b, m, p, err, InEntry, android, capturecoor, gpsopen;
  numeric sday, smonth, syear, di, dicdc, time, ch, checkx, minab, minam, minabm, minamm, max5, maxsib, chsex;
  numeric calint, calbeg, calend, callen, calendy, calbegy, yrspcare, yrsvacc, yrshlth, yrsfeed;
  numeric calterm, xrow, ycmc, pregtype, pregpcare, pregvacc, preghlth, pregfeed, births2;
  numeric endevent, begevent, cmcend, cmcbeg, endrowint, begrowint, caluse, calmeth, calcmc, beguse, begcheck;
  numeric uniocal, cmcdm, begrow, endrow, prev, maxd, mind, adeath, wives;
  numeric ldb, udb, ldth, udth, lds, uds, xl, xu, ldm, udm, upto;

  numeric xintnum, xsupnum, xmodcent, xrvisit, xpartial, xmodify, xentryhw, xhhnum, xline, xteam, reviewsup;
  numeric methoth, methem, methsupp, stermeth, stermetm, used, usem, methpos, discont, xusing, condom, method;
  numeric vcheckx, temp, evermarr, inunion, prostit, sexp, agric, ch014, ch017, daughter;
  numeric goodval, oldval, maxchild, twins, age, aold, iold, aoldest, anew; 
  numeric month, year, year1, month1, year2, month2, mstat, lchild, daughty;
  numeric older, order, agew, agem, agedau, breastfed, treatment, marriages;
  numeric NSibs, xMM03, xMM04, xMM05, xMM06, xMM08, xMM10;
  numeric relprev, anyviol, nhhold, showcard, showID;
  numeric DaysMonth = 30.4375, WeeksMonth = 0.23;
  numeric idx, durpreg;
  numeric drinks_popup   = 0;	// used in handling Q636
  numeric foods_popup    = 0;	// used in handling Q637
  numeric foods_popupW   = 0;	// used in handling Q643 for foods
  numeric other_drinks   = 0;   // toggle for "other" drinks for children
  numeric other_foods    = 0;   // toggle for "other" foods for children
  numeric other_foodsW   = 0;   // toggle for "other" foods for women
  numeric foodsid  = 0;         // resource id for foods userbar button
  numeric preghid  = 0;         // resource id for pregnancy history userbar button
  numeric pregsid  = 0;         // resource id for pregnancies userbar button
  numeric eventsid = 0;         // resource id for events display
  numeric matmortid= 0;         // resource id for maternal mortality display
  numeric moving   = 0;         // when moving pregnancies
  numeric calendid = 0;         // resource id for calendar display
  numeric goback222 = 0;        // manages when to go back to 222
  numeric indexpreg, indexpreg2, childecd;
  numeric twinnum;

  valueset individuals, vs;
  valueset string vaccinations, foods, sources;
  valueset grades;

  { used to move to a specific section in the questionnaire } 
  function toSection();
    numeric ix = 0;
    numeric sec = 0;
    array string formname(20);
    string formstr;
    if QQTYPE = 2 then
      sec = accept( tr("Go to section:"),
        getlabel( QSECOVER  ), 
        getlabel( QWSEC01   ), 
        getlabel( QWSEC2A   ), 
        getlabel( QWSEC2B   ), 
        getlabel( QWSEC2D   ), 
        getlabel( QWSEC3A   ), 
        getlabel( QWSEC3B   ), 
        getlabel( QWSEC3C   ), 
        getlabel( QWSEC04   ), 
        getlabel( QWSEC05   ), 
        getlabel( QWSEC6A   ), 
        getlabel( QWSEC6B   ), 
        getlabel( QWSEC07   ), 
        getlabel( QWSEC08   ), 
        getlabel( QWSEC09   ), 
        getlabel( QWSEC10   ), 
        getlabel( QWSEC11   ), 
      { getlabel( ZZZQWSECMH   ), 
        getlabel( QWSECM1   ), 
        getlabel( QWSECM2   ), }
        getlabel( QWSECDV   ), 
      { getlabel( ZZZQWSECG1   ), 
        getlabel( ZZZQWSECG2   ), 
        getlabel( ZZZQWSECECD  ), 
        getlabel( ZZZQWSECSBC  ), 
        getlabel( ZZZQWSECFIS  ), }
        tr("End of questionnaire"),
        tr("Cancel") );
      if     sec =  1 & totocc(QSECOVER_FORM) then move to QSECOVER_FORM advance
      elseif sec =  2 & totocc(QWSEC01_FORM)  then move to QWSEC01_FORM  advance
      elseif sec =  3 & totocc(QWSEC2A_FORM)  then move to QWSEC2A_FORM  advance
      elseif sec =  4 & totocc(QWSEC2B_FORM)  then move to QWSEC2B_FORM  advance
      elseif sec =  5 & totocc(QWSEC2D_FORM)  then move to QWSEC2D_FORM  advance
      elseif sec =  6 & totocc(QWSEC3A_FORM)  then move to QWSEC3A_FORM  advance 
      elseif sec =  7 & totocc(QWSEC3B_FORM)  then move to QWSEC3B_FORM  advance 
      elseif sec =  8 & totocc(QWSEC3C_FORM)  then move to QWSEC3C_FORM  advance 
      elseif sec =  9 & totocc(QWSEC04_FORM)  then move to QWSEC04_FORM  advance 
      elseif sec = 10 & totocc(QWSEC05_FORM)  then move to QWSEC05_FORM  advance 
      elseif sec = 11 & totocc(QWSEC6A_FORM)  then move to QWSEC6A_FORM  advance 
      elseif sec = 12 & totocc(QWSEC6B_FORM)  then move to QWSEC6B_FORM  advance 
      elseif sec = 13 & totocc(QWSEC07_FORM)  then move to QWSEC07_FORM  advance 
      elseif sec = 14 & totocc(QWSEC08_FORM)  then move to QWSEC08_FORM  advance 
      elseif sec = 15 & totocc(QWSEC09_FORM)  then move to QWSEC09_FORM  advance 
      elseif sec = 16 & totocc(QWSEC10_FORM)  then move to QWSEC10_FORM  advance 
      elseif sec = 17 & totocc(QWSEC11_FORM)  then move to QWSEC11_FORM  advance 
     { elseif sec = 18 & totocc(AWSECMT_FORM)  then move to AWSECMT_FORM  advance 
      elseif sec = 19 & totocc(QWSECM1_FORM)  then move to QWSECM1_FORM  advance 
      elseif sec = 20 & totocc(QWSECM2_FORM)  then move to QWSECM2_FORM  advance  }
      elseif sec = 21 & totocc(QWSECDV_FORM)  then move to QWSECDV_FORM  advance 
    {  elseif sec = 22 & totocc(ZZZQWSECG1_FORM)  then move to ZZZQWSECG1_FORM  advance 
      elseif sec = 23 & totocc(ZZZQWSECG2_FORM)  then move to ZZZQWSECG2_FORM  advance 
      elseif sec = 24 & totocc(ZZZQWSECECD_FORM) then move to ZZZQWSECECD_FORM advance 
      elseif sec = 25 & totocc(ZZZQWSECSBC_FORM) then move to ZZZQWSECSBC_FORM advance 
      elseif sec = 26 & totocc(ZZZQWSECFIS_FORM) then move to ZZZQWSECFIS_FORM advance }
      elseif sec = 27 & totocc(QLANG_FORM)    then move to QLANG_FORM    advance 
	  elseif sec = 28 then   // Cancel - do nothing
	  else
	    errmsg( 0005 );
      endif;
    elseif QQTYPE = 1 then
      sec = accept( tr("Go to section:"),
        getlabel( QSECOVER  ), 
      {  getlabel( ZZZQMSEC01   ), 
        getlabel( ZZZQMSEC02   ), 
        getlabel( ZZZQMSEC3A   ), 
        getlabel( ZZZQMSEC3B   ), 
        getlabel( ZZZQMSEC04   ), 
        getlabel( ZZZQMSEC05   ), 
        getlabel( ZZZQMSEC06   ), 
        getlabel( ZZZQMSEC07   ), 
        getlabel( ZZZQMSEC08   ), 
        getlabel( ZZZQMSECGC   ), }
        tr("End of questionnaire"),
        tr("Cancel") );
      if     sec =  1 & totocc(QSECOVER_FORM) then move to QSECOVER_FORM advance
     { elseif sec =  2 & totocc(ZZZQMSEC01_FORM)  then move to ZZZQMSEC01_FORM  advance
      elseif sec =  3 & totocc(ZZZQMSEC02_FORM)  then move to ZZZQMSEC02_FORM  advance
      elseif sec =  4 & totocc(ZZZQMSEC3A_FORM)  then move to ZZZQMSEC3A_FORM  advance
      elseif sec =  5 & totocc(ZZZQMSEC3B_FORM)  then move to ZZZQMSEC3B_FORM  advance
      elseif sec =  6 & totocc(ZZZQMSEC04_FORM)  then move to ZZZQMSEC04_FORM  advance
      elseif sec =  7 & totocc(ZZZQMSEC05_FORM)  then move to ZZZQMSEC05_FORM  advance
      elseif sec =  8 & totocc(ZZZQMSEC06_FORM)  then move to ZZZQMSEC06_FORM  advance
      elseif sec =  9 & totocc(ZZZQMSEC07_FORM)  then move to ZZZQMSEC07_FORM  advance
      elseif sec = 10 & totocc(ZZZQMSEC08_FORM)  then move to ZZZQMSEC08_FORM  advance
      elseif sec = 11 & totocc(ZZZQMSECGC_FORM)  then move to ZZZQMSECGC_FORM  advance }
      elseif sec = 12 & totocc(QLANG_FORM)    then move to QLANG_FORM    advance 
	  elseif sec = 13 then   // Cancel - do nothing
	  else
	    errmsg( 0005 );
      endif;
    endif;
  end;

  { to position window with answers: 0-Next to answers window -1-Next to field }
  function responseloc( loc );
    if loc = 1 then
      setproperty( TJIN80, "captureposx", "0" );
      setproperty( TJIN80, "captureposy", "0" );
	elseif loc = 2 then
      setproperty( TJIN80, "captureposx", "-1" );
      setproperty( TJIN80, "captureposy", "-1" );
    endif;
  end;

  { to select where to position window with answers }
  function responses( loc );
    if !loc in 1,2 then
      loc = accept( tr("Select location for responses"),
	                tr("Top left corner beneath questions"),
		            tr("Next to field on the form") );
	endif;
	responseloc( loc );
    reenter; // force reposition of labels - only works when called from a field
  end;

  { setup basic user bar }
  function userbase();
    userbar( clear );
    userbar( add button, "<",    do("PreviousField") );
    userbar( add button, ">",    do("NextField") );
    userbar( add button, ">>|",  do("AdvanceToEnd") );
    userbar( add button, tr("Note"), do("EditNote") );
    userbar( add button, tr("Lang"), do("ChangeLanguage") );
	userbar( add button, tr("Ver"),  GetPubDate(2) );
	userbar( add button, tr("Section"), toSection() );
	if !android then // Response location only works for Windows
	  userbar( add button, tr("Responses"), Responses( 0 ) );
	endif;
  end;

  { set value sets based on language }
  function OnChangeLanguage()
    SetLanguage( getlanguage() );
    savesetting("Language", getlanguage());
  end;

  { list all pictures and use the last last one taken }
  function string GetPicture()
    string picfile;
    list string PictureList;
    picfile = "C:/Users/" + GetUserName() + "/OneDrive/Pictures/Camera Roll";  //New default location Windows 11
    dirlist( PictureList, picfile, "WIN*.JPG" );
    do j = 1 while j <= PictureList.length()
      Textstr2 = PictureList(j);
    enddo;
    GetPicture = Textstr2;
  end;

  { function to take picture with a windows tablet }
  function TakePictureW( child )
    image VCardPic;
    { take as many pictures as necessary }
    do i = 1 while i
      execsystem( "cmd /c start microsoft.windows.camera:", wait ); 	
      display( tr("Click OK to continue") );	  
      textstr1 = GetPicture();
      VCardPic.load(textstr1);
      VCardPic.resample(width := 800, height := 600);
	  FileDelete( textstr1 );
      { find if there are pictures previusly taken for that child  and generate different versions }
      textstr2 = "../PII/Pictures/P" + id + edit("99",child);
      do n = 1 while FileExist( textstr2 + "_" + edit("99",n) + ".jpg" ) enddo;
      textstr2 = textstr2 + "_" + edit("99",n) + ".jpg";
      VCardPic.save( textstr2 );	  
      view( textstr2 );
      if accept( tr("Do you want to take another picture of the document"), tr("Yes"), tr("No") ) <> 1 then
        break
      endif;
    enddo;
  end;

  { function to take picture with an android tablet }
  function TakePictureA( child )
    image VCardPic;
    { take as many pictures as necessary }
    do i = 1 while i
	  if VCardPic.TakePhoto( tr("Photo of the document with vaccinations") ) then
        VCardPic.resample(width := 800, height := 600);
        { find if there are pictures previusly taken for that child  and generate different versions }
        textstr2 = "../PII/Pictures/P" + id + edit("99",child);
        do n = 1 while FileExist( textstr2 + "_" + edit("99",n) + ".jpg" ) enddo;
        textstr2 = textstr2 + "_" + edit("99",n) + ".jpg";
        VCardPic.save( textstr2 );
        view( textstr2 );
        if accept( tr("Do you want to take another picture of the document"), tr("Yes"), tr("No") ) <> 1 then
          break
        endif;
      endif;		
    enddo;
  end;

  { used by the central office to show a vaccination card picture display  }
  function ShowVaccCard()
    textstr2 = "../PII/Pictures/P" + id + edit("99",Q503);
    do n = 1 while FileExist( textstr2 + "_" + edit("99",n) + ".jpg" ) enddo;
    textstr2 = textstr2 + "_" + edit("99",n-1) + ".jpg";
    if !fileExist(textstr2) then
      errmsg( 4465, Q503, strip(Q218(Q503)) );
    else
      view( textstr2 );
    endif;
  end;

  array string preghist(24,9);
  function ph_array();
    do i = 1 while i <= maxchild
	  if maxchild > Q212W & special( visualvalue( Q215L(i) ) ) & special( visualvalue( Q215(i) ) ) & special( visualvalue( Q216(i) ) ) then
	    break
	  else
	    preghist(i,1) = maketext( "%2d", visualvalue( Q215L(i) ) );
	    preghist(i,2) = Q218(i);
	    preghist(i,3) = replace(maketext( "%1d", visualvalue( Q216(i) ) ), "NOTAPPL", "") + "-" + getlabel( Q216, visualvalue( Q216(i) ) );
	    preghist(i,4) = getlabel( Q223, visualvalue( Q223(i) ) );
		recode visualvalue( Q219(i) ) -> preghist(i,5);
								  1   -> tr("Boy");
								  2   -> tr("Girl");
								      -> "";
		endrecode;
		if special( visualvalue( Q220D(i) ) ) & special( visualvalue( Q220M(i) ) ) & special( visualvalue( Q220Y(i) ) ) then
		  preghist(i,6) = "";
		else
		  preghist(i,6) = maketext( "%d/%d/%d", visualvalue( Q220D(i) ), visualvalue( Q220M(i) ), visualvalue( Q220Y(i) ) );
		endif;
		recode visualvalue( Q224(i) ) -> preghist(i,7);
								  1   -> tr("Alive");
								  2   -> tr("Dead");
								      -> "";
		endrecode;
		recode visualvalue( Q225(i) ) -> preghist(i,8);
						       0:40   -> maketext( "%d", visualvalue( Q225(i) ) );
							     98   -> tr("DK");
								      -> "";
		endrecode;
		recode visualvalue( Q226(i) ) -> preghist(i,9);
								  1   -> tr("Yes");
								  2   -> tr("No");
								      -> "";
		endrecode;
	  endif;
	enddo;
	ph_array = i-1;
  end;

  array string hhmember(50,7);
  function hhm_array();
    do i = 1 while i <= QHMEMBER
	  {Line number}
	  hhmember(i,1) = maketext( "%2d", QH01(i) );
      { First/last name }
	  hhmember(i,2) = QH02(i);
      { Relationship with head of household }
	  hhmember(i,3) = getlabel(QHRELAT, QH03(i));
      { Update labels to be sex specific where we can - otherwise leave as in dictionary }
      if QH04(i) = 1 then
		recode QH03(i) -> hhmember(i,3);
                 2     -> tr("Husband");
                 3     -> tr("Son");
                 4     -> tr("Son-in-law");
                 6     -> tr("Father");
                 7     -> tr("Father-in-law");
                 8     -> tr("Brother");
        endrecode;
      else
        recode QH03(i) -> hhmember(i,3);
                 2     -> tr("Wife");
                 3     -> tr("Daughter");
                 4     -> tr("Daughter-in-law");
                 6     -> tr("Mother");
                 7     -> tr("Mother-in-law");
                 8     -> tr("Sister");
        endrecode;
      endif;
      { Sex }
      hhmember(i,4) = getlabel(QH04, QH04(i));
      { Usual residence }
      hhmember(i,5) = getlabel(QH05, QH05(i));
      { Slept the night before }
      hhmember(i,6) = getlabel(QH06, QH06(i));
	  hhmember(i,7) = maketext( "%2d", QH07(i) );
	enddo;
	hhm_array = i-1;
  end;

  array string SiblingsList(20,7);
  {function sib_array();
    do i = 1 while i <= maxsib
	  if i > totocc(AWSECMM_ROSTER) then
	    break
	  else
	    SiblingsList(i,1) = maketext( "%2d", visualvalue( QMM13(i) ) );
	    SiblingsList(i,2) = QMM13N(i);
		recode visualvalue( QMM14(i) ) -> SiblingsList(i,3);
								  1    -> tr("Male");
								  2    -> tr("Female");
								       -> "";
		endrecode;
		recode visualvalue( QMM15(i) ) -> SiblingsList(i,4);
								  1    -> tr("Alive");
								  2    -> tr("Dead");
								       -> "";
		endrecode;
		if visualvalue(QMM15(i)) = 1 then
	      SiblingsList(i,5) = maketext( "%2d", visualvalue( QMM16(i) ) );
		  SiblingsList(i,6) = "";
	      SiblingsList(i,7) = "";
		else
	      SiblingsList(i,5) = "";
	      SiblingsList(i,6) = maketext( "%2d", visualvalue( QMM17(i) ) );		
	      SiblingsList(i,7) = maketext( "%2d", visualvalue( QMM18(i) ) );		
        endif;
	  endif;
	enddo;
	sib_array = i-1;
  end;}

  { help function to display pregnancy history, household members }
  function showroster( rtype )
    numeric npregs;
	numeric nsibls;
    numeric sr = 0;
    if rtype = 1 then   // pregnancy history
	  npregs = ph_array();
      sr = showarray( tr("Pregnancy history")+" ("+tr("expecting")+" "+edit("9",visualvalue(Q212W))+" "+tr("pregnancy outcomes")+")",
 	      preghist, npregs, 
          title( tr("Line"), tr("Name"), tr("Initial Outcome"), tr("Final Outcome"), tr("Sex"), tr("Date"), tr("Alive"), tr("Age"), tr("Live Mother") ) );
    {elseif rtype = 2 then  // siblings
	  nsibls = sib_array();
      sr = showarray( tr("Maternal mortality: siblings"), SiblingsList, nsibls,
          title( tr("Line"), tr("Name"), tr("Sex"), tr("Alive"), tr("Age"), tr("Years-D"), tr("Age-D") ) ); }
    elseif rtype = 3 then   // events
      sr = showarray( tr("List of events"), womevents, title(tr("Event"), tr("Date"), tr("Dur/Preg")) );
    elseif rtype = 4 then  // household members
      sr = showarray( tr("Household members"), hhmember, nhhold, 
          title( tr("Line"), tr("Name"), tr("Relation"), tr("Sex"), tr("Usual"), tr("Stayed"), tr("Age") ) );	
    endif;
    showroster = sr;
  end;

  { function to show the pregnancies to include in sections 4, 5, and 6 of the questionnaire }
  function showpreg456(string titlestr, index, birth)
    // index is the index of the earliest pregnancy to include
	// birth is whether to include only live births (1) or all pregnancies (0)
    show( titlestr, TJIN80.QWSEC2B, Q215L, Q218, Q220,
    where Q215L >= index & (birth = 0 | Q224 = 1) // include either all pregnancies (birth = 0) or living children only (q224 = 1)
    title( tr("Line number"), tr("Name"), tr("Date of birth/end of pregnancy") ));
  end;

  { Function to ensure proper entry and updating of "Other" answers }
  function getother( alpha(10) questnum, questocc );
    { Create alpha id for other answers file }
    { If your ID is not 10 characters in length, remember to fix the length of the level 1 ID and of OTHID in OTHERS.DCF }
    OTHID   = id;
    OTHQUES = questnum;   { question number }
    OTHOCC  = questocc;   { occurrence for multiple section/group or
                                           multipart question }
    { Get the previous response back if already entered
      in case of backtabbing or updating }
    if !loadcase( OTHERS, OTHID, OTHQUES, OTHOCC ) then
      { Otherwise initialize to blanks }
      OTHRESP = " ";
      OTHCODE = 0;
    endif;
    wothresp = OTHRESP;
    wothcode = OTHCODE;
  end;

  { to customize questions involving husband/partner }  
  function relterms()              // relationship terms
    if Q701 = 1 then
      partner = tr("husband")
    elseif Q701 = 2 then
      partner = tr("partner")
    else
      partner = tr("(husband/partner)"); // just in case
    endif;
  end;

  { to customize questions DV06 to DV16 in DV module }  
  function relterms2()              // relationship terms
    relprev = ( inunion = 1 | DV04 = 1 );
    rellast = "";
    relpast = tr("current");
    if !relprev then 
      rellast = tr("last") + " ";   // with a blank
      relpast = tr("last");         // without a blank
    endif;
    if Q701 = 1 | Q702 = 1 then     // only married, not living with
      partype = tr("husband");
    else	
      partype = tr("male partner");
    endif;
  end;

  { Function to convert a CMC code to a calendar row }
  function cmcrow( xcmc )
    if !(xcmc in calbeg:calend) then
      xrow = 0
    else
      xrow = calend-xcmc+1
    endif;
    cmcrow = xrow;
  end;

  { Function to convert a calendar row to a CMC code }
  function rowcmc( yrow )
    if !(yrow in 1:callen) then
      ycmc = 0
    else
      ycmc = calend-yrow+1
    endif;
    rowcmc = ycmc;
  end;

  { Function to generate month labels (mnthstr1) and years (year) based on a calendar row }
  { to be used when displaying error messages                                             }
  function MnthYear( yrow );
    ycmc   = rowcmc( yrow );
    month  = ( ycmc-1 ) % 12 + 1;
    mnthstr1 = GetLabel( QINTM, month );
    year   = int( (ycmc-1)/12 ) + 1900;
  end;

  { Function to check all possible combinations of day, month and year of vaccination in section 5 }
  function vcheck( vcheckd, vcheckm, vchecky )
    recode  vchecky         :: vcheckm               :: vcheckd    -> x;       { !!! }
                       9998 :: 98                    :: 98         -> 1; { can't all be 98's - would use 44 in that case }
        2015:2025,9997,9998 :: 1,3,5,7,8,10,12,97,98 :: 1:31,97,98 -> 0;
        2015:2025,9997,9998 :: 4,6,9,11              :: 1:30,97,98 -> 0;
        2015:2025,9997,9998 :: 2                     :: 1:28,97,98 -> 0;
        2016,2020,2024      :: 2                     :: 29         -> 0;       { Leap year }
                 6666       :: 66                    :: 66         -> 0;
                 4444       :: 44                    :: 44         -> 0;
                    0       :: 0                     :: 0          -> 0;
                            ::                       ::            -> 1;
    endrecode;
    if vchecky < 2050 & vchecky > QINTY then
	  x = 2
    elseif vchecky = QINTY & vcheckm <= 12 & vcheckm > QINTM then
      x = 2
    elseif vchecky = QINTY & vcheckm = QINTM &
           vcheckd <= 31 & vcheckd > QINTD then
      x = 2
    endif;
    vcheck = x;
	if x then
	  errmsg( 4470, vcheckd, vcheckm, vchecky );
      reenter;
    endif;
  end;

  { check that a given date is greater or equal to child's date of birth }
  function vckbirth( vcheckd, vcheckm, vchecky, chidx )
    vcheckx = 0;
    if vchecky in 2015:2025 & Q220Y(chidx) in 2015:2025 & vchecky < Q220Y(chidx) then
      vcheckx = 1
    elseif vchecky in 2015:2025 & vchecky = Q220Y(chidx) &
           vcheckm in 1:12 & Q220M(chidx) in 1:12 & vcheckm < Q220M(chidx) then
      vcheckx = 1
    elseif vchecky in 2015:2025 & vchecky = Q220Y(chidx) &
           vcheckm in 1:12 & Q220M(chidx) = vcheckm &
           vcheckd in 1:31 & Q220D(chidx) in 1:31 & vcheckd < Q220D(chidx) then
      vcheckx = 1
    endif;
    vckbirth = vcheckx;
	if vcheckx then
      errmsg( 4471, vcheckd, vcheckm, vchecky, Q503, Q220D(Q503), Q220M(Q503), Q220Y(Q503) );
      reenter;
    endif;
  end;

  { function to know if a vaccination was given – excludes 66 }
  function vacgiven( xvar )
    if xvar in 1:31,44,97,98 then
      vacgiven = 1
    else
      vacgiven = 0
    endif;
  end;

  { function to check if the current pregnancy is a love birth or not }
  function livebirth();
    livebirth = (Q216 = 1 | Q216 = 2 & Q217 = 1);
  end;

  { function to renumber the rows of the pregnancy history when insertion or deletion takes place }
  function renum_pregs()
    do i = 1 while i <= maxchild
      if i <= Q212W then
        Q215L(i) = i;
		QPLINE(i) = i;
      else
        Q215L(i) = notappl;        { blank out unused lines }
		QPLINE(i) = notappl;
      endif;
    enddo;
  end;

  { function to insert a new pregnancy into the pregnancy history before the occurrence given in pocc }
  function insert_preg( pocc )
    numeric occno;
	goback222 = (pocc>Q212W); // if adding after last then need to go back to Q222 after adding - used in PROC Q222A
    if moving | // if we are moving a pregnancy the message has already been displayed
       accept( maketext(2400+goback222), tr("Yes"), tr("No") ) = 1 then // otherwise display message to insert before pregnancy (2400), or after the last pregnancy (2401)

	  // reset 222 if insertion was because of 222, saving the information that Q222 = 1 was used. Needs to be done before the insertion.  Similar for 229.
	  if lastfield = "Q222" & Q222 = 1 then
	    Q222W(Q215L) = 1;
		Q222 = 2;
	  elseif lastfield = "Q222A" & Q222A = 1 then
	    Q222AW = 1;
		Q222A = 2;
	  endif;

	  // remove the 24th pregnancy first to avoid an error message
      if totocc( QWSEC2B_ROSTER1 ) = maxchild then delete( QWSEC2B_ROSTER1(maxchild) ) endif; { needed as totocc is set to the maximum for Partial save in add mode }
      if totocc( QWSEC2B_ROSTER2 ) = maxchild then delete( QWSEC2B_ROSTER2(maxchild) ) endif; { needed as totocc is set to the maximum for Partial save in add mode }
	  // insert the new pregnancy entry in roster 1
      insert( QWSEC2B_ROSTER1(pocc) );
	  Q215L(pocc) = pocc;
	  // and in roster 2 if that has been started
	  if !special( visualvalue(Q223(pocc)) ) then // check this works
        insert( QWSEC2B_ROSTER2(pocc) );
		QPLINE(pocc) = pocc;
	  endif;

	  // increase the total number of pregnancies
	  inc( Q212W );
	  // renumber all of the pregnancies
	  renum_pregs();

	  // and in Android, reset the occurence labels
	  if android then
	    // get the occurence number for the last one used
	    do occno = pocc while !special( visualvalue( Q215L(occno) ) ) enddo; 
        inc( occno, -1 );
		// shift all of the occurence labels up by 1
  	    while occno > pocc do
	      setocclabel( QWSEC2B_ROSTER1(occno), getocclabel( QWSEC2B_ROSTER1(occno-1) ) );
	      setocclabel( QWSEC2B_ROSTER2(occno), getocclabel( QWSEC2B_ROSTER1(occno-1) ) );
          inc( occno, -1 );
	    enddo;
		// add in the new occurence labels
	    setocclabel( QWSEC2B_ROSTER1(pocc), maketext("%d",pocc) );
	    setocclabel( QWSEC2B_ROSTER2(pocc), maketext("%d",pocc) );
	  endif;

	  // just to blank out the field as the current value is often left behind
	  setvalue( lastfield, notappl, pocc); 

	  // if not moving pregnancies (i.e. just inserting) then move to the first field
	  if !moving then
        display(tr("Pregnancy inserted")); // included to force correct display of the screen
	    if goback222 then
		  move to Q222(pocc-1) // go back to Q222 as we can't go to Q215 or Q215L for a new occurence, when adding on the end of the roster
		else
	      move to Q215L(pocc)
		endif;
	  endif;
	elseif !moving then
	  // reset 222 or 229 before moving on if needed.
	  if lastfield = "Q222" & Q222 = 1 then
	    Q222 = 2;
	  elseif lastfield = "Q222A" & Q222A = 1 then
	    Q222A = 2;
	  endif;
    endif;
  end;

  { function to date a pregnancy from the pregnancy history at the occurrence given in pocc }
  function delete_preg( pocc )
    numeric occno;
    if moving | // if we are moving a pregnancy the message has already been displayed
	   // otherwise display message to delete pregnancy
	   accept( maketext( 2402, strip(Q218), getlabel(Q220M, visualvalue(Q220M)), visualvalue(Q220Y) ),
               maketext( tr("Yes, delete the pregnancy of %s in %s %d"), strip(Q218), getlabel(Q220M, visualvalue(Q220M)), visualvalue(Q220Y) ),
                         tr("No, make no change") ) = 1 then
	  // delete the pregnancy in roster 1 and roster 2
      delete( QWSEC2B_ROSTER1(pocc) );
	  if !special( visualvalue(Q223(pocc)) ) then
        delete( QWSEC2B_ROSTER2(pocc) );
	  endif;
	  // decrease the total number of pregnancies
	  if Q212W > 0 & Q212W > Q212 then
        inc( Q212W, -1 );
	  endif;
	  // renumber all of the pregnancies
	  renum_pregs();
	  // and in Android, reset the occurence labels
	  if android then 
		// shift all of the occurence labels up by 1
	    do occno = pocc while !special( visualvalue( Q215L(occno) ) ) 
	      setocclabel( QWSEC2B_ROSTER1(occno), getocclabel( QWSEC2B_ROSTER1(occno+1) ) );
	      setocclabel( QWSEC2B_ROSTER2(occno), getocclabel( QWSEC2B_ROSTER1(occno+1) ) );
	    enddo;
	  endif;

	  // if not moving pregnancies (i.e. just deleting) then move to the first field of the next pregnancy
	  if !moving then
        display(tr("Pregnancy deleted")); // included to force correct display of the screen
	    if special( visualvalue(Q215L(pocc)) ) then
		  if pocc = 1 then
		    move to Q214 // no more pregnancies left so move back to Q214
		  else
		    move to Q215(pocc-1) // move back to the pregnancy before
		  endif;
		else
          move to Q215L(pocc) advance // move to the pregnancy following
		endif;
	  endif;
    endif;
  end;

  { function to copy a pregnancy into the pregnancy history from the occurrence given in pocc1 into the occurrence given in pocc2 }
  function copy_preg( pocc1, pocc2 );
	Q215 (pocc2) = visualvalue( Q215 (pocc1) );
	Q216 (pocc2) = visualvalue( Q216 (pocc1) );
	Q217 (pocc2) = visualvalue( Q217 (pocc1) );
	Q218 (pocc2) =              Q218 (pocc1)  ;
	Q219 (pocc2) = visualvalue( Q219 (pocc1) );
	Q220D(pocc2) = visualvalue( Q220D(pocc1) );
	Q220M(pocc2) = visualvalue( Q220M(pocc1) );
	Q220Y(pocc2) = visualvalue( Q220Y(pocc1) );
	Q221U(pocc2) = visualvalue( Q221U(pocc1) );
	Q221N(pocc2) = visualvalue( Q221N(pocc1) );
	Q222 (pocc2) = visualvalue( Q222 (pocc1) );
	Q222W(pocc2) = visualvalue( Q222W(pocc1) );
	Q223 (pocc2) = visualvalue( Q223 (pocc1) );
	Q224 (pocc2) = visualvalue( Q224 (pocc1) );
	Q225 (pocc2) = visualvalue( Q225 (pocc1) );
	Q226 (pocc2) = visualvalue( Q226 (pocc1) );
	Q227 (pocc2) = visualvalue( Q227 (pocc1) );
	Q228U(pocc2) = visualvalue( Q228U(pocc1) );
	Q228N(pocc2) = visualvalue( Q228N(pocc1) );
  end;

  { function to move a pregnancy in the pregnancy history from the occurrence given in pocc1 before the occurrence given in pocc2 }
  { uses insert_preg, copy_preg, delete_preg, renum_pregs to move the pregnancy }
  function move_preg( pocc1, pocc2 )
    if pocc2 < 1 | pocc2 >= pocc1 then
      display( tr("No change made") );
    elseif accept( maketext( 2403, strip(Q218), getlabel(Q220M, visualvalue(Q220M)), visualvalue( Q220Y ), 
	                      strip( Q218(pocc2) ), getlabel(Q220M, visualvalue(Q220M(pocc2))), visualvalue( Q220Y(pocc2) ) ),
                   maketext(tr("Yes, move the pregnancy of %s in %s %d before the pregnancy of %s in %s %d"),
  				          strip(Q218), getlabel(Q220M, visualvalue(Q220M)), visualvalue( Q220Y ), 
				          strip(Q218(pocc2)), getlabel(Q220M, visualvalue(Q220M(pocc2))), visualvalue( Q220Y(pocc2) ) ),
                   tr("No, make no change") ) = 1 then
      moving = 1;						
      insert_preg( pocc2 );
      if pocc1 > pocc2 then inc( pocc1 ) endif;
      copy_preg( pocc1, pocc2 );
      delete_preg( pocc1 );
      renum_pregs();
      display(tr("Pregnancy moved")); // included to force correct display of the screen
	  moving = 0;
      move to Q215L(pocc2) advance;
	endif;
  end;

  { function to display the pregnancy history and select a particular pregnancy, possibly excluding a certain pregnancy }
  function select_preg(exclude_occ);
	select_preg = show( tr("Select the pregnancy to move the current pregnancy before"),
	                    TJIN80.QWSEC2B, Q218, Q216, Q219, Q220, Q224, Q225
      title( tr("Name"), tr("Outcome"), tr("Sex"), tr("Date"), tr("Alive"), tr("Age") ) where Q215L <> exclude_occ );
  end;

  { Popup for adding, inserting, deleting, moving pregnancies, or showing the pregnancy history }
  function preg_tools()
    numeric newocc;
    lastfield = getsymbol();
    if getrecord( lastfield ) = "QWSEC2B" then
      x = accept( tr("Pregnancies"),
	              tr("Insert pregnancy before current pregnancy"),
				  tr("Delete current pregnancy"),
				  tr("Move current pregnancy"),
				  tr("Cancel") );
      if     x = 1 then insert_preg( curocc() );
	  elseif x = 2 then delete_preg( curocc() );
	  elseif x = 3 then newocc = select_preg( curocc() ); 
	                    move_preg( curocc(), newocc );
	  elseif x in 0,4 then // do nothing
	  endif;
	else // just show the roster
      showroster(1)
	endif;
  end;

  { Copy the value from a prior twin for numeric fields }
  function copytwin(xval, nocc)
    n = nocc;
    numeric val = notappl;
    string var = getsymbol();         // get the name of the field we are on
    if special(xval) then             // check if there is already a value in the field
      do i = n-1 while i by (-1)      // loop over the other pregnancies
        if twincode(Q404(n)) > 0 & twincode(Q404(n)) = twincode(Q404(i))-(n-i) then // twin of the same pregnancy
          val = getvalue(var, i);     // get the value from the twin
          if !special(val) then       // the same variable for the twin has a response
            setvalue(var, val, n);    // set the code to the same as the twin
            break;                    // found a value for this twin and set the variable, so break out of the loop
          endif;
        endif;
      enddo;
    endif;
    copytwin = (!special(val));
  end;

  { Copy the value from a prior twin for alpha fields }
  function copytwin_a(string xval, nocc)
    n = nocc;
    string val = "";
    string var = getsymbol();          // get the name of the field we are on
    if length(strip(xval)) = 0 then    // check if there is already a value in the field
      do i = n-1 while i by (-1)       // loop over the other pregnancies
        if twincode(Q404(n)) > 0 & twincode(Q404(n)) = twincode(Q404(i))-(n-i) then // twin of the same pregnancy
          val = getvaluealpha(var, i); // get the value from the twin
          if length(strip(val)) then   // the same variable for the twin has a response
            setvalue(var, val, n);     // set the code to the same as the twin
            break;                     // found a value for this twin and set the variable, so break out of the loop
          endif;
        endif;
      enddo;
    endif;
    copytwin_a = (length(strip(val)) > 0);
  end;

  { function to check certain key combinations and disable them, also enables Ctrl-I, Ctrl-D, Ctrl-M. 
    Also captures the last field in use }
  function OnKey( I_Key )
    numeric newocc;
    lastfield = getsymbol(); // used in a number of other procs - keep this here
	if I_key in 114,2114,115,116 then { F3, Ctrl-F3, F4, F5 - block these }
	  I_key = 0;
	endif;
    if I_Key in {114,2114,}2073 then { F3, Ctrl-F3, Ctrl-I - insert }
      if getrecord( lastfield ) = "QWSEC2B" then
        insert_preg( curocc() );
	  endif;
	  I_key = 0;
    elseif I_Key in {115,}2068 then { F4, Ctrl-D - delete }
      if getrecord( lastfield ) = "QWSEC2B" then
        delete_preg( curocc() );
	  endif;
	  I_key = 0;
    elseif I_Key in {116,}2068 then { F5, Ctrl-M - move }
      if getrecord( lastfield ) = "QWSEC2B" then
	    select_preg( curocc() ); 
		newocc = showroster(1); 
		move_preg( curocc(), newocc );
	  endif;
	  I_key = 0;
	endif;
	Onkey = I_key;
  end;

  { function to get the position that the current source of method }
  { occupies in the string of sources in calendar for column 3     }
  function calsource()
    temp = Q322;
    if Q307N in stermeth,stermetm then
      temp = Q312
    endif;
    recode temp   -> methpos;
           11:16  -> temp-10;  { public sector 1-6 }
           21:26  -> temp-14;  { private sector    }
           31:33  -> temp-18;  { other source      }
             96   -> 16;       { other             }
    endrecode;
    calsource = methpos;
  end;
  
  { displays calendar on call from toolbar }
  function showcal();
    numeric ycal, mcal;
    numeric cal_ctr;
    numeric cal_idx = 0;
	numeric preg;
    string str_year, str_month, str_disp;
    // fill calendar array from working calendar
    cal_array.clear();
    do cal_ctr = 1 until cal_ctr > 72
      if cal_ctr < cmcrow(di)  then // don't show rows after date of interview
        next;
      endif;
      inc(cal_idx);
      ycal = int(cal_ctr/12);
      mcal = cal_ctr % 12;
      if !mcal then mcal = 12 endif;
      if cal_idx = 1 | mcal = 7 then
        str_year = edit("9999", calendy - ycal );
      elseif mcal = 12 then
        str_year = "____";
      else
        str_year = "";
      endif;
      // set up strings to display current episode rows
      if disp1 <> notappl then
        if disp1 = 72 then inc(disp1) endif; // if beginning of calendar move arrow 1 row back
        if     cal_ctr = disp1-1 then str_disp = ">>"
        elseif cal_ctr in disp2+2:disp1-2 then str_disp = "||"
        elseif cal_ctr = disp2+1 then str_disp = "<<"
        else str_disp = "";
        endif;
      endif;
      str_month = months_array(mcal);
      cal_array(cal_idx,1) = str_year;
      cal_array(cal_idx,2) = str_month;
      cal_array(cal_idx,3) = edit("99", cal_ctr);
      cal_array(cal_idx,4) = str_disp;
      cal_array(cal_idx,5) = QCAL1[cal_ctr:1];
      cal_array(cal_idx,6) = QCAL2[cal_ctr:1];
	  cal_array(cal_idx,7) = "";
	  if cal_array(cal_idx,5) in codeb,codet then
	    do preg = totocc(QWSEC2B_ROSTER1) while preg > 0 by (-1)
          calcmc = rowcmc(cal_ctr);
          if calcmc in ldc(preg):udc(preg) then
		    cal_array(cal_idx,7) = strip(Q218(preg));
		    break;
		  endif;
		enddo;
	  elseif cal_array(cal_idx,6) <> "" then
	    cal_array(cal_idx,7) = getlabel(QCAL_VS2,cal_array(cal_idx,6));
	  elseif !cal_array(cal_idx,5) in "" & cal_ctr < 72 & QCAL1[cal_ctr:1] <> QCAL1[cal_ctr+1:1] then
	    cal_array(cal_idx,7) = getlabel(QCAL_VS1,cal_array(cal_idx,5));
	  endif;
    enddo;
    // show calendar array
    showarray (tr("Calendar"), cal_array, cal_idx, title(tr("Year"), tr("Month"), tr("Row"), 
	           tr("Episode"), tr("Use"), tr("Disc"), tr("Label")));
  end;

  { function to assign births, current pregnancy and terminations to calendar }
  function FillC1Cal( event )
    { blank out working calendar column 1 }
    do i = 1 while i <= callen
      QCAL1[i:1] = " ";
      birthrow(i) = 0;
    enddo;
    { assign pregnancies outcomes along with pregnancy durations }
    do i = 1 while i <= totocc( QWSEC2B_ROSTER1 )
      if QLAST5(i) then
        xrow = cmcrow( ldc(i) );    { assign birth }
        pregtype = (Q216(i) = 1 | Q216(i) = 2 & Q217(i) = 1);
		if pregtype then
          QCAL1[xrow:1]  = codeb;
		else
          QCAL1[xrow:1]  = codet;
		endif;
        birthrow(xrow) = Q215L(i);
        do j = xrow + 1 while j <= callen & j <= xrow+Q221DUR(i)-1   { assign pregnancies }
          QCAL1[j:1]  = codep;
          birthrow(j) = Q215L(i);    { number of birth in calendar row j }
        enddo;
      endif;
    enddo;
    { assign current pregnancy along with its duration }
    if event >= 2 & Q232 = 1 & !special(Q233N) then
      do i = calint while i <= calint+Q233DUR-1    { first check that there are no data collisions }
        if QCAL1[i:1] <> " " then
          MnthYear( i );
          errmsg(82283, mnthstr1, year) select( tr("Currently pregnant"), Q232, tr("Duration of pregnancy"), Q233_BLOCK);
        endif;
      enddo;
      do i = calint while i <= calint+Q233DUR-1    { second assign pregnancies to calendar }
        QCAL1[i:1]  = codep;
        birthrow(i) = 77;           { code 77 is pregnancy in calendar row i }
      enddo;
    endif;
  end;

  { function to assign current method to the calendar based on date started using }
  function col1currm( cmcstart )
    if cmcstart >= calbeg then
      upto = cmcrow( cmcstart );
    else
      upto = callen;
    endif;
    meth    = MethInStr( Q307N, methoth );
    onemeth = methstr[meth:1];            { to check date started using any method }
    i = calint;
    while i <= callen & i <= upto do
      if QCAL1[i:1] = codeb | QCAL1[i:1] = codet then
        if i < upto then
          MnthYear( i );
          if QCAL1[i:1] = codeb then
		    if meth in stermeth, stermetm then
              errmsg( 83132, mnthstr1, year )
			    select( tr("Date started using") + " " + getlabel( Q307N, meth ), Q313_BLOCK,
				        tr("Current method"), Q307 );
			else
              errmsg( 83132, mnthstr1, year )
			    select( tr("Date started using") + " " + getlabel( Q307N, meth ), Q314_BLOCK,
				        tr("Current method"), Q307 );
			endif;
          else
		    if meth in stermeth, stermetm then
              errmsg( 83133, mnthstr1, year )
			    select( tr("Date started using") + " " + getlabel( Q307N, meth ), Q313_BLOCK,
				        tr("Current method"), Q307 );
			else
              errmsg( 83133, mnthstr1, year )
			    select( tr("Date started using") + " " + getlabel( Q307N, meth ), Q314_BLOCK,
				        tr("Current method"), Q307 );
			endif;
          endif;
        endif;
        i = i + 1;
        while i <= callen & i <= lds & QCAL1[i:1] = codep do
          i = i + 1;
        enddo;
        i = i - 1;
      else
        QCAL1[i:1] = onemeth;
      endif;
      i = i + 1;
    enddo;
  end;

  { function to identify the beginning and end of an interval between pregnancies or terminations }
  { going from the month of the interview down.  The function establishes two global variables    }
  { endrowint : the row where the open interval ends                                              }
  { begrowint : the row where the open interval begins                                            }
  function goingdown( rowbeg, occur )
    { find the beginning of the episode }
    calcode = QCAL1[rowbeg:1];
    endevent = rowbeg;
    cmcend = rowcmc( endevent );
    QCAUXM2(occur) = ( cmcend-1 ) % 12 + 1;
    QCAUXY2(occur) = int( (cmcend-1)/12 ) + 1900;
    do i = rowbeg while i <= callen & QCAL1[i:1] = calcode
    enddo;
    if i <= callen then
      begevent = i - 1;
      cmcbeg = rowcmc( begevent );
      QCAUXM1(occur) = ( cmcbeg-1 ) % 12 + 1;
      QCAUXY1(occur) = int( (cmcbeg-1)/12 ) + 1900;
    else
      begevent = callen;
      cmcbeg = rowcmc( begevent );
      QCAUXM1(occur) = ( cmcbeg-1 ) % 12 + 1;
      QCAUXY1(occur) = int( (cmcbeg-1)/12 ) + 1900;
    endif;
    endrowint = endevent;
    begrowint = begevent;
    { display( "going down occur=%02d rowbeg=%02d endevent=%d begevent=%d", occur, rowbeg, endrowint, begrowint ); }
  end;

  { clean the remains of the event to properly back-tab within the calendar }
  { the cleaning begins in the month following the episode until endrowint  }
  { endrowint : the row where the open interval ends                        }
  function CleanCal( rowbeg, occur )
    { display( "cleaning rowbeg=%04d endevent=%d", rowbeg, QCFEVENT(occur) ); }
    do i = rowbeg while i >= QCFEVENT(occur) by (-1)
      QCAL1[i:1] = " ";
      QCAL2[i:1] = " ";
    enddo;
  end;

  { function to close the gap between events }
  { going from the beginning of the event towards the month of the interview }
  function goingup( rowbeg, occur )
    { find the beginning of the episode }
    calcode = QCAL1[rowbeg-1:1];
    cmcbeg = rowcmc( rowbeg );
    QCAUXM1(occur) = ( cmcbeg ) % 12 + 1;
    QCAUXY1(occur) = int( (cmcbeg )/12 ) + 1900;
    do i = rowbeg-1 while i >= calint & QCAL1[i:1] = calcode by (-1)
    enddo;
    endevent = i + 1;
    cmcend = rowcmc( endevent );
    QCAUXM2(occur) = ( cmcend-1 ) % 12 + 1;
    QCAUXY2(occur) = int( (cmcend-1)/12 ) + 1900;
   { display( "going up occur=%02d Episode-begin=%d Episode-end=%d", occur, rowbeg, endevent ); }
  end;

  { function to customize text for the first part of the question for contraceptive use episodes }
  function textbegin( occur )
    cmcend = cmcode( Q317AM(occur), Q317AY(occur) );
    xrow   = cmcrow( cmcend );
//    display( "Row Begin=%d", xrow ); 
    if xrow >= callen then
      event1 = tr("(the beginning of the calendar)") + " ";
    elseif !pos( QCAL1[xrow+1:1], pregstr ) then
      if pos( QCAL1[xrow+1:1], methstr ) then
        event1 = tr("the time when you were using the") + " " + GetLabel(Q317C, QCAL1[xrow+1:1]);
      elseif xrow = calint & QCAL1[calint:1] = " " then
        event1 = tr("the month of the interview") + " ";
      else
        event1 = tr("the time when you were not using any method") + " ";
      endif;
    else
      if QCAL1[xrow+1:1] = codet then
        event1 = tr("the time when the") + " " + strip(Q218(birthrow(xrow+1))) + " " + tr("ended");
      elseif QCAL1[xrow+1:1] = codeb then
        event1 = tr("the time when") + " " + strip(Q218(birthrow(xrow+1))) + " " + tr("was born") + " ";
      elseif QCAL1[calint:1] = " " then
        event1 = tr("the month of the interview") + " ";
      elseif i < calint then
        event1 = tr("the time when the current pregnancy started") + " ";
      else
        event1 = tr("has an undefined error") + " ";
      endif;
    endif;
  end;

  { function to customize text for the second part of the question for contraceptive use episodes }
  function textend( occur )
    cmcbeg = cmcode( QCAUXM2(occur), QCAUXY2(occur) );
    xrow   = cmcrow( cmcbeg );
    { display( "Row=%d End=%02d/%04d", xrow, QCAUXM2(occur), QCAUXY2(occur) ); }
    if xrow-1 <= calint then
      event2 = tr("the month of the interview") + " ";
    elseif pos( QCAL1[xrow-1:1], pregstr ) then
      do i = xrow-1 while i >= calint & pos( QCAL1[i:1], pregstr ) by (-1)
      enddo;
      if QCAL1[i+1:1] = codeb then
        event2 = tr("the start of the pregnancy of") + " " + Q218(birthrow(i+1));
      elseif QCAL1[i+1:1] = codet then
        event2 = tr("the start of the pregnancy that ended in") + " " + Q218(birthrow(i+1)) + " ";
      elseif QCAL1[i+1:1] = codep then
        event2 = tr("the start of the current pregnancy") + " ";
      endif;
    elseif pos( QCAL1[xrow-1:1], methstr ) then
      event2 = tr("when you started to use the") + " " + GetLabel(Q317C, QCAL1[xrow-1:1]);
    else
      event2 = tr("when you were not using any method") + " ";
    endif;
  end;

  { function to handle the drinks popup for Q636 }
  function drinkgroups()
    foodfield = getsymbol();
	drinks_popup = 1;
	move to Q636Z;
  end;

  { function to handle the foods popup for Q637 }
  function foodgroups()
    foodfield = getsymbol();
	foods_popup = 1;
	move to Q637Z;
  end;
  
  { function to handle the food and drinks popup for Q643 }
  function foodgroupsW()
    foodfield = getsymbol();
	foods_popupW = 1;
	move to Q643Z;
  end;

  { function to display the relevant food and drinks popup for Q636, Q637, or Q643 }
  function fooddrinks()
    foodfield = getsymbol();
    if accept(tr("Display food or drink categories"),tr("Yes"),tr("No")) = 1 then
      if     pos("Q636",foodfield) & length(foodfield) = 5 & foodfield[5:1] in "A":"X" then drinkgroups()
      elseif pos("Q637",foodfield) & length(foodfield) = 5 & foodfield[5:1] in "A":"X" then foodgroups()
      elseif pos("Q643",foodfield) & length(foodfield) = 5 & foodfield[5:1] in "A":"X" then foodgroupsW()
	  else   display(tr("No food or drink categories exist for this question"))
	  endif;
	endif;
  end;

  array string vacc_array(20,3);
  { function to prepare an array of vaccinations and their dates for display (and selection for reentry) }
  function getvaccs(vc);
    { array elements:
	  1 - Name of vaccination
	  2 - Date of vaccination
	  3 - Name of variable for reentry
	}
    numeric v = 0;
	inc(v); vacc_array(v,3) = "D509B"  ; vacc_array(v,1) = "BCG"                            ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509B  (vc)), visualvalue(M509B  (vc)), visualvalue(Y509B  (vc)) );
	inc(v); vacc_array(v,3) = "D509H"  ; vacc_array(v,1) = "Hep.B at birth"                 ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509H  (vc)), visualvalue(M509H  (vc)), visualvalue(Y509H  (vc)) );
	inc(v); vacc_array(v,3) = "D509P0" ; vacc_array(v,1) = "Oral Polio at birth (OPV0)"     ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509P0 (vc)), visualvalue(M509P0 (vc)), visualvalue(Y509P0 (vc)) );
	inc(v); vacc_array(v,3) = "D509P1" ; vacc_array(v,1) = "Oral Polio (OPV) 1"             ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509P1 (vc)), visualvalue(M509P1 (vc)), visualvalue(Y509P1 (vc)) );
	inc(v); vacc_array(v,3) = "D509P2" ; vacc_array(v,1) = "Oral Polio (OPV) 2"             ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509P2 (vc)), visualvalue(M509P2 (vc)), visualvalue(Y509P2 (vc)) );
	inc(v); vacc_array(v,3) = "D509P3" ; vacc_array(v,1) = "Oral Polio (OPV) 3"             ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509P3 (vc)), visualvalue(M509P3 (vc)), visualvalue(Y509P3 (vc)) );
	inc(v); vacc_array(v,3) = "D509IPV"; vacc_array(v,1) = "Inactivated Polio Vaccine (IPV)"; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509IPV(vc)), visualvalue(M509IPV(vc)), visualvalue(Y509IPV(vc)) );
	inc(v); vacc_array(v,3) = "D509D1" ; vacc_array(v,1) = "DPT-Hep.B-Hib (Pentavalent) 1"  ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509D1 (vc)), visualvalue(M509D1 (vc)), visualvalue(Y509D1 (vc)) );
	inc(v); vacc_array(v,3) = "D509D2" ; vacc_array(v,1) = "DPT-Hep.B-Hib (Pentavalent) 2"  ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509D2 (vc)), visualvalue(M509D2 (vc)), visualvalue(Y509D2 (vc)) );
	inc(v); vacc_array(v,3) = "D509D3" ; vacc_array(v,1) = "DPT-Hep.B-Hib (Pentavalent) 3"  ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509D3 (vc)), visualvalue(M509D3 (vc)), visualvalue(Y509D3 (vc)) );
	inc(v); vacc_array(v,3) = "D509D4" ; vacc_array(v,1) = "DPT-Hep.B-Hib (Pentavalent) 4"  ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509D4 (vc)), visualvalue(M509D4 (vc)), visualvalue(Y509D4 (vc)) );
	inc(v); vacc_array(v,3) = "D509N1" ; vacc_array(v,1) = "Pneumococcal 1"                 ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509N1 (vc)), visualvalue(M509N1 (vc)), visualvalue(Y509N1 (vc)) );
	inc(v); vacc_array(v,3) = "D509N2" ; vacc_array(v,1) = "Pneumococcal 2"                 ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509N2 (vc)), visualvalue(M509N2 (vc)), visualvalue(Y509N2 (vc)) );
	inc(v); vacc_array(v,3) = "D509N3" ; vacc_array(v,1) = "Pneumococcal 3"                 ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509N3 (vc)), visualvalue(M509N3 (vc)), visualvalue(Y509N3 (vc)) );
	inc(v); vacc_array(v,3) = "D509R1" ; vacc_array(v,1) = "Rotavirus 1"                    ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509R1 (vc)), visualvalue(M509R1 (vc)), visualvalue(Y509R1 (vc)) );
	inc(v); vacc_array(v,3) = "D509R2" ; vacc_array(v,1) = "Rotavirus 2"                    ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509R2 (vc)), visualvalue(M509R2 (vc)), visualvalue(Y509R2 (vc)) );
	{inc(v); vacc_array(v,3) = "ZZZD509R3" ; vacc_array(v,1) = "Rotavirus 3"                    ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(ZZZD509R3 (vc)), visualvalue(ZZZM509R3 (vc)), visualvalue(ZZZY509R3 (vc)) );}
	inc(v); vacc_array(v,3) = "D509M1" ; vacc_array(v,1) = "Measles containing vaccine 1"   ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509M1 (vc)), visualvalue(M509M1 (vc)), visualvalue(Y509M1 (vc)) );
	{inc(v); vacc_array(v,3) = "ZZZD509M2" ; vacc_array(v,1) = "Measles containing vaccine 2"   ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(ZZZD509M2 (vc)), visualvalue(ZZZM509M2 (vc)), visualvalue(ZZZY509M2 (vc)) );}
	inc(v); vacc_array(v,3) = "D509V"  ; vacc_array(v,1) = "Vitamin A (most recent)"        ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509V  (vc)), visualvalue(M509V  (vc)), visualvalue(Y509V  (vc)) );
    getvaccs = v;
  end;

  { display the list of vaccinations prepared in the getvaccs function, and reenter if one is selected }
  function showvaccs(vc);
    numeric vacc, nvaccs;
    nvaccs = getvaccs(vc);
    vacc = showarray( maketext( "Vaccinations for %s. Select vaccination to modify or exit to continue", strip(Q503N(vc)) ), vacc_array, nvaccs,
          title( tr("Vaccination"), tr("Date of vaccination") ) );
    if vacc then
	  string vaccstr = vacc_array(vacc,3);
	  reenter vaccstr;
	endif;
  end;
  
  { function to determine if a blood pressure is valid }
  function ValidBP( xvar )  
    x = 0;
    if xvar in 1:900 then
	  x = 1;
    endif;
    ValidBP = x;
  end;	
  
  { function to determine the blood pressure test result }
  function BloodResult( systolic, diastolic )  
  recode systolic  :: diastolic -> $;
          0:129    ::     <84   -> 1;
          0:129    ::   85:89   -> 2;
          0:129    ::   90:99   -> 3;
          0:129    ::  100:109  -> 4;
          0:129    ::  110:119  -> 5;
          0:129    ::           -> 6;
        130:139    ::     <90   -> 2;
        130:139    ::   90:99   -> 3;
        130:139    ::  100:109  -> 4;
        130:139    ::  110:119  -> 5;
        130:139    ::           -> 6;
        140:159    ::    <100   -> 3;
        140:159    ::  100:109  -> 4;
        140:159    ::  110:119  -> 5;
        140:159    ::           -> 6;
        160:179    ::    <110   -> 4;
        160:179    ::  110:119  -> 5;
        160:179    ::           -> 6;
        180:209    ::    <120   -> 5;
        180:209    ::           -> 6;
          >=210    ::           -> 6;
                   ::           -> 0;
    endrecode;
  end;
  
  { displays blood pressure result for reporting form } 
  function DisplayBloodResult( systolic, diastolic, ires);    
	textstr1 = tr("Read aloud to the respondent the following information: \n");
    textstr1 = textstr1 + maketext(tr("Your final blood pressure is: Systolic=%d Diastolic=%d\n"), systolic, diastolic);
	textstr1 = textstr1 + maketext(tr("Your blood pressure category is: %s"), toupper(BloodCat(ires))) + " ";
	textstr1 = textstr1 + maketext(tr("Consult health provider to check blood pressure within: %s"), toupper(BloodCon(ires))); 
	textstr1 = textstr1 + maketext(tr("\n\nCircle %d in the blood pressure reporting form and "), ires ); 
	textstr1 = textstr1 + tr("then give the form to the respondent and answer any questions the respondent may have.");
	putnote(textstr1);
	textstr1 = editnote();
  end;	
  
  { function to get the right score for depression variables }
  function ScorePHQ( xvar )  
    x = 0;
    if xvar in 1:3 then
	  x = xvar;
    endif;
    ScorePHQ = x;
  end;	

{There is not Maternal Mortality in TJ23}
{
PROC AWSECMM_ROSTER
  err  = 0;
  aold = 100;
  iold = 0;
  if QMM11 = 0 then
    aold = Q111;
  endif;
  aoldest = aold;

  for i in $ do
    anew = aold;

    if QMM15 = 1 then           { sibling is still alive }
      if valid(QMM16) then      { sibling's age is valid }
        anew = QMM16;
      endif
    elseif QMM15 = 2 then       { sibling has died }
      if valid(QMM18) then      { age when they died }
        anew = QMM18;
        if valid(QMM17) then    { how many yrs ago did they die }
          anew = anew + QMM17
        endif;
      elseif valid(QMM17) then  { # yrs ago when they died }
        anew = QMM17            { Age would be at least this, probably more }
      endif;
    endif;

    if anew > aold then
      warning( 9000, i, anew, iold, aold )
	    select( maketext( tr("Status for") + " %s", QMM13N(i) ), QMM15(i),
	            maketext( tr("Status for") + " %s", QMM13N(iold) ), QMM15(iold),
				tr("Continue"), continue );
      err  = 1;
    elseif valid(QMM16) | valid(QMM17) & valid(QMM18) then
      aold = anew;
      iold = i;
    endif;

    if QMM11 = i then            { Check respondent against siblings }
      if Q111 > aold then
        warning( 9000, 0, Q111, iold, aold )
	      select( tr("Siblings born before respondent"), QMM11,
	              maketext( tr("Status for") + " %s", QMM13N(iold) ), QMM15(iold),
				  tr("Continue"), continue );
        err  = 1;
      else
        aold = Q111;
        anew = Q111;
        iold = 0;
      endif;
    endif;

    if aoldest = 100 then
      aoldest = aold;
    endif;

  enddo;

  if QMM07 > 1 & (aoldest - aold) > 30 then
    warning( 9001, aoldest, aold )
	  select( tr("Status for first sibling"), QMM15(1), tr("Continue"), continue );
  endif;
  if err then
    showroster( 2 );
  endif;
}

{PROC QM726
preproc
  if ZZZQM717 <> 1 then
    skip to ZZZQM729
  endif;

PROC QMM00
preproc
  $ = 1;

PROC QMM01
preproc
  if visualvalue(QMM10) = notappl then	{leave order number blank for now and return to fill order number after QMM10}
	skip to QMMMORE
  endif;

postproc
  do i = curocc()-1 while i by (-1)
    if QMM01 = QMM01(i) then
      errmsg( 9120, QMM01, QMM01(i) ) select( tr("Order numbers"), QMM01 );
  	endif;
  enddo;

PROC QMM01N
preproc
  if $ <> "" then
	advance to QMM01
  endif;

postproc
  if $(1) = "" then
    warning( 9110 ) 
	  select( tr("Modify"), $, tr("Continue"), continue);
	skip to QMM03
  endif;

PROC QMM03
preproc
  NSibs = count( AWSIBL_ROSTER where QMM01N <> "" );
  xMM03 = visualvalue(QMM03);
  xMM04 = visualvalue(QMM04);
  xMM05 = visualvalue(QMM05);
  xMM06 = visualvalue(QMM06);
  xMM08 = visualvalue(QMM08);
  xMM10 = visualvalue(QMM10);
  if NSibs = 0 then 
    skip to QMM04;
  endif;
  if     xMM08 <> notappl then advance to QMM08
  elseif xMM06 <> notappl then advance to QMM06
  elseif xMM05 <> notappl then advance to QMM05
  elseif xMM04 <> notappl then advance to QMM04
  endif;

postproc
  if $ = 1 & xMM03 <> 1 then
    if QMM01N(1) = "" then
      reenter QMM00
    else
      {QMMMORE(NSibs)=1;}
      reenter QMMMORE(NSibs);
	endif;
  endif;

PROC QMM04
preproc
  if     xMM08 <> notappl then advance to QMM08
  elseif xMM06 <> notappl then advance to QMM06
  elseif xMM05 <> notappl then advance to QMM05
  endif;

postproc
  if $ = 1 & xMM04 <> 1 then
    if QMM01N(1) = "" then
      reenter QMM00
    else
      {QMMMORE(NSibs)=1;}
      reenter QMMMORE(NSibs);
    endif;
  endif;

PROC QMM05
preproc
  if     xMM08 <> notappl then advance to QMM08
  elseif xMM06 <> notappl then advance to QMM06
  endif;

postproc
  if $ = 1 & xMM05 <> 1 then
    if QMM01N(1) = "" then
      reenter QMM00
    else
      {QMMMORE(NSibs)=1;}
      reenter QMMMORE(NSibs);
    endif;
  endif;

PROC QMM06
  if $ = 1 & xMM06 <> 1 then
    if QMM01N(1) = "" then
      reenter QMM00
    else
      {QMMMORE(NSibs)=1;}
      reenter QMMMORE(NSibs);
    endif;
  endif;

PROC QMM07
preproc
  $ = NSibs;

postproc
  if $ <> NSibs then
    errmsg( 9121, $, NSibs ) select( tr("Number of siblings"), QMMMORE(NSibs) );
  endif;

PROC QMM08
  if $ = 2 then
    if QMM01N(1) = "" then
      reenter QMM00
    else
      reenter QMMMORE(NSibs);
    endif;
  elseif QMM07 = 0 then	{no brother or sister and is correct}
    endgroup
  endif;

PROC QMM10
  { since total number of sibling is correct, now go back and enter order number of all the siblings }
  if $ = 1 then { go back and enter order number }
    if QMM01N(1) = "" then
      reenter QMM00
    else
      reenter QMM01N(1)
    endif;
  else
    if QMM01N(1) <> "" & QMM01(1) = notappl then
      errmsg( 9113 ) select( tr("Introduction Maternal Mortality"), QMM00 );
    endif;
  endif;

  if count(QMM01 where QMM01N <> "" & QMM01 in 1:NSibs) <> NSibs then
    errmsg( 9114, NSibs ) select( tr("Order numbers"), QMM01(1) );
  endif;

  { Check order number min=1, max=NSibs, no duplicate... }
  do i = 1 while i <= NSibs
    { check duplicate order number }
    do j = 1 while j <= NSibs
      if QMM01(i) = QMM01(j) & i <> j then
        errmsg( 9115, QMM01(i), i, j ) 
		  select( maketext( tr("Order number for") + " %s", QMM01N(i)), QMM01(i),
		          maketext( tr("Order number for") + " %s", QMM01N(j)), QMM01(j) );
      endif;
    enddo;
  enddo;

PROC QMM11
  if $ > QMM07 then
    errmsg( 9002 ) select( tr("Siblings born before respondent"), $ );
  endif;

  SaveData();

{ Maternal Mortality post-processing }
	
PROC QMM13
preproc
  do i = 1 while i <= maxsib
    if i <= QMM07 then
      QMM13(i)  = i;
{     QMM13N(i) = QMM01N(i);  }
 	    do j = 1 while j <= maxsib { & i <> QMM01(j) }
        if i = QMM01(j) then
          QMM13N(i) = QMM01N(j);
          break;
        endif;
      enddo;
    else
      QMM13(i) = notappl
    endif;
  enddo;
  SaveData();

  if curocc() > QMM07 then  { to run in-Batch }
    endgroup
  endif;

PROC QMM15
  if $ = 2 then
    skip to QMM17
  elseif $ <> 1 then
    skip to next QMM13
  endif;

PROC QMM16
  skip to next QMM13;

PROC QMM18
  if !valid($) | $ < 12 | QMM14 <> 2 then
    skip to QMM23
  endif;

PROC QMM19
  if $ = 1 then
    skip to QMM23
  endif;

PROC QMM20
  if $ = 1 then
    skip to next QMM13
  endif;

PROC QMM21
  if $ <> 1 then
    skip to QMM23
  endif;

PROC QMM23
  if $ = 1 then
    skip to next QMM13
  endif;

{ @@@ End Maternal Mortality for Women }

{ @@@ Begin Domestic Violence }
PROC QMMMORE
preproc
  if QMM01 <> notappl then  { Don't ask about more if already got full list and now getting order }
    noinput
  endif;

postproc
  if $ <> 1 then		{ this is the last sibling }
    endgroup
  endif;

PROC QWSECM2_FORM
preproc
  { skip maternal mortality if there are no siblings }
  if QMM07 = 0 then
    endgroup
  endif;

  if !matmortid then
    matmortid = userbar( add button, tr("Siblings"), showroster(2) );
  endif;

PROC ZZZD509M2
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    ZZZM509M2 = $;
    ZZZY509M2 = $*100+$;
    advance to D509V
  endif;

PROC ZZZD509R3
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    ZZZM509R3 = $;
    ZZZY509R3 = $*100+$;
    advance to D509M1
  endif;

PROC ZZZGC01
  if $ = 1 then
    skip to ZZZGC03
  endif;

PROC ZZZGC02
  if $ <> 1 then
    endgroup
  endif;

PROC ZZZGC03
  if $ <> 1 then
    endgroup
  endif;

PROC ZZZGC04
  if $ = 1 then
    skip to ZZZGC06
  endif;

PROC ZZZGC07
  if valid($) & $ < 95 & $ > agew then    { compare with current age }
    errmsg( 11050, agew ) select( tr("Age at circumcision"), $);
  endif;

PROC ZZZGC08
  majorgrp( $ );
  { Get other answer }
  if $ in 16,26 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZGC12
  if $ <> 1 then
    skip to next ZZZLINEGC;
  endif;

PROC ZZZGC13
  agedau = int( (di-ldc(ZZZGC11))/12 );        { daughter current age }
  if valid($) & $ < 95 & $ > agedau then    { compare with daughter's current age }
    errmsg( 11054, ZZZGC11, agedau )
	  select( tr("Daughter's age at circumcision"), $,
	          tr("Daughter's current age"), Q225(ZZZGC11) );
  endif;

PROC ZZZGC15
  majorgrp( $ );
  { Get other answer }
  if $ in 16,26 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;
  skip to next ZZZLINEGC;

PROC ZZZGC17
preproc
  if ZZZGC01 <> 1 & ZZZGC02 <> 1 then
    endgroup;
  endif;
{ @@@ End Female Genital Cutting Module for Women }

{ @@@ Begin early childhood development }
PROC ZZZGCM01
  if $ = 1 then
    skip to ZZZGCM03
  endif;

PROC ZZZGCM02
  if $ <> 1 then
    endgroup
  endif;
{ @@@ End Female Genital Cutting Module for Men }

PROC ZZZLINEGC
preproc
  if curocc() > daughter then
    endgroup;
  endif;

PROC ZZZQ1114
  if $ <> 1 then
    endgroup
  endif;

PROC ZZZQ1115
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQ130
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQ308
  if $ <> 1 then
    skip to Q314M
  endif;	

PROC ZZZQ309
  skip to Q314M;

PROC ZZZQ310
  { Get other answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  skip to Q314M

PROC ZZZQ311
  { Get other answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  skip to Q314M

PROC ZZZQ420
preproc
  if Q405 <> 1 then
    skip to Q426
  endif;

postproc
  if $ <> 1 then
    skip to ZZZQ423
  endif;

PROC ZZZQ421
  if $ in 2:7 then
    skip to Q426
  endif;

PROC ZZZQ423
  if $ <> 1 then
    skip to Q426
  endif;

PROC ZZZQ425
  if valid($) & $ > agew then
    warning( 4220, Q111 );
  endif;

PROC ZZZQ429
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC ZZZQ431
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

postproc
  if $ <> 1 then
    skip to Q434
  endif;

PROC ZZZQ432
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC ZZZQ433
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC ZZZQ728
  { Get other answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQ928
onfocus
  if evermarr then
    setvalueset( $, ZZZQ928_VS1 );
  else // exclude the husband/partner options for never married
    vs = ZZZQ928_VS1;
    vs.remove(2);
    vs.remove(4);
    setvalueset( $, vs );
  endif;

postproc
  if $ = 6 then
    skip to Q930A
  endif;

PROC ZZZQ929
  if $ <> 1 then
    skip to Q930A
  endif;

PROC ZZZQCOLECD
preproc
  if curocc() > childecd then
    endgroup
  endif;

PROC ZZZQECD6
  if $ <> 1 then
    skip to ZZZQECD8
  endif;	
{ @@@ End early childhood development }

{ @@@ Begin malaria knowledge and beliefs }
PROC ZZZQECDCA
preproc
  numeric nextbirth = 0;
  do i = Q212W while i > 0 by (-1)
    if Q224(i) = 1 & Q226(i) = 1 then
	  nextbirth = nextbirth + 1;
	  if nextbirth = ZZZQCOLECD then
	    $ = i;
		break;
	  endif;
    endif;	  
  enddo;

postproc
  ZZZQECDCN = Q218($);
  
PROC ZZZQFI1
  if $ = 1 then
    skip to ZZZQFI4
  endif;	

PROC ZZZQFI10
  if $ in 0,5 then
    errmsg( 9980 );
    reenter
  endif;	
{ @@@ End fistula module }

PROC ZZZQFI2
  if $ = 1 then
    skip to ZZZQFI4
  endif;	
  
PROC ZZZQFI3
  endgroup;

PROC ZZZQFI4
  x = count(QWSEC2B_ROSTER2 where Q223 = 1);  // counting live births
  y = count(QWSEC2B_ROSTER2 where Q223 = 2);  // counting stillbirths
  if $ = 1 & !x then
    warning( 9200 )
	  select( tr("Change this response"), $, tr("Begin reproduction"), Q201, tr("Continue"), continue );
  elseif $ = 2 & !y then
    warning( 9201 )
	  select( tr("Change this response"), $, tr("Begin reproduction"), Q201, tr("Continue"), continue );
  elseif $ = 6 then
    skip to ZZZQFI6
  endif;	
  
PROC ZZZQFI5
onfocus
  if ZZZQFI4 in 1,2 then
    textstr1 = GetValueLabel( ZZZQFI4 );
  else
    textstr1 = GetValueLabel( ZZZQFI6 );
  endif;
  
postproc
  skip to ZZZQFI7;
  
PROC ZZZQFI6
  if $ = 8 then
    skip to ZZZQFI8
  endif;	
  { Get other answer }
  if $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;  

PROC ZZZQFI8
  if $ = 1 then
    skip to ZZZQFI10
  endif;	
  
PROC ZZZQFI9
  $ = SortAlpha( $ );
  endgroup;

PROC ZZZQM101H
preproc
  savedata();

  if InEntry then
    n = totocc( QVISITS_ROSTER );
    $ = QVHOUR( n );
  endif;

PROC ZZZQM101M
preproc
  if InEntry then
    n = totocc( QVISITS_ROSTER );
    $ = QVMINUTE( n );
  endif;

PROC ZZZQM102
  if $ <> 96 then
    skip to ZZZQM104
  endif;

PROC ZZZQM103
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM104
  if $ = 96 & QH05(QLINE) = 1 then
    warning( 21031, QH05(QLINE) ) 
	  select( tr("Time living in place of interview"), $, tr("Continue"), continue );
  endif;
  if $ in 95,96 then
    skip to ZZZQM110M
  elseif !$ in 0:4 then
    skip to ZZZQM107
  endif;
  
PROC ZZZQM106Y
  di = cmcode(QINTM, QINTY);
  if afterint(ZZZQM106M,$,QINTM,QINTY) then
	errmsg( 89998 ) select( tr("Date move here"), ZZZQM106_BLOCK );
  endif;
  if validyr(ZZZQM106Y) then
    temp = setub(ZZZQM106M, ZZZQM106Y, 9999);
	if int((di-temp)/12) <> ZZZQM104 then
	  warning( 1035, ZZZQM104 ) 
	    select( tr("Date moved here"), ZZZQM106_BLOCK, 
	            tr("Years living in place of residence"), ZZZQM104,
				tr("Continue"), continue );
	endif;
  endif;

PROC ZZZQM109
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM111
  { Set up CMC for date of interview }
  di = cmcode( QINTM, QINTY );
  { Initial ranges for CMC date of birth }
  if validyr(ZZZQM110Y) then
    ldb = setlb( ZZZQM110M, ZZZQM110Y, 0 );
    udb = setub( ZZZQM110M, ZZZQM110Y, 9999 );
  else
    ldb = di - 779;             { !!! modify based on upper age of eligible men }
    udb = di - 180;
  endif;

  { Check either year of birth or age given for all men }
  if !validyr(ZZZQM110Y) & !valid($) then
    errmsg( 21060, ZZZQM110M, ZZZQM110Y, $ ) 
	  select( tr("Date of birth"), ZZZQM110_BLOCK, tr("Age"), $ );
  { Compare age of man with age in household to look for typos }
  elseif $ <> QH07(QLINE) & demode() = add then
    warning( 21061, $, QH07(QLINE) ) 
	  select( tr("Age"), $, tr("Continue"), continue );
  endif;

  { Adjust ranges for CMC date of birth based on age }
  if valid($) then
    { Lower bound of CMC }
    t = ndjlba( ldb, udb, di, di, $ );
    if t < 0 then
      errmsg( 21062, ZZZQM110M, ZZZQM110Y, $, QINTM, QINTY ) 
	    select( tr("Date of birth"), ZZZQM110_BLOCK, tr("Age"), $ );
    else
      ldb = t
    endif;
    { Upper bound of CMC }
    t = adjuba( ldb, udb, di, di, $ );
    if t < 0 then
      errmsg( 21062, ZZZQM110M, ZZZQM110Y, $, QINTM, QINTY ) 
	    select( tr("Date of birth"), ZZZQM110_BLOCK, tr("Age"), $ );
    else
      udb = t
    endif;
  endif;

  { calculate man's age }
  agem = int( (di - ldb) / 12 );

  { checks duration of current residence against age }
  if ZZZQM104 in 0:64 & ZZZQM104 > agem then
    warning( 21030, ZZZQM104 ) 
	  select( tr("Years living in place of residence"), ZZZQM104, 
	          tr("Age"), $,
              tr("Continue"), continue );
  endif;

PROC ZZZQM113
  if $ <> 1 then
    skip to ZZZQM117
  endif;

PROC ZZZQM114
  { Check education in individual questionnaire agrees with education in hh }
  if $ <> QH17A(QLINE) & demode() = add then
    warning( 21080, $, QH17A(QLINE) ) 
	  select( tr("Level of education"), $, tr("Continue"), continue );
  endif;

PROC ZZZQM115
onfocus
  grades.clear();
  grades.add(tr("Less than one year"), 0);
  n = maxgrade(ZZZQM114);
  do i = 1 while i <= n
    grades.add(maketext("Year %d", i), i);
    // change the above to match the terms used in the country
    // e.g. it might be "Year" that is used in most levels, but "Form" is used in secondary schooling
    // if ZZZQM114 = 2 then
    //   grades.add(maketext("Form %d", i), i);
    // else
    //   grades.add(maketext("Year %d", i), i);
    // endif;
  enddo;
  SetValueSet( $, grades );

postproc
  if !LevelYears( ZZZQM114, $ ) then
    errmsg( 21091 ) 
	  select( tr("Level of education"), ZZZQM114, tr("Grade/year/form"), $ );
  endif;

  { Check education in individual questionnaire agrees with education in hh }
  if $ <> QH17B(QLINE) & demode() = add then
    warning( 21090, $, QH17B(QLINE) ) 
	  select( tr("Grade/year/form"), $, tr("Continue"), continue );
  endif;

PROC ZZZQM117
preproc
  if ZZZQM114 = 3 then
    skip to ZZZQM119
  endif;

postproc
  if $ in 1,5 then
     skip to ZZZQM120
  { Get Other Answer }
  elseif $ = 4 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM122
  if $ <> 1 then
    skip to ZZZQM127
  endif;

PROC ZZZQM127
  if $ <> 1 then
    skip to ZZZQM130
  endif;

PROC ZZZQM128
  if $ <> 1 then
    skip to ZZZQM130
  endif;

PROC ZZZQM130
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM131
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM201
  if $ <> 1 then
    skip to ZZZQM206
  endif;

PROC ZZZQM202
  if $ <> 1 then
    skip to ZZZQM204
  endif;

PROC ZZZQM203B
  { Check for at least one child living at home - otherwise 202 must be 2 }
  if !ZZZQM203A & !$ then
    errmsg( 22030 ) select( tr("Any children living at home"), ZZZQM202, 
	                        tr("Number of children living at home"), AM203_BLOCK );
  endif;

PROC ZZZQM204
  if $ <> 1 then
    skip to ZZZQM206
  endif;

PROC ZZZQM205B
  { Check for at least one child living away from home - otherwise 204 must be 2 }
  if !ZZZQM205A & !$ then
    errmsg( 22030 ) select( tr("Any children living away"), ZZZQM204, 
	                        tr("Number of children living away"), AM205_BLOCK );
  endif;

PROC ZZZQM206
  if $ <> 1 then
    skip to ZZZQM208
  endif;

PROC ZZZQM207B
  { Check for at least one child to have died - otherwise 206 must be 2 }
  if !ZZZQM207A & !$ then
    errmsg( 22030 ) select( tr("Any boys or girls who died"), ZZZQM206, 
	                        tr("Number of boys or girls who died"), AM207_BLOCK );
  endif;

PROC ZZZQM208
preproc
  { Count up total children ever born }
  $ = NAtoZero(ZZZQM203A) + NAtoZero(ZZZQM203B) +
      NAtoZero(ZZZQM205A) + NAtoZero(ZZZQM205B) +
      NAtoZero(ZZZQM207A) + NAtoZero(ZZZQM207B);

postproc
  if ZZZQM208 = 0 & ZZZQM201 = 1 then
    errmsg( 22080 ) select( tr("Any children ever born"), ZZZQM201 );
  endif;

PROC ZZZQM209
  if $ <> 1 then
    reenter ZZZQM201
  elseif ZZZQM208 = 0 then
    endgroup
  elseif ZZZQM208 = 1 then
    skip to ZZZQM211
  endif;

PROC ZZZQM211
  if valid($) & $ > agem then
    errmsg( 22130, $, agem ) 
      select( tr("Age at birth of first child"), $, tr("Current age" ), ZZZQM111 );
  endif;
  SaveData();

PROC ZZZQM213
preproc
  { Count up living children }
  lchild = NAtoZero(ZZZQM203A) + NAtoZero(ZZZQM203B) +
           NAtoZero(ZZZQM205A) + NAtoZero(ZZZQM205B);
  if !lchild then
    endgroup
  endif;

postproc
  if valid($) & $+int(minabm/12) > agem then
    warning( 22140, $, agem, int(minabm/12) )
	  select( tr("Age of youngest child"), $,
	          tr("Current age"), ZZZQM111,
			  tr("Continue"), continue );
  endif;
  if !$ in 0:2 then
    endgroup
  endif;

PROC ZZZQM215
  if !pos( $[1:1], alphalst ) then
    errmsg( 89991 ) select( tr("Name"), $ );
  endif;

PROC ZZZQM216
  if $ <> 1 then
    skip to ZZZQM218
  endif;

PROC ZZZQM218
  if $ <> 1 then
    endgroup
  endif;

PROC ZZZQM301
preproc
  numeric oldvalm = visualvalue( $(ZZZQM3N) );
  if ZZZQM3N >= methoth then
    if visualvalue($(ZZZQM3N)) in 1,2 then
      $ = oldvalm;
    else
      $ = 2
    endif;
    noinput;
  endif;

onfocus
  methname = GetLabel( ZZZQM301, ZZZQM3N );

PROC ZZZQM301OT
  $ = SortAlpha( $ );
  { Get names of other methods }
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 3141 ) select( tr("Fix answers marked"), $ );
  endif;
  if pos( "A", $ ) then
    ZZZQM301(methoth) = 1
  else
    ZZZQM301(methoth) = 2
  endif;
  if pos( "B", $ ) then
    ZZZQM301(methoth+1) = 1
  else
    ZZZQM301(methoth+1) = 2
  endif;
  if pos( "A", $ ) then
    if demode() = add then
      display( tr("Record other modern method") );
	endif;
    getother( "Q301OT", methoth+10 );
    enter FL_OTHERS
  endif;
  if pos( "B", $ ) then
    if demode() = add then
      display( tr("Record other traditional method") );
	endif;
    getother( "Q301OT", methoth+11 );
    enter FL_OTHERS
  endif;

PROC ZZZQM304
  if $ <> 1 then
    skip to ZZZQM306;
  endif;

PROC ZZZQM305
  { Get Other Answer }
  if $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM307B
  SaveData();

PROC ZZZQM401
  wives = 0;                  { Initialized for later use }
  inunion = ( $ in 1,2 );

  if inunion then
    skip to ZZZQM404
  endif;

PROC ZZZQM402
  if $ = 3 then
    skip to ZZZQM414
  endif;

PROC ZZZQM403
  skip to ZZZQM410;

PROC ZZZQM405
  if $ <> 1 then
    wives = 1;
    skip to ZZZQM407
  endif;

PROC ZZZQM406
  wives = $;
  { if missing assume one wife }
  if !valid($) then wives = 1 endif;

PROC ZZZQM407
preproc
  { skip out of loop after last wife/partner entered }
  if curocc() > wives then
    endgroup;
  endif;

onfocus
  individuals.clear();
  do i = 1 while i <= QHMEMBER
    if QH04(i) = 2 & QH07(i) in 10:98,missing then
      individuals.add(QH02(i), i);
    endif;
  enddo;
  individuals.add( tr("Not a household member"), 0 );
  SetValueSet( $, individuals );

postproc
  { Check if line number is out of range }
  if $ > QHMEMBER | $ = QLINE then
    errmsg( 25060 ) select( tr("Line number of wife/partner"), $ );
  elseif $ <> 0 then
    { Check partner is female }
    if QH04($) <> 2 then
      errmsg( 25061, QH04($), $ ) select( tr("Line number of wife/partner"), $ );
    { Check partner is at least age 12 }
    elseif valid( QH07($) ) & QH07($) < 12 then
      warning( 25062, QH07($), $, 12 )
	    select( tr("Line number of wife/partner"), $, tr("Continue"), continue );    
	endif;
    { Check relationship of respondent to partner }
    x = QH03(QLINE);
    y = QH03($);
    recode x :: y                 -> err;
           1 :: 2                 -> 0;
           2 :: 1                 -> 0;
           3 :: 4                 -> 0;
           4 :: 3                 -> 0;
           5 :: 9                 -> 0;
           6 :: 6                 -> 0;
           7 :: 7                 -> 0;
           8 :: 9                 -> 0;
           9 :: 5,8:11,98         -> 0;
       10:11 :: 10:11             -> 0;
  98,missing :: 10,11,98,missing  -> 0;
             ::                   -> 1;
    endrecode;
    if err then
      warning( 25064, $, x, y )
	    select( tr("Line number of wife/partner"), $, tr("Continue" ), continue );
    endif;
    { line number cannot be equal to any preceding line number }
    do n = curocc()-1 while n by (-1)
      if ZZZQM407(n) = ZZZQM407 then
        errmsg( 25065, ZZZQM407 )select( tr("Line number of wife/partner"), $ );
      endif;
    enddo;
  endif;

PROC ZZZQM408
onfocus
  if ZZZQM407 in 1:QHMEMBER then
    textstr1 = strip(QH02(ZZZQM407))
  else
    textstr1 = tr("this wife or partner");
  endif;

postproc
  { Check wife's age with age declared in the household }
  if demode() = add & ZZZQM407 & valid(QH07(ZZZQM407)) & $ <> QH07(ZZZQM407) then
    warning( 25068, QH07(ZZZQM407) )
	  select( tr("Age of wife/partner"), $, tr("Continue"), continue );
  endif;

PROC ZZZQM410
preproc
  if wives > 1 then
    skip to ZZZQM411_BLOCK
  endif;

PROC ZZZQM411_BLOCK
onfocus
  marriages = ( wives > 1 | ZZZQM410 = 1 );
  
PROC ZZZQM411Y
  numeric ageatm;
  { Check date of marriage before interview }
  if afterint( ZZZQM411M, $, QINTM, QINTY ) then
    errmsg( 9992 ) select( tr("Date of 1st union"), ZZZQM411_BLOCK );
  { Compute CMC date of marriage }
  elseif validyr($) then
    ldm = setlb( ZZZQM411M, $, 0 );
    udm = setub( ZZZQM411M, $, 9999 );
	ageatm = int((ldm-udb)/12);
	if ageatm < 10 then
	  warning( 5140, ageatm )
	    select( tr("Date of 1st union"), ZZZQM411_BLOCK, tr("Continue" ), continue );
	elseif ageatm > agem then
	  errmsg( 5141, ageatm, agem )
	    select( tr("Date of 1st union"), ZZZQM411_BLOCK );
	endif;
    skip to ZZZQM414
  endif;

PROC ZZZQM412
  if valid($) then
    ldm = ldb+$*12;
    udm = udb+$*12+11;
    if ldm > di then
      if demode() = add then
        warning( 25130, QINTM, QINTY, ZZZQM110M, ZZZQM110Y, agem, ZZZQM411M, ZZZQM411Y, ZZZQM412 )
		  select( tr("Date of 1st union"), ZZZQM411_BLOCK, 
		          tr("Age at 1st union"), $, 
				  tr("Continue"), continue );
      endif
    elseif udm > di then
      udm = di;
    endif;
  else
    { No age and year at marriage given }
    if demode() = add then
      warning( 25135, ZZZQM412, ZZZQM411M, ZZZQM411Y )
	    select( tr("Date of 1st union"), Q715_BLOCK, 
	            tr("Age at 1st union"), $, 
			    tr("Continue"), continue );
    endif;
    { Set outer ranges for date of marriage }
    ldm = ldb+minamm;
    udm = di;
  endif;

PROC ZZZQM414
preproc
  { consistency of date of marriage is done here because age at marriage
    is not asked to all the respondents }
  if demode() = add & ZZZQM411M <> notappl then  { if ever married }
    if ldm > udm then
      warning( 25121, int(minamm/12), ZZZQM110M, ZZZQM110Y, agem, ZZZQM411M, ZZZQM411Y, ZZZQM412 )
  		select( tr("Date of 1st union"), ZZZQM411_BLOCK, 
		        tr("Age at 1st union"), ZZZQM412,
				tr("Current age"), ZZZQM111,
			    tr("Continue"), continue );

    elseif ldm > di then
      warning( 25120, ZZZQM411M, ZZZQM411Y, ZZZQM412, QINTM, QINTY, ZZZQM110M, ZZZQM110Y, agem )
  		select( tr("Date of 1st union"), ZZZQM411_BLOCK, 
		        tr("Age at 1st union"), ZZZQM412,
				tr("Current age"), ZZZQM111,
			    tr("Continue"), continue );
    endif;
  endif;

postproc
  if $ = 0 then
    if ZZZQM208 > 0 then           {have kids}
      errmsg( 25150 ) select( tr("Age at first intercourse"), $ );
    elseif wives > 0 then
      if demode() = add then
        warning( 25151, wives, ZZZQM401, ZZZQM402 )
		  select( tr("Age at first intercourse"), $, 
		          tr("Marital status"), ZZZQM401,
		          tr("Continue"), continue );
      endif;
    endif;
  elseif $ = 95 & ZZZQM402 = 3 then
    errmsg( 25192 ) select( tr("Age at first intercourse"), $ );
  elseif valid($) & $ < 95 then
    if $ > agem then
      warning( 25190, QINTM, QINTY, ZZZQM110M, ZZZQM110Y, ZZZQM111, $ )
	    select( tr("Age at first intercourse"), $, 
 		        tr("Current age"), ZZZQM111, 
		        tr("Continue"), continue );
    endif
  endif;

  { Set up ever married status for later use }
  evermarr = ( ZZZQM401 in 1,2 | ZZZQM402 in 1,2 );
  if $ = 0 then
    endgroup;
  endif;

PROC ZZZQM415N
onfocus
  protect( ZZZQM415U, false );

PROC ZZZQM415U
preproc
  if ZZZQM415N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  badspecial( $, ZZZQM415N, getsymbol() );

  recode ZZZQM415U :: ZZZQM415N -> err;
            3   :: >=12   -> 1;
            2   :: >=52   -> 1;
          <>1   :: 0      -> 1;
                ::        -> 0;
  endrecode;
  if err then
    errmsg( 9994 ) select( tr("Number"), ZZZQM415N, tr("Unit"), ZZZQM415U );
  elseif ZZZQM415U = 4 & ZZZQM415N > agem then
    errmsg( 25193, ZZZQM415U, ZZZQM415N, agem )
	  select( tr("Time since last sex"), ZZZQM415_BLOCK, 
 	          tr("Current age"), ZZZQM111, 
		      tr("Continue"), continue );
  endif;
  if ZZZQM415U in 4,9 then
    skip to ZZZQM429
  endif;

PROC ZZZQM416
  if $ = 1 then
    skip to ZZZQM418
  endif;

PROC ZZZQM417
  skip to ZZZQM419;

PROC ZZZQM418
  $ = SortAlpha( $ );
  { !!! if ever use in contraceptive table make sure to check against that rather than knowledge
        In DHS-8 a one to one relationship between current use and contraceptive table          }
  y = length( strip($) );
  do x = 1 while x <= y
    meth = pos( $[x:1], am439str );
    if ZZZQM301(meth) <> 1 then               { other methods should be known }
      errmsg( 23142, GetLabel(ZZZQM418, $[x:1]) ) select( tr("Method used"), $ );
    endif;
  enddo;
  if poschar( "GH",$ ) then
    skip to ZZZQM420;
  endif;	

PROC ZZZQM419
  if $ = 1 & ZZZQM301(7) <> 1 then
    warning( 26280 ) 
	  select( tr("Used condom during last intercourse"), $,
	          tr("Knowledge of condom"), ZZZQM301(7),
			  tr("Continue"), continue );
  endif;
  if $ <> 1 then
    skip to ZZZQM422
  endif;

PROC ZZZQM420
  if $ = 96 then
    getother(GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM421
  majorgrp( $ );
  { Get other answer }
  if $ in 16,27,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM422
  if $ = 1 & !evermarr then
    warning( 25240, ZZZQM401, ZZZQM402 )
      select( tr("Relationship with last sex partner"), $,
	          tr("Marital status"), ZZZQM401,
		      tr("Continue"), continue );
  elseif $ = 2 & ZZZQM402 = 3 then
    warning( 25241, ZZZQM401, ZZZQM402 )
      select( tr("Relationship with last sex partner"), $,
	          tr("Marital status"), ZZZQM401,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "Q730", 10 );      // use same question as for women
    enter FL_OTHERS
  endif;

PROC ZZZQM423
  if $ <> 1 then
    skip to ZZZQM429
  endif;

PROC ZZZQM425
  if $ = 1 & !evermarr then
    warning( 25240, ZZZQM401, ZZZQM402 )
      select( tr("Relationship with prior sex partner"), $,
	          tr("Marital status"), ZZZQM401,
		      tr("Continue"), continue );
  elseif $ = 2 & ZZZQM402 = 3 then
    warning( 25241, ZZZQM401, ZZZQM402 )
      select( tr("Relationship with prior sex partner"), $,
	          tr("Marital status"), ZZZQM401,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "Q730", 11 );      // use same question as for women
    enter FL_OTHERS
  endif;

PROC ZZZQM426
  if $ <> 1 then
    skip to ZZZQM429
  endif;

PROC ZZZQM428
  if $ = 1 & !evermarr then
    warning( 25240, ZZZQM401, ZZZQM402 )
      select( tr("Relationship with third prior sex partner"), $,
	          tr("Marital status"), ZZZQM401,
		      tr("Continue"), continue );
  elseif $ = 2 & ZZZQM402 = 3 then
    warning( 25241, ZZZQM401, ZZZQM402 )
      select( tr("Relationship with third prior sex partner"), $,
	          tr("Marital status"), ZZZQM401,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "Q730", 12 );      // use same question as for women
    enter FL_OTHERS
  endif;

PROC ZZZQM429
  sexp = 1 + (ZZZQM423 = 1) + (ZZZQM426 = 1);
  if valid($) & $ < sexp then
    warning( 25245, sexp )
      select( tr("Lifetime number of sex partners"), $, tr("Continue"), continue );
  endif;
  SaveData();

PROC ZZZQM504
preproc
  { not in union or man sterilized }
  { Note that alpha variables stay in memory when backtracking, thus ZZZQM416 needs to be included! }
  if !inunion | pos("B", ZZZQM418) then
    skip to ZZZQM514
  elseif wives > 1 then
    skip to ZZZQM509
  endif;

postproc
  if $ <> 1 then
    skip to ZZZQM507;
  endif;

PROC ZZZQM505
  if $ <> 1 then
    skip to ZZZQM514
  endif;

PROC ZZZQM506N
onfocus
  protect( ZZZQM506U, false );

postproc
  { Check special answers }
  if $ = 96 then
    getother( "Q805N", 10 );
    enter FL_OTHERS
  endif;

PROC ZZZQM506U
preproc
  if ZZZQM506N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, ZZZQM506N, getsymbol() );

  skip to ZZZQM514;

PROC ZZZQM507
  if $ <> 1 then
    skip to ZZZQM514
  endif;

PROC ZZZQM508N
onfocus
  protect( ZZZQM508U, false );

postproc
  if $ = 96 then
    getother( "Q805N", 11 );   { !!! record others for time to next child in the same question }
    enter FL_OTHERS
  endif;

PROC ZZZQM508U
preproc
  if ZZZQM508N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, ZZZQM508N, getsymbol() );

  skip to ZZZQM514;

PROC ZZZQM509
  if $ <> 1 then
    skip to ZZZQM512
  endif;

PROC ZZZQM510
  if $ <> 1 then
    skip to ZZZQM514
  endif;

PROC ZZZQM511N
onfocus
  protect( ZZZQM511U, false );

postproc
  if $ = 96 then
    getother( "Q805N", 12 );   { !!! record others for time to next child in the same question }
    enter FL_OTHERS
  endif;

PROC ZZZQM511U
preproc
  if ZZZQM511N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, ZZZQM511N, getsymbol() );

  skip to ZZZQM514;

PROC ZZZQM512
  if $ <> 1 then
    skip to ZZZQM514
  endif;

PROC ZZZQM513N
onfocus
  protect( ZZZQM513U, false );

postproc
  if $ = 96 then
    getother( "Q805N", 13 );   { !!! record others for time to next child in the same question }
    enter FL_OTHERS
  endif;

PROC ZZZQM513U
preproc
  if ZZZQM513N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, ZZZQM513N, getsymbol() );

PROC ZZZQM514
onfocus
  lchild = NAtoZero(ZZZQM203A) + NAtoZero(ZZZQM203B) +
           NAtoZero(ZZZQM205A) + NAtoZero(ZZZQM205B);

postproc
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  if $ in 0,96 then
    endgroup
  endif;

PROC ZZZQM515B
preproc
  if ZZZQM515A = 96 then
    $ = 96;
    noinput
  endif;

postproc
  if ($ = 96 <=> ZZZQM515A <> 96) | ($ = missing <=> ZZZQM515A <> missing) then
    errmsg( 9994 ) select( tr("Boys"), ZZZQM515A, tr("Girls"), $ );
  endif;

PROC ZZZQM515C
preproc
  if ZZZQM515A = 96 then
    $ = 96;
    noinput
  endif;

postproc
  if ($ = 96 <=> ZZZQM515A <> 96) | ($ = missing <=> ZZZQM515A <> missing) then
    errmsg( 9994 ) select( tr("Boys"), ZZZQM515A, tr("Girls"), ZZZQM515B, 
	                       tr("Either"), $, tr("Total"), ZZZQM514 );
  elseif valid(ZZZQM515A) & valid(ZZZQM515B) & valid($) & $ < 96 &
         ZZZQM515A+ZZZQM515B+$ <> ZZZQM514 then
    errmsg( 26131 )
      select( tr("Ideal number of children by sex"), AM515_BLOCK,
	          tr("Ideal number of children"), ZZZQM514 );
  endif;

  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  SaveData();

PROC ZZZQM601
  if $ = 1 then
    skip to ZZZQM604
  endif;

PROC ZZZQM602
  if $ = 1 then
    skip to ZZZQM604
  endif;

PROC ZZZQM603
  if $ <> 1 then
    skip to ZZZQM609;
  endif;

PROC ZZZQM604
  { !!! it is possible that all textual occupation needs to recorded }
  if $ = 96 then
    getother( "Q908", 2 );   { !!! record others for occupation in the same question }
    enter FL_OTHERS
  endif;

PROC ZZZQM609
preproc
  { no wives or not earnings in cash }
  if !inunion then
    skip to ZZZQM612;
  elseif !ZZZQM606 in 1,2 then
    skip to ZZZQM610
  endif;

postproc
  if $ in 2,3 & !inunion then
    warning( 27250, $, ZZZQM401 )
      select( tr("Person deciding how earnings are used"), $,
	          tr("Marital status"), ZZZQM401,
		      tr("Continue"), continue );
  { Get Other answer }
  elseif $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM610
  if $ in 2,3 & !inunion then
    warning( 27250, $, ZZZQM401 )
      select( tr("Final say on health care"), $,
 	          tr("Marital status"), ZZZQM401,
		      tr("Continue"), continue );
  endif;

PROC ZZZQM611
  if $ in 2,3 & !inunion then
    warning( 27250, $, ZZZQM401 )
      select( tr("Final say on large purchases"), $,
	          tr("Marital status"), ZZZQM401,
		      tr("Continue"), continue );
  endif;

PROC ZZZQM612
onfocus
  if evermarr then
    setvalueset( $, ZZZQM612_VS1 );
  else // exclude the husband/partner options for never married
    vs = ZZZQM612_VS1;
    vs.remove(2);
    vs.remove(4);
    setvalueset( $, vs );
  endif;

postproc
  if $ = 6 then
    skip to ZZZQM615
  endif;

PROC ZZZQM613
  if $ <> 1 then
    skip to ZZZQM615
  endif;

PROC ZZZQM615
onfocus
  if evermarr then
    setvalueset( $, ZZZQM615_VS1 );
  else // exclude the husband/partner options for never married
    vs = ZZZQM615_VS1;
    vs.remove(2);
    vs.remove(4);
    setvalueset( $, vs );
  endif;

postproc
  if $ = 6 then
    skip to ZZZQM617A
  endif;

PROC ZZZQM616
  if $ <> 1 then
    skip to ZZZQM617A
  endif;

PROC ZZZQM617A
  if $ <> 1 then
    skip to ZZZQM617C
  endif;

PROC ZZZQM619
  SaveData();

PROC ZZZQM701
  if $ <> 1 then
    skip to ZZZQM729
  endif;

PROC ZZZQM703
preproc
  if agem >= 25 then
    skip to ZZZQM708
  endif;

PROC ZZZQM710
  if $ <> 1 then
    skip to ZZZQM713;
  endif;

PROC ZZZQM713
  if $ <> 1 then
    skip to ZZZQM721
  endif;

PROC ZZZQM714Y
  if afterint(ZZZQM714M,$,QINTM,QINTY) then
	errmsg( 89998 ) select( tr("Date most recent HIV test"), ZZZQM714_BLOCK );
  endif;
  ldth = setlb( ZZZQM714M, ZZZQM714Y, 0 );
  if ldth < ldb then
    errmsg( 11012, ZZZQM110M, ZZZQM110Y ) select( tr("Date most recent HIV test"), ZZZQM714_BLOCK );
  endif;

PROC ZZZQM715
  majorgrp( $ );
  if $ in 16,27,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQM716
  if $ <> 1 then
    skip to ZZZQM720
  endif;

PROC ZZZQM717
  if $ <> 1 then
    skip to ZZZQM720
  endif;	

PROC ZZZQM718M
  if $ = 95 then
    skip to ZZZQM719
  endif;

PROC ZZZQM718Y
  if afterint(ZZZQM718M,$,QINTM,QINTY) then
	errmsg( 89998 ) select( tr("Date tested positive"), ZZZQM718_BLOCK );
  endif;
  udth = setlb( ZZZQM718M, ZZZQM718Y, 9999 );
  if udth > ldth+1 then   // give one month to allow time to get results from last test
    errmsg( 11010 ) 
	  select( tr("Date tested positive"), ZZZQM718_BLOCK,
              tr("Date most recent HIV test"), ZZZQM714_BLOCK );	  
  endif;
  if udth < ldb then
    errmsg( 11011, ZZZQM110M, ZZZQM110Y ) select( tr("Date tested positive"), ZZZQM718_BLOCK );
  endif;

PROC ZZZQM721
  if $ <> 1 then
    skip to ZZZQM723
  endif;

PROC ZZZQM732
preproc
  if ZZZQM414 = 0 then
    skip to ZZZQM735
  elseif ZZZQM729 <> 1 then
    skip to ZZZQM733
  endif;

PROC ZZZQM801
  if $ <> 1 then
    skip to ZZZQM806
  endif;

PROC ZZZQM802
  if $ <> 1 then
    skip to ZZZQM804
  endif;

PROC ZZZQM803
  if valid($) & $ < 95 & $ > agem then
    errmsg(11050, agem) select( tr("Age at traditional circumcision"), $);
  endif;  

PROC ZZZQM804
  if ZZZQM802 = 2 & $ = 2 then
    errmsg(11055) select(tr("Circumcision"), ZZZQM801, tr("Traditional"), ZZZQM802, tr("Medical"), $ );
  endif;	
  if ZZZQM802 = 2 & $ = 8 | ZZZQM802 = 8 & $ = 2 then
    warning(11056) select(tr("Circumcision"), ZZZQM801, tr("Traditional"), ZZZQM802, 
	                      tr("Medical"), $, tr("Continue"), continue );
  endif;	
  if $ <> 1 then
    skip to ZZZQM806
  endif;
  
PROC ZZZQM805
  if valid($) & $ < 95 & $ > agem then
    errmsg(11050, agem) select( tr("Age at medical circumcision"), $);
  endif;  

PROC ZZZQM806
  if $ = 1 then
    skip to AM809_BLOCK
  elseif $ <> 2 then
    skip to ZZZQM808
  endif;

PROC ZZZQM807
  skip to ZZZQM810A;

PROC ZZZQM808
  skip to ZZZQM811;

PROC ZZZQM809G
  if $ in 1:300,888 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  skip to ZZZQM811;

PROC ZZZQM810G
  if $ in 1:300,888 then
    getother( "ZZZQM809G", 1 );
    enter FL_OTHERS
  endif;

PROC ZZZQM811
  if $ = 2 then
    skip to AM813_BLOCK
  elseif $ <> 1 then
    skip to ZZZQM814
  endif;

PROC ZZZQM812E
  if $ in 1:300,888 then
    getother( "ZZZQM809G", 2 );
    enter FL_OTHERS
  endif;
  skip to ZZZQM814;

PROC ZZZQM813E
  if $ in 1:300,888 then
    getother( "ZZZQM809G", 3 );
    enter FL_OTHERS
  endif;

PROC ZZZQM814
  if $ <> 1 then
    skip to ZZZQM817
  endif;

PROC ZZZQM815
  if $ = 0 then
    skip to ZZZQM817
  endif;

PROC ZZZQM817
  if $ <> 1 then
    endgroup
  endif;

PROC ZZZQM818
  $ = SortAlpha( $ );
  { get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

{ @@@ Begin Female Genital Cutting Module for Men }
PROC ZZZQM819H
preproc
  if visualvalue( $ ) = notappl then
    time = systime();
    $ = int( time/10000 );
  endif;

PROC ZZZQM819M
preproc
  if visualvalue( $ ) = notappl then
    time = systime();
    $ = int( time/100 ) % 100;
  endif;
  { @@@ End Men's Questionnaire }

PROC ZZZQML501
  if $ <> 1 then
    skip to ZZZQML503
  endif;	
  
PROC ZZZQML502 
  $ = SortAlpha( $ );
  { Check "Don't remember" is only response }
  if pos( "Z", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  endif;
  
PROC ZZZQML503
  if $ <> 1 then
    skip to ZZZQML505
  endif;	
  
PROC ZZZQML504 
  $ = SortAlpha( $ );
  { Check "Don't know" is only response }
  if pos( "Z", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  endif;
{ @@@ End malaria knowledge and beliefs }

{ @@@ Begin fistula module }
PROC ZZZQMSEC3A_FORM
preproc
  do i = 1 while i <= maxocc( ZZZQMSEC3A_GRP )
    ZZZQM3N(i) = i
  enddo;

{ The logic used in QALLMETH should be replicated here if the spontaneous knowledge of method is used }
{ If that is the case ZZZQMALLMETH is the variable to be used for men                                    }

PROC ZZZQMTH2
preproc
  numeric symptoms;
  symptoms = (ZZZQMTHGAD1 in 1:3) + (ZZZQMTHGAD2 in 1:3) + (ZZZQMTHGAD3 in 1:3) + (ZZZQMTHGAD4 in 1:3) + 
             (ZZZQMTHGAD5 in 1:3) + (ZZZQMTHGAD6 in 1:3) + (ZZZQMTHGAD7 in 1:3) + 
			 (ZZZQMTHPHQ1 in 1:3) + (ZZZQMTHPHQ2 in 1:3) + (ZZZQMTHPHQ3 in 1:3) + (ZZZQMTHPHQ4 in 1:3) + 
			 (ZZZQMTHPHQ5 in 1:3) + (ZZZQMTHPHQ6 in 1:3) + (ZZZQMTHPHQ7 in 1:3) + (ZZZQMTHPHQ8 in 1:3) + 
			 (ZZZQMTHPHQ9 in 1:3); 
  if !symptoms then			 
    skip to ZZZQMTH4A
  endif;	
  
postproc  
  if $ <> 1 then			 
    skip to ZZZQMTH4A
  endif;	

PROC ZZZQMTH3
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC ZZZQMTH6
preproc
  $ = ScorePHQ(ZZZQMTHPHQ1) + ScorePHQ(ZZZQMTHPHQ2) + ScorePHQ(ZZZQMTHPHQ3) + ScorePHQ(ZZZQMTHPHQ4) + 
	  ScorePHQ(ZZZQMTHPHQ5) + ScorePHQ(ZZZQMTHPHQ6) + ScorePHQ(ZZZQMTHPHQ7) + ScorePHQ(ZZZQMTHPHQ8) + 
	  ScorePHQ(ZZZQMTHPHQ9); 
	  
PROC ZZZQMTH8
preproc
  if !(ZZZQMTH6 >= 10 | ZZZQMTHPHQ9 in 1:3) then
    endgroup
  endif;	
	  
PROC ZZZQWSECECD_FORM
preproc
  { initialize variables used to count entries for different sections }
  QESECECD = 0;
  numeric fullcdc, livcdc, livcmc;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  childecd = 0;
  fullcdc = count(QWSEC2B where Q220CD <> 0);
  if Q212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if Q224(i) = 1 & Q226(i) = 1 & int((dicdc - Q220CD(i))/DaysMonth) in 24:59 then
	    childecd = childecd + 1;
        do j  = i+1 while j <= totocc(QWSEC2B_ROSTER2)
          if Q224(j) = 1 & Q226(i) = 1then
	        childecd = childecd + 1;
		  endif;
		enddo;
		break;
	  endif;
	enddo;
	indexpreg = i;
  else
    { count pregnancies based on CDC codes } 
	do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if Q224(i) = 1 & Q226(i) = 1 & int((dicdc - Q220CD(i))/DaysMonth) in 24:59 then
	    livcdc = livcdc + 1;               // assume remaining pregnancies occurred after this one
        do j  = i+1 while j <= totocc(QWSEC2B_ROSTER2)
          if Q224(j) = 1 & Q226(i) = 1 then
	        livcdc = livcdc + 1;
		  endif;
		enddo;
		break;
	  endif; 
	enddo;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if Q224(i) = 1 & Q226(i) = 1 & (di-udc(i) in 24:59 | di-udc(i) in 24:59) then
	    livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
        do j = i+1 while j <= totocc(QWSEC2B_ROSTER2)
          if Q224(j) = 1 & Q226(i) = 1 then
            livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
          endif; 
        enddo;
		break;
	  endif; 
	enddo;
	indexpreg2 = i;
	childecd = livcdc;
	if livcmc > livcdc then childecd = livcmc; indexpreg = indexpreg2 endif;
  endif;  
  if !childecd then 
    endgroup
  endif;
  QESECECD = childecd;
  do i = 1 while i <= 4
    if i <= childecd then
      ZZZQCOLECD(i) = i;
    else
      ZZZQCOLECD(i) = notappl;
    endif;
  enddo;
  
PROC ZZZQWSECG2_ROSTER
preproc
  if ZZZGC01 <> 1 & ZZZGC02 <> 1 then
    endgroup;
  endif;

  { !!! count daughters currently alive and born in daughty or later, adjust year accordingly }
  daughter = 0;
  for i in QWSEC2B do
    if Q219(i) = 2 & Q224(i) = 1 & udc(i) >= cmcode(1,daughty) then
      daughter = daughter + 1;
    endif;
  enddo;
  ZZZGCDAUGHT = daughter;
  { if no living daughters }
  if !ZZZGCDAUGHT then
    endgroup;
  endif;
  do i = 1 while i <= 20
    if i <= daughter then
      ZZZLINEGC(i) = i;
    else
      ZZZLINEGC(i) = notappl;
    endif;
  enddo;
  { populate names coming from birth history }
  j = 1;
  for i in QWSEC2B do
    if Q219(i) = 2 & Q224(i) = 1 & udc(i) >= cmcode(1,daughty) then
      ZZZGC11(j)   = Q215L(i);
      ZZZGC11N(j)  = Q218(i);
      if android then 
        setocclabel(ZZZQWSECG2_ROSTER(j),strip(Q218(i)));
      endif;
      j = j + 1;
    endif;
  enddo;

PROC ZZZY509M2
  vcheck  ( ZZZD509M2, ZZZM509M2, $ );
  vckbirth( ZZZD509M2, ZZZM509M2, $, Q503 );

PROC ZZZY509R3
  vcheck  ( ZZZD509R3, ZZZM509R3, $ );
  vckbirth( ZZZD509R3, ZZZM509R3, $, Q503 );
}

PROC TJIN80_FF
preproc

  { Get the system date to ensure the date is set up correctly }
  sday   = sysdate("dd");
  smonth = sysdate("mm");
  syear  = sysdate("yyyy");
  if CDCode(syear,smonth,sday) < CDCode(2023,5,1) then    { !!! Fix to minimum date of interview }
    errmsg( 0003, sday, smonth, syear );
    endlevel;
  endif;

  { Set the applications minimum and maximum parameters }
  alphalst = "ABCDEFGHIJKLMNOPQRSTUVWXYZЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮҚҲҶЯӢЁҒ";

  { Set the application parameters }
  minab    = 120;                           { !!! minimum age at first birth in months - women }
  minam    = 96;                            { !!! minimum age at marriage in months - women }
  minabm   = 180;                           { !!! Minimum age at first birth in months at birth - men }
  minamm   = 144;                           { !!! minimum age at marriage in months - men }
  maxchild = 24;                            { !!! maximum number of children in birth history }
  max5     = 6;                             { !!! maximum number of births since '0? in section 4 & 5 }
  maxsib   = 20;                            { !!! maximum number of siblings in mat.mort. section }
  stermeth = 1;                             { Method number for female sterilization }
  stermetm = 2;                             { Method number for male   sterilization }
  yrspcare = 3;                             { !!! Number of years worth of pregnancies for pregnancy and postnatal section }
  yrsvacc  = 3;                             { !!! Number of years worth of births for immunization section }
  yrshlth  = 5;                             { !!! Number of years worth of births for child health }
  yrsfeed  = 2;                             { !!! Number of years used as cutoff for nutrition  }
  daughty  = 2005;                          { !!! Year used as cutoff for daughters to be included in the FGC roster }
  android  = (getos() = 20);                { !!! 1-to use application in android machine }

  calendy  = 2023;                          { !!!! year when calendar ends }
  calbegy  = 2018;                          { !!!! Year when calendar begins }
  calend   = cmcode(12,calendy);            { last date of calendar }
  calbeg   = cmcode( 1,calbegy);            { first date of calendar }
  callen   = calend-calbeg+1;               { length of calendar }

  pregstr  = "BPT";                         { Codes for Birth, Pregnancy and Termination }
  codeb    = pregstr[1:1];
  codep    = pregstr[2:1];
  codet    = pregstr[3:1];
  methstr  = "123456789JKLMXY";             { !!! Codes for contraceptive methods in calendar }
  q307str  = "ABCDEFGHIJKLMXY";             { !!! Codes for contraceptive methods in Q307    }
  am439str = "ABCDEFGHIJKLMXY";             { !!! Codes for contraceptive methods in ZZZQM418   }
  asource  = "123456789ABCDEFX";            { !!!! source of method, calendar column 3 }

  methoth  = 14;                            { !!! Occurrence number of "other" method }
  InEntry   = ( demode() = add | demode() = modify );   { it will essentially sets inEntry = 0 to properly run it in batch }

  orderstr(1) = tr("first twin");
  orderstr(2) = tr("second twin");
  orderstr(3) = tr("third twin");
  orderstr(4) = tr("fourth twin");
  orderstr(5) = tr("fifth twin");

//Added by Ikhtier
   months_array(1) =tr("Dec");
   months_array(2) =tr("Nov");
   months_array(3) =tr("Oct");
   months_array(4) =tr("Sep");
   months_array(5) =tr("Aug");
   months_array(6) =tr("Jul");
   months_array(7) =tr("Jun");
   months_array(8) =tr("May");
   months_array(9) =tr("Apr");
   months_array(10)=tr("Mar");
   months_array(11)=tr("Feb");
   months_array(12)=tr("Jan");
   
   BloodCat(1) =tr("Acceptable range");
   BloodCat(2) =tr("At the high end of acceptable range");
   BloodCat(3) =tr("Above acceptable range");
   BloodCat(4) =tr("Moderately high");
   BloodCat(5) =tr("High");
   BloodCat(6) =tr("Very high");
   
   BloodCon(1) = tr("24 months");
   BloodCon(2) = tr("12 months");
   BloodCon(3) = tr("2 months");
   BloodCon(4) = tr("1 month");
   BloodCon(5) = tr("7 days");
   BloodCon(6) = tr("Today");
   
  { converts parameter to numbers  }
  xintnum  = tonumber( sysparm()[1:4] );    { interviewer number }
  xsupnum  = tonumber( sysparm()[5:4] );    { supervisor number }
  xmodcent = tonumber( sysparm()[9:1] );    { modify by central office }
  xrvisit  = tonumber( sysparm()[10:1] );   { revisit }
  xmodify  = tonumber( sysparm()[11:1] );   { modify completed }
  xpartial = tonumber( sysparm()[12:1] );   { if case has been saved partially }
  xentryhw = tonumber( sysparm()[13:1] );   { enter height & weight data }
  xhhnum   = tonumber( sysparm()[14:4] );   { household number }
  xline    = tonumber( sysparm()[18:2] );   { individual line number }
  xteam    = tonumber( sysparm()[24:2] );   { team number }

  if !xmodify then
    YCLUSTER = tonumber( sysparm()[20:4] );
    if !loadcase( CLUSTERS, YCLUSTER ) then
      errmsg( 0001, YCLUSTER );
      endlevel
    endif;
  endif;

  { settings for CAPI }
  reviewsup = ( xmodcent & xmodify & xsupnum <> 0 );         { indicates supervisor is reviewing, therefore exit the application }
  if !xmodcent | reviewsup then                              { central office desn't have to exit after reviewing one HH }
    set behavior() exit on;
  endif;
  set attributes(TJIN80) assisted off (variable(title));
  
  { avoid radio buttons for months in blocks for android }
  if android then
    setproperty(Q106M,   "CaptureType", "ComboBox" );
    setproperty(Q110M,   "CaptureType", "ComboBox" );
    setproperty(Q220M,   "CaptureType", "ComboBox" );
    setproperty(Q313M,   "CaptureType", "ComboBox" );
    setproperty(Q314M,   "CaptureType", "ComboBox" );
    setproperty(Q317EM,  "CaptureType", "ComboBox" );
    setproperty(Q317GM,  "CaptureType", "ComboBox" );
    setproperty(M509B,   "CaptureType", "ComboBox" );
    setproperty(M509H,   "CaptureType", "ComboBox" );
    setproperty(M509P0,  "CaptureType", "ComboBox" );
    setproperty(M509P1,  "CaptureType", "ComboBox" );
    setproperty(M509P2,  "CaptureType", "ComboBox" );
    setproperty(M509P3,  "CaptureType", "ComboBox" );
    setproperty(M509IPV, "CaptureType", "ComboBox" );
    setproperty(M509D1,  "CaptureType", "ComboBox" );
    setproperty(M509D2,  "CaptureType", "ComboBox" );
    setproperty(M509D3,  "CaptureType", "ComboBox" );
    setproperty(M509D4,  "CaptureType", "ComboBox" );
    setproperty(M509N1,  "CaptureType", "ComboBox" );
    setproperty(M509N2,  "CaptureType", "ComboBox" );
    setproperty(M509N3,  "CaptureType", "ComboBox" );
    setproperty(M509R1,  "CaptureType", "ComboBox" );
    setproperty(M509R2,  "CaptureType", "ComboBox" );
{    setproperty(ZZZM509R3,  "CaptureType", "ComboBox" ); }
    setproperty(M509M1,  "CaptureType", "ComboBox" );
{    setproperty(ZZZM509M2,  "CaptureType", "ComboBox" );  }
    setproperty(M509V,   "CaptureType", "ComboBox" );
    setproperty(Q715M,   "CaptureType", "ComboBox" );
    setproperty(Q719M,   "CaptureType", "ComboBox" );
    setproperty(Q1023M,  "CaptureType", "ComboBox" );
    setproperty(Q1025M,  "CaptureType", "ComboBox" );
    setproperty(Q1029M,  "CaptureType", "ComboBox" );
 {   setproperty(ZZZQM106M,  "CaptureType", "ComboBox" );
    setproperty(ZZZQM110M,  "CaptureType", "ComboBox" );
    setproperty(ZZZQM411M,  "CaptureType", "ComboBox" );
    setproperty(ZZZQM714M,  "CaptureType", "ComboBox" );
    setproperty(ZZZQM718M,  "CaptureType", "ComboBox" ); }
  endif;

  { set font for value sets }
  setfont( ALL, "Arial", 16, bold );

  { set up minimal user bar }
  userbase();
  userbar( show );
  { set language at start of the program, defaulting to language passed by menu }
  setlanguage(loadsetting("Language", getlanguage()));

  responseloc( 1 );  // 1 = top left corner, under the questions, 2 = next to the field

postproc
  if !xmodcent then
    stop(1);
  endif;

PROC INDIVIDUAL
preproc
  if xmodify then
    advance to QCORRECT;
  endif;

postproc
  endlevel;

PROC QSECOVER_FORM
  if QRESULT <> 1 then
    { Check that questionnaire finished OK }
#if AppType(Entry)
    if endmess() then
      reenter QCORRECT
    endif;
    endlevel
#else
    skip case
#endif;
  endif;

PROC QCLUSTER
preproc
  { Set cluster and other geographical variables from CLUSTERS file }
  if demode() = add then
    $ = YCLUSTER;
    QREGION = YREGION;
	QTYPE   = YURBRUR;
  endif;

PROC QNUMBER
preproc
  if demode() = add then
    $ = xhhnum;
  endif;

postproc
  { loads household questionnaire }
  if !loadcase( TJHH80, QCLUSTER, QNUMBER ) then
    errmsg( 80006, QNUMBER, QCLUSTER );
    stop(1);
  endif;
  nhhold = hhm_array();
  userbar( add button, tr("Household"),   showroster(4) );

PROC QLINE
preproc
  if demode() = add then
    $ = xline;
  endif;
  
postproc
  id = edit("9999",QCLUSTER)+edit("9999",QNUMBER)+edit("99",QLINE);

PROC QVIOLEN
preproc
  { QHNUMDV is a variable in the household questionnaire }
  { indicating the woman who is selected for the DV module }
  if QHNUMDV = QLINE then
    $ = 1
  else
    $ = 2
  endif;

PROC QQTYPE
preproc
  $ = QH04(QLINE);
  
postproc  
  QQTYPET = GetValueLabel( $ );

PROC QNAME
preproc
  if !xmodify then
    $ = QH02( QLINE );
  endif;

PROC QCORRECT
  if $ <> 1 then
    stop(1);
  endif;

PROC QINTNUM
preproc
  if demode() = add then
    $ = xintnum;
  endif;

PROC QTEAM
preproc
  if demode() = add then
    $ = xteam;
  endif;

PROC QSUPERV
preproc
  if demode() = add then
    $ = xsupnum;
  endif;

PROC QVLINE
preproc
  n = curocc();
  { if in modify mode and result = NA skip }
  if xmodify & visualvalue(QVRESULT(n)) = notappl then
    skip to QINTD;
  { partial save with modification doesn't create a new visit }
  elseif xpartial = 2 & visualvalue($(n)) = notappl then
    skip to QINTD
  { assign new visit for add, partial save with add }
  elseif visualvalue( $(n) ) = notappl | n >= maxocc() then
    $ = n;
  { incomplete cases are called as if they were partially saved }
  { in addmode to generate an entry in visits table             }
  elseif xpartial = 1 & visualvalue( QVRESULT(n) ) <> 1 then
    advance to QVLINE(n+1);
  { change result code to postponed when partial visit to previous visit }
  elseif xpartial = 1 & visualvalue( $(n+1) ) = notappl then
    QVRESULT(n) = 3;
    advance to QVLINE(n+1);
  { revisit generates another entry in visit }
  elseif xrvisit then
    advance to QVLINE(n+1);
  endif;

PROC QVDAY
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    $ = sysdate( "dd" );
  endif;

PROC QVMONTH
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    $ = sysdate( "mm" );
  endif;

PROC QVYEAR
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    $ = sysdate( "YYYY" );
  endif;

PROC QVHOUR
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    time = systime();
    $ = int( time/10000 );
  endif;

PROC QVMINUTE
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    time = systime();
    $ = int( time/100 ) % 100;
  endif;

PROC QVRESULT
preproc
  n = curocc();
  oldval = visualvalue( $(n) );
  { a partial case in addmode is assigned a completed interview }
  if ( oldval = notappl | n >= maxocc() ) & xpartial = 1  then
    $ = 1;
  endif;

onfocus
  n = curocc();
  oldval = visualvalue( $(n) );

postproc
  { Verify that household questionnaire was incomplete }
  if $ <> 1 & oldval in 1,notappl then
    if visualvalue(Q101H) = notappl then
      warning( 0014 ) select( tr("Interview result"), $, tr("Continue"), continue );
    else
      warning( 0019 ) select( tr("Interview result"), $, tr("Continue"), continue );
    endif;
  endif;

  { Get Other Answer for result of household interview }
  if $ = 7 & oldval <> 7 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;
  n = curocc();
  if !xrvisit & n >= maxocc() then
    skip to QINTD;
  elseif !xrvisit & visualvalue( QVLINE(n+1) ) = notappl then
    skip to QINTD;
  elseif oldval = notappl then
    skip to QINTD;
  endif;

PROC QINTD
preproc
  if InEntry then
    n = totocc( QVISITS_ROSTER );
    $ = QVDAY( n );
  endif;	

PROC QINTM
preproc
  if InEntry then
    n = totocc( QVISITS_ROSTER );
    $ = QVMONTH( n );
  endif;	

PROC QINTY
preproc
  if InEntry then
    n = totocc( QVISITS_ROSTER );
    $ = QVYEAR( n );
  endif;	

PROC QRESULT
preproc
  if InEntry then
    $ = QVRESULT( n );
  endif;	

PROC QVISITS
preproc
  if InEntry then
    $ = totocc( QVISITS_ROSTER );
  endif;	

postproc
  { a partial save is forced for incomplete interviews to allow }
  { revisiting the woman in add mode                            }
  if !xmodcent & QRESULT <> 1 then
    savepartial( clear );
    stop(1);
  endif;

PROC QCONSENT_FORM
  if QRESULT <> 1 then
#if AppType(Entry)
    endlevel
#else
    skip case
#endif;
  endif;

PROC QCONSENT
preproc
  if QRESULT <> 1 & special(visualvalue($)) then
    endgroup
  elseif visualvalue($) = 1 then
    advance to Q101H
  endif;

postproc
  n = totocc( QVISITS_ROSTER );
  if $ <> 1 then
    x = accept( tr("Please confirm that the result of this interview is a refusal"), 
	            tr("Yes, Refused"), tr("No, Consent given") );
    if x <> 1 then
      reenter
    endif;
    QVRESULT( n ) = 4;
    QRESULT       = 4;
    endgroup;
  elseif $ = 1 & QVRESULT(n) <> 1 then
    QVRESULT(n) = 1
  endif;

  { Initialize top row of calendar to use }
  di = cmcode( QINTM, QINTY );
  calint = cmcrow( di );            { first row to use of calendar }
  { calculate interview CDC }
  dicdc = CDCode( QINTY, QINTM, QINTD );
  { *** skip to men's background characteristics if men's interview }
  if QQTYPE = 1 then
   { skip to ZZZQM101H }
  endif;

PROC Q101H
preproc
  if InEntry then
    n = totocc( QVISITS_ROSTER );
    $ = QVHOUR( n );
  endif;
PROC Q101M
preproc
  if InEntry then
    n = totocc( QVISITS_ROSTER );
    $ = QVMINUTE( n );
  endif;
  
PROC Q102
preproc
if Q101H in 0:5,23 then
	warning( 0184 ) 
	select( tr("Check tablet clock" ), $, tr("Continue"), continue );;
  endif;

postproc
  if $ <> 96 then
    skip to Q104
  endif;

PROC Q103
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
PROC Q104
  if $ = 96 & QH05(QLINE) = 1 then
    warning( 1031, QH05(QLINE) ) 
	  select( tr("Time living in place of interview"), $, tr("Continue"), continue );
  endif;
  if $ in 95,96 then
    skip to Q110M
  elseif !$ in 0:4 then
    skip to Q107
  endif;
  
PROC Q106Y
  di = cmcode(QINTM, QINTY);
  if afterint(Q106M,$,QINTM,QINTY) then
	errmsg( 89998 ) select( tr("Date moved here"), Q106_BLOCK );
  endif;
  if validyr(Q106Y) then
    temp = setub(Q106M, Q106Y, 9999);
	if int((di-temp)/12) <> Q104 then
	  warning( 1035, Q104 ) 
	    select( tr("Date moved here"), Q106_BLOCK, 
	            tr("Years living in place of residence"), Q104,
				tr("Continue"), continue );
	endif;
  endif;

PROC Q109
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q111
  { Set up CMC for date of interview }
  di = cmcode(QINTM, QINTY);
  { Initial ranges for CMC date of birth }
  if validyr(Q110Y) then
    ldb = setlb(Q110M, Q110Y, 0);
    udb = setub(Q110M, Q110Y, 9999);
  else
    ldb = di - 599;
    udb = di - 180;
  endif;

  { Check either year of birth or age given for all women }
  if !validyr(Q110Y) & !valid($) then
    errmsg( 1060, Q110M, Q110Y, $ ) 
	  select( tr("Date of birth"), Q110_BLOCK, 
	          tr("Age"), $ );
  { Compare age of woman with age in household to look for typos }
  elseif $ <> QH07(QLINE) & demode() = add then
    warning( 1061, $, QH07(QLINE) ) 
	  select( tr("Age"), $, 
	          tr("Continue"), continue );
  endif;

  { Adjust ranges for CMC date of birth based on age }
  if valid($) then
    { Lower bound of CMC }
    t = ndjlba(ldb, udb, di, di, $);
    if t < 0 then
      errmsg( 1062, Q110M, Q110Y, $, QINTM, QINTY ) 
	    select( tr("Date of birth"), Q110_BLOCK, 
		        tr("Age"), $ ); 
    else
      ldb = t
    endif;
    { Upper bound of CMC }
    t = adjuba(ldb, udb, di, di, $);
    if t < 0 then
      errmsg( 1062, Q110M, Q110Y, $, QINTM, QINTY ) 
	    select( tr("Date of birth"), Q110_BLOCK, 
		        tr("Age"), $ );
    else
      udb = t
    endif;
  endif;

  { calculate woman's age }
  agew = int( (di - ldb) / 12 );

  { checks duration of current residence against age }
  if Q104 in 0:49 & Q104 > agew then
    errmsg( 1030, Q104 )
	  select( tr("Years living in place of residence"), Q104, 
	          tr("Age"), $ );
  endif;

PROC Q113
  if $ <> 1 then
    skip to Q117
  endif;

PROC Q114
  { Check education in individual questionnaire agrees with education in hh }
  if $ <> QH17A(QLINE) & demode() = add then
    warning( 1080, $, QH17A(QLINE) ) 
	  select( tr("Level of education" ), $, tr("Continue"), continue );
  endif;

PROC Q115
onfocus
  grades.clear();
  grades.add(tr("Less than one year"), 0);
  n = maxgrade(Q114);
  do i = 1 while i <= n
    grades.add(maketext("Year %d", i), i);
    // change the above to match the terms used in the country
    // e.g. it might be "Year" that is used in most levels, but "Form" is used in secondary schooling
    // if Q114 = 2 then
    //   grades.add(maketext("Form %d", i), i);
    // else
    //   grades.add(maketext("Year %d", i), i);
    // endif;
  enddo;
  SetValueSet( $, grades );
  
postproc
  { Verify the maximum grade for the level }
  if !levelYears( Q114, $ ) then
    errmsg( 1091 ) 
	  select( tr("Level of education"), Q114, tr("Grade/year/form"), $ );
  endif;

  { Check education in individual questionnaire agrees with education in hh }
  if $ <> QH17B(QLINE) & demode() = add then
    warning( 1090, $, QH17B(QLINE) ) 
	  select( tr("Grade/year/form"), $, tr("Continue"), continue );
  endif;


PROC Q115C
preproc
  if Q114 in 4,5 then
    skip to Q117
  endif;		  
PROC Q115E
preproc
  if !Q114 in 2,3 then
    skip to Q117
  endif;		  
PROC Q117
preproc
  if Q114 > 1 then   {modified for TJ23}
    skip to Q119
  endif;

postproc
  if $ in 1,5 then
     skip to Q120
  { Get Other Answer }
  elseif $ = 4 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q122
  if $ <> 1 then
    skip to Q127
  endif;

PROC Q127  {Skip modified for TJ23}
  if $ <> 1 then
    skip to Q131
  endif;

PROC Q128 {Skip modified for TJ23}
  if $ <> 1 then
    skip to Q131
  endif;

PROC Q131
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
PROC Q201
  SaveData();
  if $ = 2 then
    skip to Q206
  endif;

PROC Q202
  if $ = 2 then
    skip to Q204
  endif;

PROC Q203B
  { Check for at least one child living at home - otherwise 202 must be 2 }
  if !Q203A & !$ then
    errmsg( 2030 ) select( tr("Any children living at home"), Q202, 
	                       tr("Number of children living at home"), Q203_BLOCK );
  endif;

PROC Q204
  if $ = 2 then
    skip to Q206
  endif;

PROC Q205B
  { Check for at least one child living away from home - otherwise 204 must be 2 }
  if !Q205A & !$ then
    errmsg( 2030 ) select( tr("Any children living away"), Q204, 
	                       tr("Number of children living away"), Q205_BLOCK );
  endif;

PROC Q206
  if $ = 2 then
    skip to Q208
  endif;

PROC Q207B
  { Check for at least one child to have died - otherwise 206 must be 2 }
  if !Q207A & !$ then
    errmsg( 2030 ) select( tr("Any boys or girls who died"), Q206, 
	                       tr("Number of boys or girls who died"), Q207_BLOCK );
  endif;

PROC Q208
preproc
  { Count up total children ever born }
  $  = NAtoZero(Q203A)+NAtoZero(Q203B)+
       NAtoZero(Q205A)+NAtoZero(Q205B)+
       NAtoZero(Q207A)+NAtoZero(Q207B);

postproc
  if $ = 0 & Q201 = 1 then
    errmsg( 02080 ) select( tr("Any children ever born"), Q201 );
  endif;

PROC Q209
  if $ <> 1 then
    errmsg( 02090 ) select( tr("Check children ever born"), Q201, 
	                        tr("Reconfirm number of children"), $ );
  endif;

PROC Q210
  if $ <> 1 then
    skip to Q212
  endif;

PROC Q212
preproc
  numeric oldQ212 = visualvalue(Q212);
  { Count up total pregnancies }
  $  = NAtoZero(Q208)+NAtoZero(Q211);

postproc
  { Working version of total pregnancies - used instead of Q212 from here on }
  if special(visualvalue(Q212W)) | visualvalue(Q212W) < Q212 then 
    Q212W = Q212
  elseif Q212 <> oldQ212 then // new value for Q212 - do we update Q212W?
    // get a count of pregnancies currently entered
    numeric totpregs = 0;
    do i = 1 while i <= maxchild
      if !special( visualvalue( Q215(i) ) ) | !special( visualvalue( Q216(i) ) ) then // check Q215 and Q216 to see if they are not blank
           inc(totpregs);
      endif;
    enddo;
    if visualvalue(Q212W) > Q212 & totpregs > Q212 then // check if there are currently more pregnancies entered than recorded in Q212
      errmsg(2100, totpregs, Q212) 
	  select( tr("Correct the number of pregnancies in Q201-Q212"), Q201, 
	          tr("Continue to pregnancy history to remove the incorrect pregnancy"), continue )
    else // can safely reduce Q212W if there are not already more pregnancies than reported in Q212
      Q212W = Q212
    endif;
  endif;

PROC Q212W
  if Q212 = 0 then
    skip to QCAL1
  endif;

PROC QWSEC2B_FORM
preproc
  { Initialize line numbers of each pregnancy }
  do i = 1 while i <= maxchild
    calrow(i) = 0;              { row of calendar containing pregnancy }
  enddo;

onfocus
  if !preghid then
    preghid = userbar( add button, tr("Pregnancy history"), showroster( 1 ) );
  endif;
  if !pregsid then
    pregsid = userbar( add button, tr("Pregnancies"), preg_tools() ); // add userbar for pregnancies once we get to pregnacy history
  endif;

killfocus
  if pregsid then
    userbar(remove,pregsid);
	pregsid = 0;
  endif;

postproc
  n = noccurs(QWSEC2B);

  { Check counts of children living at home }
  ch = count( QWSEC2B where Q219 = 1 & Q224 = 1 & Q226 = 1 );
  if lessthan( ch, Q203A ) then
    errmsg( 02240, tr("Boys at home"), "Q203A", Q203A, ch )
      select( tr("Begin reproduction"), Q201, 
	          tr("Begin pregnancy history"), Q215(1) );
  endif;
  ch = count( QWSEC2B where Q219 = 2 & Q224 = 1 & Q226 = 1 );
  if lessthan( ch, Q203B ) then
    errmsg( 02240, tr("Girls at home"), "Q203B", Q203B, ch )
      select( tr("Begin reproduction"), Q201, 
	          tr("Begin pregnancy history"), Q215(1) );
  endif;

  { Check counts of children living away }
  ch = count( QWSEC2B where Q219 = 1 & Q224 = 1 & Q226 = 2 );
  if lessthan( ch, Q205A ) then
    errmsg( 02240, tr("Boys living away"), "Q205A", Q205A, ch )
      select( tr("Begin reproduction"), Q201, 
	          tr("Begin pregnancy history"), Q215(1) );
  endif;
  ch = count( QWSEC2B where Q219 = 2 & Q224 = 1 & Q226 = 2 );
  if lessthan( ch, Q205B ) then
    errmsg( 02240, tr("Girls living away"), "Q205B", Q205B, ch )
      select( tr("Begin reproduction"), Q201, 
	          tr("Begin pregnancy history"), Q215(1) );
  endif;

  { Check counts of children who have died }
  ch = count( QWSEC2B where Q216 = 1 & Q219 = 1 & Q224 = 2 );
  if lessthan( ch, Q207A ) then
    errmsg( 02240, tr("Boys who died"), "Q207A", Q207A, ch )
      select( tr("Begin reproduction"), Q201, 
	          tr("Begin pregnancy history"), Q215(1) );
  endif;
  ch = count( QWSEC2B where Q216 = 1 & Q219 = 2 & Q224 = 2 );
  if lessthan( ch, Q207B ) then
    errmsg( 02240, tr("Girls who died"), "Q207B", Q207B, ch )
      select( tr("Begin reproduction"), Q201, 
	          tr("Begin pregnancy history"), Q215(1) );
  endif;

  if Q212W then
    { Checking of minimum interval between pregnancies }
    x = Q212W - twincode(Q212W) - (twincode(Q212W) = 0);
    do i = 1 while i <= x
      j = i + 1;
      while twincode(j) > 1 do
        j = j + 1
      enddo;
      t = adjlbi( ldc(i), udc(i), ldc(j), udc(j), 7 );
      if t < 0 then
        warning( 2241, i, Q220M(i), Q220Y(i), j, Q220M(j), Q220Y(j) ) 
		  select( maketext( tr("Date of pregnancy") + " %d", i), Q220_BLOCK(i),
		          maketext( tr("Date of pregnancy") + " %d", j), Q220_BLOCK(j),
				  tr("Continue"), continue );
      else
        ldc(j) = t;
      endif;
      t = adjubi( ldc(i), udc(i), ldc(j), udc(j), 7 );
      if t < 0 then
        warning( 2241, i, Q220M(i), Q220Y(i), j, Q220M(j), Q220Y(j) ) 
		  select( maketext( tr("Date of pregnancy") + " %d", i), Q220_BLOCK(i),
		          maketext( tr("Date of pregnancy") + " %d", j), Q220_BLOCK(j),
				  tr("Continue"), continue );
      else
        udc(i) = t;
      endif;
    enddo;
  endif;

  { check that children declared as of respondent in HH are also declared in pregnancy history }
  do i = 1 while i <= QHMEMBER
    if QH13(i) = QLINE & count( QWSEC2B where Q227 = i ) <> 1 then
      if demode() = add then
        warning( 2185, i ) select( tr("Begin pregnancy history"), Q215L(1),
		                           tr("Continue"), continue );
      endif;
    endif;
  enddo;

PROC Q214
  $ = "";

PROC QWSEC2B_ROSTER1
preproc
  { Initialize line number of each pregnancy }
  do i = 1 while i <= maxchild
    QLAST5(i) = 0;  { initialize child as if not born in the last 5 years }
  enddo;
  renum_pregs();

postproc
  { Check counts of boys }
  numeric boys = NAToZero(Q203A) + NAToZero(Q205A) + NAToZero(Q207A);
  ch = count( $ where Q216 = 1 & Q219 = 1 );
  if lessthan( ch, boys ) then
    errmsg( 02240, tr("Boys"), "Q203A+Q205A+Q207A", boys, ch )
      select( tr("Begin reproduction"), Q201, 
	          tr("Begin pregnancy history"), Q215L(1) );
  endif;
  { Check counts of girls }
  numeric girls = NAToZero(Q203B) + NAToZero(Q205B) + NAToZero(Q207B);
  ch = count( $ where Q216 = 1 & Q219 = 2 );
  if lessthan( ch, girls ) then
    errmsg( 02240, tr("Girls"), "Q203B+Q205B+Q207B", girls, ch )
      select( tr("Begin reproduction"), Q201, 
	          tr("Begin pregnancy history"), Q215L(1) );
  endif;
  { checks that the number of pregnancy losses consistent with reproduction }
  numeric losses = count( $ where Q216 in 2,3,4 );
  if lessthan( losses, Q211) then
    errmsg( 02240, tr("Pregnancy losses"), "Q211", Q211, losses )
      select( tr("Pregnancy losses"), Q211, 
	          tr("Begin pregnancy history"), Q215L(1));
  endif;
  
  { check order of pregnancies }
  do p = 2 while p < Q212W
    do i = p-1 while i & (Q220Y(i) = missing | Q220Y(i) > QINTY) by (-1) enddo;
    { Check pregnancies are given in order }
    if i & validyr(Q220Y(i)) &
      ( Q220Y(p) < Q220Y(i) |
       (Q220Y(p) = Q220Y(i) & (valid(Q220M(i)) & (Q220M(p) < Q220M(i) |
	                                             (Q220M(p) = Q220M(i) & (valid(Q220D(i)) & Q220D(p) < Q220D(i)))
      )))) then
      errmsg( tr("Date of end of pregnancy for %s in %s %d is before date of end of pregnancy for %s in %s %d. Reorder these pregnancies?"), 
	          strip(Q218(i)),getlabel(Q220M,visualvalue(Q220M(i))),visualvalue(Q220Y(i)),
			  strip(Q218(p)),getlabel(Q220M,visualvalue(Q220M(p))),visualvalue(Q220Y(p)))
			  select( maketext(tr("Correct date of pregnancy for %s"), Q218(i)), Q220D(i), 
			          maketext(tr("Correct date of pregnancy for %s"), Q218(p)), Q220D(p));
    endif;
  enddo;
  if android then
    show( tr("Pregnancy history"), $, Q215L, Q218, Q216, Q219
      title( tr("Line"), tr("Name"), tr("Outcome"), tr("Sex") ) where Q215L <> notappl );
  endif;

PROC Q215L
preproc
  SaveData();
  renum_pregs();

  { Check for list of pregnancies }
  if curocc() > Q212W then
    endgroup
  endif;

PROC Q215
preproc
  { If a twin of prior outcome, automatically set to the same code }
  if Q215L > 1 & $(Q215L-1) > high(twincode(Q215L-1),1) then
    if special(visualvalue($)) then
      $ = Q215(Q215L-1);
      noinput;
    endif;
  endif;

postproc
  { Check twin codes }
  { Last pregnancy can not be 1st of multiple pregnancy }
  if $ > 1 & Q212W = 1 then
    errmsg( 02122, Q212W ) select( tr("Single or multiple pregnancy"), $,
                                   tr("Reconfirm number of children"), Q209 );
  elseif $ > 1 & Q215L > 1 & $(Q215L-1) = 1 then
    if Q215L = Q212W then
      errmsg( 02120 ) select( tr("Single or multiple pregnancy"), $ );
    endif
  { Previous pregnancy is first of multiple, but current is single pregnancy }
  elseif $ = 1 & Q215L > 1 & $(Q215L-1) = 2 then
    if Q215L = 2 | Q215L > 2 & $(Q215L-2) <> 2 then
      errmsg( 02120 ) select( tr("Single or multiple pregnancy"), $ );
    endif;
  endif;

  { Set up twin code variable coded as follows:
    0 - Single birth
    1 - 1st of multiple
    2 - 2nd of multiple
    3 - 3rd of multiple
    etc.
    This variable easier to use in controlling twins.
  }
  if $ = 1 then
    twincode(Q215L) = 0
  { first pregnancy or the prior pregnancy last the last of a set of twins or triplets, in which case this is the first of the next set of twins/triplets }	
  elseif Q215L = 1 | Q215(Q215L-1) = twincode(Q215L-1) then
    twincode(Q215L) = 1
  else
    twincode(Q215L) = twincode(Q215L-1) + 1
  endif;
  
  if $ > 1 & Q215L+$-twincode(Q215L) > Q212W then
    errmsg( 2123, tolower(getlabel($, $)), Q212W ) select( tr( "Number of pregnancies" ), Q201, tr( "Single or multiple pregnancy" ), Q215 );
    reenter
  endif;

PROC Q216
onfocus
  twinnum = twincode(Q215L);

postproc
  { check correct outcome combinations for twins }
  if Q215 = 2 & Q215L > 1 & Q215L(Q215L-1) = 2 then
    if $ <> $(Q215L-1) then           // ??? if different, add code to check valid twins combinations  
	  warning( 2121 ) select( tr("Pregnancy outcome"), $, 
	                          tr("Prior pregnancy outcome"), $(Q215L-1), 
							  tr("Continue"), continue );
	endif;
  endif;
  if $ <> 2 then
    skip to Q218
  endif;	

PROC Q218
onfocus
  protect($, false);
  if !livebirth() then
    recode Q216 -> $;
             2  -> tr("STILLBIRTH");
             3  -> tr("MISCARRIAGE");
             4  -> tr("ABORTION");
    endrecode;
    protect( $, true );
  endif;

postproc
  if !pos( $[1:1], alphalst ) then
    errmsg( 89991 ) select( tr("Name"), $ );
  endif;

  if android then 
    setocclabel(QWSEC2B_ROSTER1(curocc()),maketext("%d %s",Q215L,strip($)));
  endif;

PROC Q219
preproc
  if !livebirth() then
    skip to Q220_BLOCK;
  endif;

PROC Q220_BLOCK
onfocus
  pregtype = livebirth();

postproc
  if android then 
    setocclabel(QWSEC2B_ROSTER1(curocc()),maketext("%d %s %d/%d/%d",Q215L,strip(Q218),Q220D,Q220M,Q220Y));
  endif;

PROC Q220Y
  if !DateOK( Q220D, Q220M, $, QINTD, QINTM, QINTY ) then
    errmsg( 2145 ) select( tr("Date of end of pregnancy"), Q220D );
  endif;

  prev = Q215L - 1;
  { Update twin code variable in case of two pairs of twins together }
  { Twincode is 0-Single birth, 1-1st of multiple, 2-2nd of multiple, ... }
  if Q215 = 2 & prev & twincode(prev) >= 2 then
    if ($ <> $(prev) | Q220M <> Q220M(prev)) then
      twincode(Q215L) = 1
    endif
  endif;

  { Check twin codes }
  { Last pregnancy can not be 1st of multiple pregnancy }
  if twincode(Q215L) = 1 then
    if Q215L = Q212W then
      errmsg( 2120 ) select( tr("Single or multiple pregnancy"), Q215 );
    endif
  { Current twin code must be 1 higher than previous }
  elseif twincode(Q215L) >= 2 then
    if Q215L = 1 | twincode(prev) <> twincode(Q215L) - 1 then
      errmsg( 2120 ) select( tr("Single or multiple pregnancy"), Q215 );
    endif
  { Previous pregnancy is first of multiple, but current is single pregnancy }
  elseif Q215L > 1 & twincode(prev) = 1 then
    errmsg( 2120 ) select( tr("Single or multiple pregnancy"), Q215 );
  endif;

  { Find prior pregnancy with year of pregnancy to check order }
  do i = Q215L-1 while i & ($(i) = missing | $(i) > QINTY) by (-1)
  enddo;
  { Check pregnancies are given in order }
  if i & validyr($) &
    ( $ < $(i) |
     ($ = $(i) & valid(Q220M(i)) & Q220M < Q220M(i)) |
     ($ = $(i) & valid(Q220M(i)) & Q220M = Q220M(i) & valid(Q220D(i)) & Q220D < Q220D(i))
    ) then
    if errmsg( 2152 ) select( tr( "Date of delivery" ), Q220_BLOCK,
                              tr( "Date of prior delivery" ), Q220_BLOCK(i),
                              tr( "Move pregnancy" ), continue ) = 3 then
      numeric newocc = select_preg( curocc() );
      move_preg( curocc(), newocc );
    endif;
    reenter;
  endif;

  { Check that twin code is correct when dates are identical }
  if Q215L > 1 & validyr($) & valid(Q220M) &
    ($ = $(prev) & Q220M = Q220M(prev)) & (Q215 = 1 | Q215(prev) = 1) then
    errmsg( 2153 ) select( tr("Date of pregnancy"), Q220_BLOCK, 
	                       tr("Date of prior pregnancy"), Q220_BLOCK(prev), 
						   tr("Single or multiple pregnancy"), Q215 );
  endif;

  { Initialize logical ranges for date of pregnancy in CMC }
  if validyr($) then
    ldc(Q215L) = setlb( Q220M, $, 0 );
    udc(Q215L) = setub( Q220M, $, 9999 );
  else
    ldc(Q215L) = ldb + minab;
    udc(Q215L) = di;
  endif;
  { calculate CDC for pregnancy date if at least year and month are valid } 
  Q220CD(Q215L) = 0;
  if validyr($) & valid(Q220M) then
    temp = Q220D;
    if !valid(Q220D) then // using the last day of the month to be on the conservative side
	  recode Q220M -> temp;
   1,3,5,7,8,10,12 -> 31;
	  	  4,6,9,11 -> 30;
		         2 -> 28+($%4=0);
	  endrecode;
	endif;
	Q220CD(Q215L) = CDCode( $, Q220M, temp );
  endif;

  if twincode(Q215L) > 1 then // check dates are within one day for twins    
    if Q220CD(Q215L) = 0 <=> Q220CD(prev) <> 0 then  // day known for one, but not the other
      errmsg( 2155, strip(Q218), Q220D, Q220M, Q220Y, strip(Q218(prev)), Q220D(prev), Q220M(prev), Q220Y(prev) )
      select( tr("Date of")+" "+tr(orderstr(twincode(prev ))), Q220_BLOCK(prev), // prior twin - %s will be "first twin", "second twin", etc.
	          tr("Date of")+" "+tr(orderstr(twincode(Q215L))), Q220_BLOCK);      // later twin - %s will be "second twin", "third twin", etc.
    elseif Q220D = 0 & (Q220M <> Q220M(prev) | $ <> $(prev)) then // day not given - month and year must be the same
      errmsg( 2151 )
      select( tr("Date of")+" "+tr(orderstr(twincode(prev ))), Q220_BLOCK(prev), // prior twin - %s will be "first twin", "second twin", etc.
	          tr("Date of")+" "+tr(orderstr(twincode(Q215L))), Q220_BLOCK);      // later twin - %s will be "second twin", "third twin", etc.
    elseif abs(Q220CD(Q215L) - Q220CD(prev)) > 1 then
      errmsg( 2156, strip(Q218), Q220D, Q220M, Q220Y, strip(Q218(prev)), Q220D(prev), Q220M(prev), Q220Y(prev) )
      select( tr("Date of")+" "+tr(orderstr(twincode(prev ))), Q220_BLOCK(prev), // prior twin - %s will be "first twin", "second twin", etc.
	          tr("Date of")+" "+tr(orderstr(twincode(Q215L))), Q220_BLOCK);      // later twin - %s will be "second twin", "third twin", etc.
    endif
  endif;

PROC Q221_BLOCK
preproc
  if twincode(Q215L) > 1 then // second or later of multiple pregnancy, so copy the duration
    if special(visualvalue(Q221N)) then
      Q221N = Q221N(Q215L-1);
      Q221U = Q221U(Q215L-1);
      advance to Q222;
    endif;
  endif;

PROC Q221U
preproc
  { check if pregnancy ended since start of calendar }
  QLAST5(Q215L) = 0;
  if ldc(Q215L) >= calbeg then
    QLAST5(Q215L) = 1
  elseif Q215L > 1 & QLAST5(Q215L-1) = 1 then
    QLAST5(Q215L) = 1
  endif;

postproc
  pregtype = livebirth();
  if !pregtype then pregtype = Q216 endif;
  recode $ :: Q221N -> err;
         1 :: 3:45  -> 0;     { weeks }
	     2 :: 1:10  -> 0;     { months }
	       ::       -> 1;
  endrecode;
  if err then
    errmsg( 2142 ) select( tr("Duration of pregnancy"), Q221_BLOCK ) ;
  endif;

  recode pregtype :: Q221N  :: Q221U -> err;
            1     ::   0:4  ::   2   -> 1;  { born alive }
            1     ::   0:21 ::   1   -> 1;  { born alive }
            1     ::   5:6  ::   2   -> 2;  { born alive - very early }
            1     ::  22:27 ::   1   -> 2;  { born alive - very early }
            2     ::   0:3  ::   2   -> 2;  { born dead }
            2     ::   0:16 ::   1   -> 2;  { born dead }
            3     ::   8:10 ::   2   -> 2;  { miscarriage }
            3     ::  28:50 ::   1   -> 2;  { miscarriage }
            4     ::   8:10 ::   2   -> 1;  { abortion }
            4     ::  28:50 ::   1   -> 1;  { abortion }
                  ::        ::       -> 0;
  endrecode;
  // code 2 is only a warning
  if err = 2 then
    warning( 2143, Q221N, getlabel(Q221U, Q221U), getlabel(Q216,Q216) ) select( tr("Duration of pregnancy"), Q221_BLOCK,
                   tr("Pregnancy outcome"), Q216, tr("Continue"), continue );
  elseif err then
    errmsg( 2143, Q221N, getlabel(Q221U, Q221U), getlabel(Q216,Q216) ) select( tr("Duration of pregnancy"), Q221_BLOCK,
                  tr("Pregnancy outcome"), Q216 );
  endif;

  { Check the units and number for the duration are the same for twins }
  if twincode(Q215L) > 1 & (Q221U <> Q221U(Q215L-1) | Q221N <> Q221N(Q215L-1)) then
    errmsg( 2144, Q221N, getlabel($,$), Q221N(Q215L-1), getlabel($,$(Q215L-1)) )
	select( tr("Duration of pregnancy of")+" "+tr(orderstr(twincode(Q215L  )) ), Q221_BLOCK,             // later twin - will be "second twin", "third twin" etc.
	        tr("Duration of pregnancy of")+" "+tr(orderstr(twincode(Q215L-1)) ), Q221_BLOCK(Q215L-1) );  // prior twin - will be "first twin", "second twin" etc.
  endif;
  
  numeric durmnth = Q221N; 
  if $ = 1 then durmnth = int(Q221N * WeeksMonth) endif;
  Q221DUR(Q215L) = durmnth;
  if QLAST5(Q215L) = 1 then
    FillC1Cal( 1 );
  endif;

PROC Q222
preproc
  n = curocc();
  if n > 1 & twincode(n) > 1 then
    skip to next Q215L
  endif;	
  
onfocus
  // special goback code used with Q222
  if goback222 then
	goback222 = 0;
    advance to Q215L(curocc()+1);
  endif;

postproc
  // Hold on to values of Q222. Will be set to 1 by insert_preg function if needed.
  if Q222W = notappl then
    Q222W = 2;
  endif;
  // Insertion of pregnancy before current pregnancy
  if $ = 1 & !xmodify then
    insert_preg(curocc())
  endif;

PROC Q222A
  // Hold on to values of Q222A. Will be set to 1 by insert_preg function if needed.
  if Q222AW = notappl then
    Q222AW = 2;
  endif;
  // Addition of pregnancy after last pregnancy
  if $ = 1 & !xmodify then
    insert_preg(curocc(QWSEC2B_ROSTER1)+1)
  endif;

PROC Q222B
onfocus
  if android then
	showroster( 1 );
  endif;

postproc
  if $ <> 1 then
    reenter Q215(1);
  endif;

PROC QWSEC2B_ROSTER2
preproc
  SaveData();


PROC QPLINE
preproc
  { Check for list of children }
  if curocc() > Q212W then
    endgroup
  endif;


postproc
  if android then 
    setocclabel(QWSEC2B_ROSTER2(curocc()),getocclabel(QWSEC2B_ROSTER1(curocc())));
  endif;
	   
PROC Q223
preproc
  // TC Need additional checking here for miscarriages and abortions as per questionnaire.
  idx = QPLINE;
  recode Q221U(idx) :: Q221N(idx) -> durpreg;
             1      ::   28:90    -> 1;
             2      ::    7:10    -> 1;
			        ::   95:99    -> 9; // special values are left unchanged below - in case they are allowed
                    ::            -> 0;
  endrecode;				  
  recode Q216(idx) :: Q217(idx) :: durpreg -> $;
            1      ::           ::         -> 1;  // born alive
            2      ::      1    ::         -> 1;  // born alive
            2      ::           ::   1     -> 2;  // stillbirth
            2      ::           ::   0     -> 3;  // miscarriage
            3      ::           ::   1     -> 2;  // stillbirth
            3      ::           ::   0     -> 3;  // miscarriage
                   ::           ::         -> Q216(idx);
  endrecode;

postproc
  if $ <> Q216(idx) & demode() = add then
    if $ = 1 then
      display( 2231, Q220D(idx), Q220M(idx), Q220Y(idx) );
	else
      display( 2232, replace(getlabel(Q216,Q216(idx)),tr("Born dead"),tr("Stillbirth")), Q220D(idx), Q220M(idx), Q220Y(idx), 
	                 replace(getlabel(Q223,Q223(idx)),tr("Born dead"),tr("Stillbirth")), Q221N(idx), getlabel(Q221U,Q221U(idx)) );
	endif;
  endif;

PROC Q224
preproc
  if Q223 in 2,3 then
    skip to next QPLINE
  elseif Q223 in 4 then
	skip to Q228B
  endif;	

onfocus
  childname = Q218(QPLINE);
  
postproc
  if $ = 1 & Q216(QPLINE) = 2 then
    errmsg( 2160 ) select( tr("Child alive"), $, 
	                       tr("Pregnancy outcome"), Q216(QPLINE) );
  elseif $ = 2 then
    skip to Q228_BLOCK
  endif;

PROC Q225
onfocus
  childname = Q218(QPLINE);

postproc
  { Check that twins have same age if both are alive }
  if twincode(QPLINE) >= 2 then
    j = default;
    do i = QPLINE - twincode(QPLINE) + 1 while i < QPLINE
      if Q224(i) = 1 then
        j = $(i);
      endif;
    enddo;
    if j <> default & j <> $ then
      errmsg( 2170 ) select( tr("Age of child"), $, tr("Age of twin"), $(i) );
    endif;
  endif;
  if age_day_check(Q220D(QPLINE), Q220M(QPLINE), Q220Y(QPLINE),  QINTD, QINTM, QINTY, Q225) >  0 then
    warning( 2175, Q225, Q220D(QPLINE), Q220M(QPLINE), Q220Y(QPLINE) )
      select( tr("Date of birth"), Q220_BLOCK(QPLINE), 
	          tr("Age"), Q225, 
			  tr("Continue"), continue);
  endif;

  { Adjust ranges for date of birth of child }
  if valid($) then
    { Lower bound of CMC date of birth }
    t = ndjlba( ldc(QPLINE), udc(QPLINE), di, di, $ );
    if t < 0 then
      errmsg( 2171, Q225, Q220D(QPLINE), Q220M(QPLINE), Q220Y(QPLINE) ) 
	    select( tr("Date of birth"), Q220_BLOCK(QPLINE), 
		        tr("Age"), $ );
    else
      ldc(QPLINE) = t
    endif;
    { Upper bound of CMC date of birth }
    t = adjuba( ldc(QPLINE), udc(QPLINE), di, di, $ );
    if t < 0 then
      errmsg( 2171, Q225, Q220D(QPLINE), Q220M(QPLINE), Q220Y(QPLINE) ) 
	    select( tr("Date of birth"), Q220_BLOCK(QPLINE), 
		        tr("Age"), $ );
    else
      udc(QPLINE) = t
    endif;
  endif;

PROC Q226
onfocus
  childname = Q218(QPLINE);

PROC Q227
onfocus
  childname = Q218(QPLINE);
  individuals.clear();
  do i = 1 while i <= QHMEMBER
    if QH04(i) = Q219(QPLINE) & i <> QLINE then   // condition for same sex maybe commented out or develop a more smart checking
      individuals.add(QH02(i), i);
    endif;
  enddo;
  individuals.add(tr("Child not listed in household"), 0);
  SetValueSet( $, individuals );

postproc
  { Check child's line number is not greater than max }
  if $ > QHMEMBER then
    errmsg( 2181 ) select( tr("Line number in the household"), $ );
  { If child is listed in HH }
  elseif $ > 0 then
    { check for duplicates }
    do i = 1 while i < curocc()
      if Q227(i) = $ then
        errmsg( 2184, i ) 
		  select( tr("Line number for this child"), $, 
		          maketext( tr("Line number for child") + "%d", i ), $(i) );
      endif;
    enddo;
    { Check mother's line number agrees with line number of mother in household questionnaire }
    if QH12($) <> notappl & QH13($) <> QLINE then
      if demode() = add then
        warning( 2182, QH13($), QLINE ) 
		  select( tr("Line number in the household"), $, tr("Continue"), continue );
      endif
    endif;
    { Check sex of child against sex in household questionnaire }
    if Q219(QPLINE) <> QH04($) then
      if demode() = add then
        warning( 2141, QH04($), Q219(QPLINE) ) 
		  select( tr("Line number in the household"), $, 
		          tr("Sex of child"), Q219(QPLINE), 
                  tr("Continue"), continue );
      endif;
    endif;
    { Check age of child against age in household questionnaire }
    if !special(Q225) & !special(QH07($)) then
      if !( (Q225-QH07($)) in (-2):2 ) then
        if demode() = add then
          warning( 2173, QH07($), Q225 ) 
		  	select( tr("Line number in the household"), $, 
		            tr("Age of child"), Q225, 
                    tr("Continue"), continue )
        endif;
      endif
    endif;
    { Check living status of child against status in household questionnaire }
    if QH05(QLINE) = 1 & Q226 <> QH05($) |
       Q226 = 1 & QH05(QLINE) <> QH05($) then
      if demode() = add then
        warning( 2183, QH05($), Q226 )
          select( tr("Line number in the household"), $, 
		          tr("Child living with respondent"), Q226, 
                  tr("Continue"), continue )
      endif;
    endif;
  endif;
  skip to next QPLINE;

PROC Q228_BLOCK
onfocus
  chsex = Q219(QPLINE);

PROC Q228N
onfocus
  childname = Q218(QPLINE);

PROC Q228U
preproc
  protect( $, false );
  if Q228N in 94:96 then
    protect( $, true );
    $ = 9;
  endif;

onfocus
  childname = Q218(QPLINE);

postproc
  { check unit is for special answer, number must be a special answer,
    but special answers are allowed for number when unit is given }
  badspecial( $, Q228N, getsymbol() );
  
  if Q216(QPLINE) = 2 & !(Q228U = 1 | Q228N in 0,1) then  // accepts age at death as 0 or 1 day for child originally reported as stillbirth
    errmsg( 2194 ) 
	  select( tr("Age at death number"), Q228N, 
	          tr("Unit"), Q228U,    
		      tr("Pregnancy outcome"), Q216(QPLINE) );
  endif;

  { Check maximum and minimum values }
  recode Q228U -> maxd;
            1  -> 30;       { 0-30 days   }
            2  -> 23;       { 1-23 months }
            3  -> 40;       { 2-40 years  }
               -> 99;
  endrecode;
  mind = Q228U-1;
  if Q228U = 9 then mind = 0 endif;
  if Q228U = 3 & Q228N = 1 then           { requested by Bernard on 11/12/2015 }
    errmsg( 2193 ) select( tr("Age at death number"), Q228N, 
	                       tr("Unit"), Q228U );
  elseif !( Q228N in mind:maxd ) then
    errmsg( 2191, mind, maxd, Q228U ) 
	  select( tr("Age at death number"), Q228N, 
	          tr("Unit"), Q228U );
  endif;

  { Check age at death plausible considering date of birth }
  recode Q228U :: Q228N   -> adeath;
               :: missing -> 0;
               ::  >=97   -> 0;
            1  ::         -> int(Q228N/30);
            2  ::         -> Q228N;
            3  ::         -> Q228N*12;
               ::         -> 0;
  endrecode;
  if ldc(QPLINE) + adeath > di then
    if demode() = add then
      warning( 2192, {ldc(QPLINE), adeath, di} Q220D, Q220M, Q220Y, Q228N, GetLabel( Q228U, Q228U ), QINTD, QINTM, QINTY )
	    select( tr("Date of birth"), Q220_BLOCK, 
		        tr("Age at death"), Q228_BLOCK, 
				tr("Continue"), continue );
    endif
  elseif udc(QPLINE) + adeath > di then
    udc(QPLINE) = di - adeath
  endif;

PROC Q228A
skip to next QPLINE
PROC Q232
preproc
  if !calendid then
    calendid = userbar( add button, tr("Calendar"), showcal());
  endif;

postproc
  { use to clear calendar from current pregnancy in case of back+tab }
  { and a change from 1-currently pregnant to 2-no pregnant          }
  FillC1Cal( 2 );
  if $ <> 1 then
    skip to Q236N
  endif;

PROC Q233U
  recode $ :: Q233N -> err;
         1 :: 5:45  -> 0;     { weeks }
	     2 :: 1:10  -> 0;     { months }
	       ::       -> 1;
  endrecode;
  if err then
    errmsg( 2142 ) select( tr("Duration of pregnancy"), Q233_BLOCK );
  endif;

  Q233DUR = Q233N; 
  if $ = 1 then Q233DUR = int(Q233N * WeeksMonth) endif;
  { Assign pregnancy and duration of pregnancy to the calendar }
  FillC1Cal( 2 );

PROC Q234
  if $ = 1 then
    skip to Q236N
  endif;

PROC Q236N
onfocus
  protect( Q236U, false );

PROC Q236U
preproc
  if Q236N in 94:96 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q236N, getsymbol() );

  { menopause/hysterectomy before age 30 }
  if Q236N = 94 & agew in 15:29 & demode() = add then
    warning( 82363, agew ) 
	  select( tr("Time since last period"), Q236_BLOCK, tr("Continue"), continue );
  endif;
  { check current age with time since last period }
  if Q236U = 4 & valid(Q236N) & Q236N > agew - 10 & demode() = add then
    warning( 82364, agew ) 
	  select( tr("Time since last period"), Q236_BLOCK, tr("Continue"), continue )
  endif;
  { Check response "before last pregnancy" given only when had one or more pregnancies }
  if Q236N = 95 & !Q212W & demode() = add then
    warning( 02360 ) 
	  select( tr("Time since last period"), Q236_BLOCK, tr("Continue"), continue )
  endif;
  { Never menstruated but had pregnancy or is currently pregnant }
  if Q236N = 96 & ( Q212W > 0 | Q232 = 1 ) then
    warning( 82369, Q212W, Q232 ) 
	  select( tr("Time since last period"), Q236_BLOCK, tr("Continue"), continue );
  endif;
  recode  $ -> temp;
          1 -> int(Q236N/365);
	      2 -> int(Q236N/52);
	      3 -> int(Q236N/12);
          4 -> Q236N;
            -> 99;
  endrecode;
  if Q236N in 94:95 then
    skip to Q240
  elseif Q236N = 96 then
    skip to Q241
  elseif temp <> 0 then
    skip to Q240
  endif;

PROC Q238
  $ = SortAlpha( $ );
  { Check "Nothing" only response }
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  { Get other answer }
  elseif pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q240
  { check current age with age at menarchy }
  if valid($) & $ > agew then
    warning( 82365, agew ) 
	  select( tr("Age at menarche"), $, 
	          tr("Continue"), continue);
  endif;

PROC Q241
  if $ <> 1 then
    skip to Q243
  endif;

PROC Q242
  if $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC QWSEC3A_FORM
preproc
  do i = 1 while i <= maxocc( QWSEC3A_GRP )
    Q301N(i) = i
  enddo;
  Q307N = notappl;

{ !!! This procedure is used in case the survey implements the spontaneous knowledge of method.
      If that is the case variable QALLMETH must be included as the first field in the
      contraceptive table form
PROC QALLMETH
  $ = SortAlpha( $ );
  { Check "No one" is only response }
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  endif;
  *** end of procedure for QALLMETH }

PROC Q301_INTRO
  $ = "";
  SaveData();

PROC Q301N
  if android then 
    setocclabel(QWSEC3A_GRP(curocc()),getlabel($,$));
  endif;

PROC Q301
preproc
  numeric oldvalm = visualvalue( $(Q301N) );
  if Q301N >= methoth then
    if visualvalue($(Q301N)) in 1,2 then
      $ = oldvalm;
    else
      $ = 2
    endif;
    noinput;
  { !!! Logic used in conjunction with the use of QALLMETH
  elseif Q301N in 1:13 & pos( "ABCDEFGHIJKLM"[Q301N:1], QALLMETH ) then
    $ = 1;
    noinput;
   *** end of logic to be used with field QALLMETH }
  endif;
  {Standard days method deleted in TJ23 quest}
  if Q301N = 10 then 
	skip to next Q301N;
  endif;
onfocus
  methname = GetLabel( Q301, Q301N );

PROC Q301OT
  $ = SortAlpha( $ );
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  endif;
  if pos( "A", $ ) then
    Q301(methoth) = 1
  else
    Q301(methoth) = 2
  endif;
  if pos( "B", $ ) then
    Q301(methoth+1) = 1
  else
    Q301(methoth+1) = 2
  endif;
  if pos( "A", $ ) then
    if demode() = add then
      display( tr("Record other modern method") );
	endif;
    getother( GetSymbol(), methoth );
    enter FL_OTHERS
  endif;
  if pos( "B", $ ) then
    if demode() = add then
      display( tr("Record other traditional method") );
	endif;
    getother( GetSymbol(), methoth+1 );
    enter FL_OTHERS
  endif;

PROC Q303
preproc
  { currently pregnant }
  if Q232 = 1 then
    skip to QWSEC3C_FORM
  endif;

onfocus
  Q307N = notappl;

postproc
  if $ = 1 then
    skip to Q307
  endif;

PROC Q304
  if $ in 1:3 then
    skip to Q307
  endif;	

PROC Q306
onfocus
  Q307N = notappl;
  
postproc 
  if $ <> 1 then
    Q307N = notappl;
    skip to QWSEC3C_FORM
  endif;	

PROC Q307
preproc
  SaveData();

onfocus
  protect($, false);
  if Q304 = 1 then
    $ = "A";
    protect( $, true );
  elseif Q304 = 2 then
    $ = "B";
    protect( $, true );
  elseif Q304 = 3 then
    $ = "AB";
    protect( $, true );
  endif;

postproc
  $ = SortAlpha( $ );
  { "?" not allowed }
  if pos( "?", $ ) then
    errmsg( 9997, "?" ) select( tr("Fix answers marked"), $ );
  elseif Q304 in 1,3 & !pos( "A", $ ) then
    errmsg( 3145 ) select( tr("Fix answers marked"), $ );
  elseif Q304 in 2,3 & !pos( "B", $ ) then
    errmsg( 3146 ) select( tr("Fix answers marked"), $ );
  elseif Q304 = 4 & poschar("AB",$) then
    errmsg( 3150, Q304 )
	  select( tr("Current method"), $,
	          tr("Respondent or partner sterilized"), Q304 );
  endif;

  { Check all methods are known  }
  {!!! assumes a one to one correspondence between current method and contraceptive table }
  y = length( strip(Q307) );
  do x = 1 while x <= y 
    meth = pos( $[x:1], q307str );
    if Q301(meth) <> 1 then
      errmsg( 3142, GetLabel(Q307, $[x:1]) )
	    select( tr("Current method"), $,
		        tr("Knowledge of") + " " + GetLabel(Q307, $[x:1]), Q301(meth) );
    endif;
  enddo;

  { Get other answer }
  if pos( "X", $ ) then
    if demode() = add & pos( "XY", $ ) then
      display( tr("Record other modern method") );
	endif;
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  if pos( "Y", $ ) then
    if demode() = add & pos( "XY", $ ) then
      display( tr("Record other traditional method") );
	endif;
    getother( GetSymbol(), 1 );
    enter FL_OTHERS
  endif;

  { Numeric code for highest ranking method }
  Q307N = pos( $[1:1], Q307STR );
  if Q307N = methoth then   { !! adjust according to position of other code (X) in Q307STR }
    Q307N = 95;
  elseif Q307N = methoth+1 then
    Q307N = 96;
  endif;
{adjusted for TJ23}
  if Q307N in stermeth,stermetm then  { Female or male sterilization }
    skip to Q312
  elseif Q307N in 3,4,5,6,7,8:96 then       { IUD, injectables, implants, pills, f/condom, emergency, SDM, LAM, rhythm, withdrawal, others }
    skip to Q314M
  endif;

PROC Q312
  majorgrp( $ );
  if $ in 26,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q313_BLOCK
onfocus
  alphmeth = GetLabel( Q307N, Q307N );

PROC Q313Y
  if afterint( Q313M, $, QINTM, QINTY ) then
    errmsg( 89998 ) select( tr("Date of sterilization"), Q313_BLOCK );
  endif;
  if validyr($) then
    lds = setlb( Q313M, $, 0 );
    uds = setub( Q313M, $, 9999 );
  else
    lds = ldb+minab;
    uds = di;
  endif;
  col1currm( lds );
  skip to QWSEC3C_FORM;

PROC Q314_BLOCK
onfocus
  alphmeth = GetLabel( Q307N, Q307N );
  
PROC Q314Y
  if afterint( Q314M, $, QINTM, QINTY ) then
    errmsg( 89998 ) select( tr("Date started using method"), Q314_BLOCK );
  endif;
  if validyr($) then
    lds = setlb( Q314M, $, 0 );
    uds = setub( Q314M, $, 9999 );
  else
    lds = ldb+minab;
    uds = di;
  endif;
  col1currm( lds );

PROC QWSEC3C_FORM
preproc
  if !eventsid then
    eventsid = userbar( add button, tr("Events"), showroster(3) );
  endif;

postproc
  { Check rows after date of interview are not used }
  do i = 1  while i <= calint-1
    if QCAL1[i:1] <> " " then
      MnthYear( i );
      errmsg( 9800, mnthstr1, year ) 
	    select( tr("Go back to pregnancy history to reset calendar"), Q209 );
    endif;
  enddo;

  { Check column 1, births/pregnancies/terminations and use of methods }
  { ------------------------------------------------------------------ }
  t = 0;
  b = Q212W;
  do i = calint while i <= callen

    { Check entries in column 1 }
    textstr1 = pregstr + "0" + methstr;
    if !pos( QCAL1[i:1], textstr1 ) then
      MnthYear( i );
      errmsg( 9801, QCAL1[i:1], 1, mnthstr1, year )
        select( tr("Introduction to calendar"), QINTROUSE );
    endif;

    { Check birth in calendar matches births in birth history }
    if QCAL1[i:1] in codeb,codet then
      calcmc = rowcmc(i);
      if b & calcmc in ldc(b):udc(b) then
        calrow(b) = i;
      else
        if b then
          xl = ldc(b);
          xu = udc(b);
        else
          xl = 0;
          xu = 0;
        endif;
        MnthYear( i );
        errmsg( 9802, mnthstr1, year, calcmc, b, xl, xu ) 
		  select( tr("Go back to pregnancy history to reset calendar"), Q209 );
      endif;
      while twincode(b) > 1 do
        b = b - 1;
        calrow(b) = i;
      enddo;

      { Check gestation length of pregnancies agrees with gestation in pregnancy history }
      do j = i + 1 while j <= callen & QCAL1[j:1] = codep
      enddo;
      if j < callen & j - i <> Q221DUR(b) then
        MnthYear( i );
        errmsg( 9803, mnthstr1, year, j-i, Q221U(b), Q221N(b) )
		  select( tr("Duration of pregnancy"), Q221_BLOCK(b) );
      endif;
      b = b - 1;
      i = j - 1;

    { Check termination pregnancies length agree with duration in termination history }
    elseif QCAL1[i:1] = codet then
      t = t + 1;
      do j = i + 1 while j <= callen & QCAL1[j:1] = codep
      enddo;
{     if j < callen & ( t = 1 & j - i <> Q221DUR(1) | t <> 1 & j - i <> Q221DUR(t-1) ) then }
      if j < callen &  j - i <> Q221DUR(t) then
        MnthYear( i );
        errmsg( 9819, mnthstr1, year, j-i, Q221U(t), Q221N(t) )
		  select( tr("Duration of pregnancy"), Q221_BLOCK(t) );
{
        if t = 1 then
          errmsg( 9819, strip(mnthstr1), year, j-i, "Q233", Q221DUR(1) );
          reenter zzA230;
        else
          errmsg( 9819, strip(mnthstr1), year, j-i, "termination history", Q221DUR(t-1) );
          reenter Q221DUR(t-1);
        endif;
}
      endif;
      i = j - 1;

    { Check pregnancy codes are either for current pregnancy, }
    { or for pregnancies that are terminated }
    elseif QCAL1[i:1] = codep then
      if i > 1 & !pos( QCAL1[i-1:1], " "+pregstr ) then
        MnthYear( i );
        errmsg( 9818, mnthstr1, year )
          select( tr("Introduction to calendar"), QINTROUSE,
 		          tr("Go back to current pregnancy"), Q232 );
      endif;

    endif;
  enddo;

  { Check all births since January 201? are represented in calendar }
  do b = Q212W while b by (-1)
    if ldc(b) >= calbeg & !calrow(b) then
      errmsg( 9804, b )
        select( tr("Go back to pregnancy history to reset calendar"), Q209 );
    endif;
  enddo;
  { Check for current pregnancy in the calendar }
  if Q232 = 1 & QCAL1[calint:1] <> codep then
    errmsg( 89823 )
	  select( tr("Go back to current pregnancy"), Q232 );
  endif;

  { Check contraception use in calendar }
  { Check current use of sterilization if it didn't occur in the month of }
  { interview and at the same time a birth or termination occurred        }
{
  if QCAL1[calint:1] <> codeb & QCAL1[calint:1] <> codet &
     Q301(1) = 1 & QCAL1[calint:1] <> edit("9",stermeth) then
    errmsg( 3031 );
    reenter Q301(1);
  endif;
}
  { Check current method with method given in calendar }
  if pos( QCAL1[calint:1], methstr ) then
    t = pos(QCAL1[calint:1],methstr);
    m = pos(Q307[1:1],Q307STR);
    if t <> m then
      errmsg( 3131, Q307, QCAL1[calint:1] ) select( tr("Current method"), Q307 );
    endif;
  elseif Q307N <> notappl then
    meth    = MethInStr( Q307N, methoth );
    onemeth = methstr[meth:1];
    if QCAL1[calint:1] <> codeb & QCAL1[calint:1] <> codet & QCAL1[calint:1] <> onemeth then
      errmsg( 3131, Q307, QCAL1[calint:1] ) select( tr("Current method"), Q307 );
    endif;
  endif;

  { Find first date used method in calendar }
  if Q307N <> notappl then
    meth    = MethInStr( Q307N, methoth );
    onemeth = methstr[meth:1];            { to check date started using any method }
    b = pos( codeb, QCAL1 );
    t = pos( codet, QCAL1 );
    if t & ( t < b | !b ) then
      b = t
    endif;
    do i = calint while i <= callen & QCAL1[i:1] = onemeth
    enddo;
    { Found method }
    if i <= callen then
      i = i - 1;
      x = rowcmc(i)
    { No method, but birth in month of interview }
    elseif b = calint then
      x = rowcmc(b)
    else
      x = 0
    endif;
    { Birth in month of interview or in month prior to method use in calendar }
    if b = calint | b = i + 1 then
      y = rowcmc(b)
    else
      y = x
    endif;
    { Check method start date from calendar agrees }
    if (i <= callen & (lds > x | uds < y)) |
       (i >  callen & lds >= calbeg) then
	  if Q313Y <> notappl then
        warning( 3211, lds, uds, x, i ) 
	      select( tr("Date of sterilization"), Q313_BLOCK, tr("Continue"), continue );
	  else
        warning( 3211, lds, uds, x, i ) 
	      select( tr("Date of start of current method"), Q314_BLOCK, tr("Continue"), continue );
      endif;				  
    endif;
    if i <= callen then
      if lds < y then
        lds = y
      endif;
      if uds > x then
        uds = x
      endif;
    endif;
  endif;

  { Look for prior use of sterilization method,
    or of female sterilization if currently using male sterilization }
  if Q307N in stermeth,stermetm then
    do i = i + 1 while i <= callen & !pos( QCAL1[i:1], onemeth+"A" )
    enddo;
    if i <= callen then
      warning( 3212, i ) 
	    select( tr("Current method"), Q307, tr("Continue"), continue );
    endif;
  endif;

  { Check column 2, discontinuation reasons }
  { --------------------------------------- }
  discont = 0;
  caluse = 0;
  xusing = default;              { Whether using in month i-1 }
  do i = calint while i <= callen

    { Checks entries in column 2 }
    if !pos( QCAL2[i:1], " 012345678NFADXZ" ) then
      MnthYear( i );
      errmsg( 9801, QCAL2[i:1], 2, mnthstr1, year )
        select( tr("Introduction to calendar"), QINTROUSE );
    endif;

    { Checks for discontinuation of use, but col 2 blank }
    used = pos( QCAL1[i:1], methstr );       { Whether using in month i }
    if used & xusing <> used & xusing <> default then
      discont = discont + 1;
      if QCAL2[i:1] = " " then
        errmsg( 9805, i ) select( tr("Introduction to calendar"), QINTROUSE );
      elseif i < callen & QCAL2[i+1:1] <> " " then
        errmsg( 9806, i, i+1 );
      endif;
    endif;
    if used & !caluse then
      caluse = i
    endif;

    { Checks for col 2 not blank, but no contraceptive method }
    if QCAL2[i:1] <> " " & (!used | used = xusing) then
      errmsg( 9807, i ) select( tr("Introduction to calendar"), QINTROUSE );
    endif;

    xusing = used;
  enddo;

PROC QINTROUSE
preproc
  if Q307N <> notappl & lds <= calbeg then
    { blank out column 2 in case of modify mode }
    do i = 1 while i <= callen
      QCAL2[i:1] = " ";
    enddo;
    skip to Q329;
  endif;

onfocus
  $ = " ";
  { blank out column 1 for codes other than pregnancy related and column 2 }
  do i = 1 while i <= callen
    if !pos( QCAL1[i:1], pregstr ) then
      QCAL1[i:1] = " ";
    endif;
    QCAL2[i:1] = " ";
  enddo;

postproc
  { prepare event table to help drawing the calendar }
  i = 1;
  if Q232 = 1 then
    womevents(i,1) = tr("Current-Pregnancy");
    womevents(i,2) = edit("99",QINTM) + "/" + edit("9999",QINTY);
    womevents(i,3) = edit("99",Q233DUR);
  elseif Q307N <> notappl then
    womevents(i,1) = GetValueLabel( Q307N );
    womevents(i,2) = edit("99",Q314M) + "/" + edit("9999",Q314Y);
    womevents(i,3) = edit("99", di - cmcode( Q314M, Q314Y ) + 1);
  endif;
  do j = 1 while j <= totocc( QWSEC2B_ROSTER2 )
    if QLAST5(j) = 1 then
      i = i + 1;
      womevents(i,1) = Q218(j);
      womevents(i,2) = edit("99",Q220M(j)) + "/" + edit("9999",Q220Y(j));
      womevents(i,3) = edit("99",Q221DUR(j));
    endif;
  enddo;
  while i < 20 do
    i = i + 1;
    womevents(i,1)  = " ";
    womevents(i,2)  = " ";
    womevents(i,3)  = " ";
  enddo;
  if demode() = add then
    showroster( 3 );
  endif;

PROC Q317N
preproc
  $ = curocc();
  QCDURIN = 0;

postproc
  if $ = 1 then
    if Q307N <> notappl then                        { current users }
      col1currm( lds );
      beguse   = cmcrow( lds ) + 1;
      do i = beguse while i <= callen & pos( QCAL1[i:1], pregstr )
      enddo;
      begcheck = i;
    elseif pos( QCAL1[calint:1], pregstr ) then     { pregnancy, terminations, births }
      do i = calint while pos( QCAL1[i:1], pregstr )
      enddo;
      begcheck = i;
    else                                            { not using a method }
      QCAL1[calint:1] = "0";
      do i = calint+1 while i <= callen & pos( QCAL1[i:1], pregstr )
      enddo;
      begcheck = i;
    endif;
  elseif QCDIRNEXT($-1) = 2 then
    do i = QCBEVENT($-1)+1 while pos(QCAL1[i:1], pregstr) & i <= callen
    enddo;
    begcheck = i;
  else
    begcheck = QCROWNEXT($-1);
  endif;
  if begcheck > callen then
    endgroup
  endif;
  if $ = 1 | QCDIRNEXT($-1) = 2 then
    goingdown( begcheck, $ );
    { variable QCFEVENT stores the row where an event finishes         }
    { the variable has the same value for all episodes within the event }
    { variable QCBEVENT stores the row where an event begins           }
    { the variable has the same value for all episodes within the event }
    QCFEVENT = endrowint;
    QCBEVENT = begrowint;
  else
    goingup( begcheck, $ );
    QCFEVENT = QCFEVENT($-1);
    QCBEVENT = QCBEVENT($-1);
  endif;

PROC Q317AM
preproc
  $ = QCAUXM1;

PROC Q317AY
preproc
  $ = QCAUXY1;

postproc
  if Q307N <> notappl & cmcode( Q317AM, Q317AY ) >= lds then
    warning( 82285, Q314M, Q314Y );
  endif;

PROC Q317B
onfocus
  year1  = Q317AY;
  month1 = Q317AM;
  if !( Q317AY = QINTY & Q317AM = QINTM | Q317AY = calbegy & Q317AM = 1 ) then
    month1 = Q317AM - 1;
    if month1 = 0 then
      month1 = 12;
      year1  = year1 -1;
    endif;
  endif;
  mnthstr1 = GetLabel( Q317AM, month1 );
  year2  = QCAUXY2;
  month2 = QCAUXM2;
  if !( QCAUXY2 = calbegy & QCAUXM2 = 1 ) then
    month2 = QCAUXM2 + 1;
    if month2 = 13 then
      month2 = 1;
      year2  = year2 + 1;
    endif;
  endif;
  mnthstr2 = GetLabel( Q317AM, month2 );
  textbegin( curocc() );
  textend( curocc() );

  // set episode start and end indicators
  disp1 = cmcrow(cmcode(month1, year1));
  disp2 = cmcrow(cmcode(month2, year2));

  if demode() = add & special(visualvalue($)) then
    showcal();
  endif;

postproc
  if $ <> 1 then
    Q317C = " ";
    skip to Q317F
  endif;

PROC Q317C
postproc
  xrow = cmcrow( cmcode(Q317AM,Q317AY) );
  CleanCal( xrow, Q317N );
  if !length( strip($) ) then
    errmsg( 89999 ) select( tr("Method used"), $ );
  { Get "Other" answers for methods in column 1 }
  elseif pos( $, "XY" ) then
    getother( "QCAL1", xrow );
    enter FL_OTHERS
  endif;
  method = pos( $, methstr );
  if method = 1 then
    errmsg( 83136 ) select( tr("Method used"), $); 
  elseif method & Q301(method) <> 1 then
    errmsg( 83135 )
      select( tr("Knowledge of method"), Q301(method), 
	          tr("Method used"), $ );
  endif;

PROC Q317D
onfocus
  alphmeth = GetValueLabel(Q317C);
  begevent = cmcode(Q317AM,Q317AY);

postproc
  begrow = cmcrow( cmcode(Q317AM,Q317AY) );
  if $ = 0 then
    if begrow <= callen & Q317C = QCAL1[begrow+1:1] then
      errmsg( 83137 ) select( tr("Method used"), Q317C );
    endif;
  endif;
  if $ <> 95 then
    if $ > begrow-QCFEVENT(Q317N) then
      errmsg( 83138, begrow-QCFEVENT(Q317N) ) select( tr("Months not using"), $ );
    else
      do i = begrow while i > begrow-$ by (-1)
        QCAL1[i:1] = "0";
        QCAL2[i:1] = " ";
      enddo;
      QCDURIN = $;
      skip to Q317F;
    endif;
  endif;

PROC Q317E_BLOCK
onfocus
  alphmeth = GetLabel( Q317C, Q317C );

PROC Q317EM
preproc
  if visualvalue( Q317EM(Q317N) ) = notappl then
    begrow = cmcode(Q317AM,Q317AY);
    $ = ( begrow-1) % 12 + 1;
  endif;

PROC Q317EY
preproc
  if visualvalue( Q317EY(Q317N) ) = notappl then
    begrow = cmcode(Q317AM,Q317AY);
    $ = int( (begrow-1)/12 + 1900 );
  endif;

postproc
  begrow = cmcrow( cmcode(Q317AM,Q317AY) );
  endrow = cmcrow( cmcode(Q317EM,$) );
  if endrow = begrow & Q317C = QCAL1[begrow+1:1] then
    errmsg( 83137 ) select( tr("Method used"), Q317C );
  endif;
  QCDURIN = begrow - endrow;
  if QCDURIN > begrow-QCFEVENT(Q317N) then
    errmsg( 83138, begrow-QCFEVENT(Q317N)+1 ) select( tr("Date began using"), $ );
  elseif QCDURIN < 0 then
    errmsg( 83142 ) select( tr("Date began using"), $ );
  else
    do i = begrow while i > endrow by (-1)
      QCAL1[i:1] = "0";
      QCAL2[i:1] = " ";
    enddo;
  endif;

PROC Q317F
preproc
  if Q317B = 2 then
    begrow = cmcrow( cmcode(Q317AM,Q317AY) );
    endrow = cmcrow( cmcode(QCAUXM2,QCAUXY2) );
    $ = begrow - endrow + 1;
    noinput;
  endif;

onfocus
  alphmeth = GetValueLabel(Q317C);
  if Q317B = 1 then
    protect( $, false );
  else
    protect( $, true );
  endif;

postproc
  if $ <> 95 then
    begrow = cmcrow( cmcode(Q317AM,Q317AY) ) - QCDURIN;
    if $ > begrow-QCFEVENT(Q317N)+1 then
      errmsg( 83138, begrow-QCFEVENT(Q317N)+1 ) select( tr("Months using"), $ );
    endif;
    endrow = begrow - $ + 1;
    cmcend = rowcmc( endrow );
    QCAUXM2 = ( cmcend-1 ) % 12 + 1;
    QCAUXY2 = int( (cmcend-1)/12 + 1900 );
    skip to Q317H;
  endif;

PROC Q317G_BLOCK
onfocus
  alphmeth = GetValueLabel(Q317C);
  
PROC Q317GM
preproc
  month = visualvalue( Q317GM(Q317N) );
  if month = notappl | month = QCAUXM2 then
    $ = QCAUXM2;
  endif;

PROC Q317GY
preproc
  year  = visualvalue( Q317GY(Q317N) );
  if year = notappl | year = QCAUXY2 then
    $ = QCAUXY2;
  endif;

postproc
  QCAUXM2 = Q317GM;
  QCAUXY2 = $;
  if afterint( QCAUXM2, QCAUXY2, QINTM, QINTY ) then
    errmsg( 89998 ) select( tr("Date end using"), Q317G_BLOCK );
  endif;

PROC Q317H
preproc
  { first analyze consistency of episodes }
  begrow = cmcrow( cmcode(Q317AM,Q317AY) ) - QCDURIN;
  endrow = cmcrow( cmcode(QCAUXM2,QCAUXY2) );
  if endrow > begrow then
    errmsg( 83134 ) select( tr("Months using"), Q317F );
  { following instructions to customize error messages }
  { when the termination of the episode falls above    }
  { the upper limit between the events                 }
  elseif begrow-endrow+1 > begrow-QCFEVENT(Q317N)+1 then
    { if date falls during a pregnancy episode }
    if pos( QCAL1[endrow:1], pregstr ) then
      do i = endrow while pos( QCAL1[i:1], pregstr )
      enddo;
      temp = i-endrow;
      do i = endrow while pos( QCAL1[i:1], pregstr ) by (-1)
      enddo;
      calcode  = QCAL1[i+1:1];
      cmcend   = rowcmc( i+1 );
      month1   = ( cmcend-1 ) % 12 + 1;
      year1    = int( (cmcend-1)/12 ) + 1900;
      mnthstr1 = GetLabel( Q317AM, month1 );
      textstr1 = tr("The date of end of the episode exceeds by") + " " + edit("99",temp) + " " + tr("months") + " ";
      if calcode = codeb then
        textstr2 = tr("the pregnancy of") + " " + strip(Q218(birthrow(i+1))) + " " + tr("in") + " " + mnthstr1 + ", " + edit("9999",year1);
      elseif calcode = codet then
        textstr2 = tr("the") + " " + strip(Q218(birthrow(i+1))) + " " + tr("that occurred in") + " " + mnthstr1 + ", " + edit("9999",year1);
      elseif calcode = codep then
        textstr2 = tr("the current pregnancy");
      else
        textstr2 = tr("another (unexpected) event");
      endif;
    { if date falls after conclusion of a pregnancy episode }
    else
      do i = endrow while !pos( QCAL1[i:1], pregstr ) & i <= callen enddo;
      temp     = i-endrow;
      calcode  = QCAL1[i:1];
      textstr1 = tr("The date of end of the episode exceeds by") + " " + edit("99",temp) + " " + "months" + " ";
      if calcode = codeb then
        textstr1 = textstr1 + " " + tr("the birth of") + " " + strip(Q218(birthrow(i))) + " " + tr("in") + " ";
      elseif calcode = codet then
        textstr1 = textstr1 + " " + tr("the") + " " + strip(Q218(birthrow(i))) + " " + tr("that occurred in") + " ";
      else
        textstr1 = textstr1 + " " + tr("another (unexpected) event") + " ";
      endif;
      cmcend   = rowcmc( i );
      month1   = ( cmcend-1 ) % 12 + 1;
      year1    = int( (cmcend-1)/12 ) + 1900;
      mnthstr1 = GetLabel( Q317AM, month1 );
      textstr2 = mnthstr1 + ", " + edit("9999",year1);
    endif;
    errmsg( "%s %s", textstr1, textstr2 ) select( tr("Months using"), Q317F );
  endif;
  do i = endrow while i <= callen & i <= begrow
    if Q317B = 2 then
      QCAL1[i:1] = "0";
      QCAL2[i:1] = " ";
    else
      QCAL1[i:1] = Q317C;
    endif;
  enddo;
  { set up row and direction for next episode }
  if endrow <= QCFEVENT | endrow <= calint then
    QCDIRNEXT = 2;                { next event go down (interview towards begin of calendar) }
  else
    QCDIRNEXT = 1;                { next event go up (end of event towards month of interview) }
    QCROWNEXT = endrow;
    { clear the remaining of the interval upwards in case that dates change }
    do i = endrow-1 while i >= QCFEVENT by (-1)
      QCAL1[i:1] = " ";
      QCAL2[i:1] = " ";
    enddo;
  endif;
  { clear the remaining of the interval upwards in case that dates change }
  do i = QCBEVENT+1 while i <= callen
    if !pos( QCAL1[i:1], pregstr ) then
      QCAL1[i:1] = " ";
    endif;
    QCAL2[i:1] = " ";
  enddo;
  { current method should be different from previous episode of use }
  {  if endrow > calint & Q317B = 2 & Q317C = QCAL1[endrow-1:1] then changed on 09/08/2008 needs to be checked }
  if endrow > calint & Q317B = 1 & Q317C = QCAL1[endrow-1:1] then
    errmsg( 83140, GetValueLabel(Q317C) ) select( tr("Method used"), Q317C );
  endif;

  { finally clear row and skip if didn't use any method }
  QCAL2[begrow:1] = " ";  { blank out the row first }
  if Q317B = 2 then
    skip to next Q317N
  endif;

onfocus
  alphmeth = GetValueLabel(Q317C);

postproc
  endrow = cmcrow( cmcode(QCAUXM2,QCAUXY2) );
  if !length( strip($) ) then
    errmsg( 89999 ) select( tr("Reason stop using"), $ );
  { Get "Other" answers reason for discontinuation in column 2 }
  elseif pos( "X", $ ) then
    getother( "QCAL2", endrow );
    enter FL_OTHERS
  endif;
  QCAL2[endrow:1] = $;

PROC QCAL2
  if demode() = add then
    showcal();
  endif;

PROC Q318
  if $ = 1 & Q301(9) <> 1 then
    warning( 3132 ) 
	  select( tr("Use of emergency contraception"), $, 
	          tr("Continue"), continue );
  endif;

PROC Q320
preproc
  if caluse | Q307N <> notappl then
    $ = 1;        { Force value of 1 if method used in calendar }
    noinput       { to allow easy checking of ever use later }
  endif;

postproc
  if ( caluse | Q307N <> notappl ) & $ <> 1 then
    errmsg( 3051 ) select( tr("Ever use of contraception"), $);
  elseif $ = 2 then
    { for respondents that have never used a method assign zeros to months }
    { where no births, pregnancies or terminations are registered          }
    do i = calint while i <= callen
      if !pos( QCAL1[i:1], pregstr ) then
        QCAL1[i:1] = "0";
      endif;
      QCAL2[i:1] = " ";
    enddo;
    skip to Q331;
  endif;

PROC Q321
preproc
  if Q307N = notappl then
    $ = 0
  else
    $ = Q307N;
  endif;

postproc
  if noteq( $, Q307N ) then
    errmsg( 3270, Q307[1:1] ) select( tr("Current method"), Q307 );
  endif;
  if $ = 0 then                       { no method }
    skip to Q331
  elseif $ = stermeth then            { female sterilization }
    skip to Q324
  elseif $ in stermetm,11:13,96 then  { male sterilization, LAM, rhythm, withdrawal, other }
    skip to Q332
  endif;

PROC Q322
onfocus
  alphmeth = GetLabel( Q307N, Q307N );
  mnthstr1 = GetLabel( Q314M, Q314M );

postproc
  majorgrp( $ );
  if $ in 26,37,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q323
  skip to Q325

PROC Q327
preproc
  $ = Q307N;
  
postproc
  if $ = 1 then
    skip to Q332
  endif;  

PROC Q328
  skip to Q330;

PROC Q329
preproc
  $ = Q307N;

postproc
  if noteq( $, Q307N ) then
    errmsg( 3270, Q307[1:1] ) select( tr("Current method"), Q307 );
  elseif $ in stermeth,stermetm,11:13,96 then  { f/m ster, LAM, rhythm, withdrawal, other traditional }
    skip to Q332
  endif;

PROC Q330
onfocus
  alphmeth = GetLabel( Q307N, Q307N );

postproc
  majorgrp( $ );
  if $ in 26,37,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  skip to Q332;

PROC Q332
  if $ <> 1 then
    skip to Q334
  endif;

PROC Q334
preproc
  SaveData();

postproc
  if $ <> 1 then
    endgroup
  endif;

PROC QWSEC04_FORM
preproc
  { initialize variables used to count entries for different sections }
  QESEC4 = 0;
  QESEC5 = 0;
  QESEC6 = 0;
  numeric fullcdc, livcdc, livcmc, prevb, prevs;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  pregpcare = 0;
  fullcdc = count(QWSEC2B where Q220CD <> 0);
  if Q212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    pregpcare = count(QWSEC2B where int((dicdc - Q220CD)/DaysMonth) < yrspcare*12);
  else
    { count pregnancies based on CDC codes } 
	livcdc = 0;
	do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if int((dicdc - Q220CD(i))/DaysMonth) < yrspcare*12 then
	    livcdc = i;               // assume remaining pregnancies occurred after this one
		break;
	  endif; 
	enddo;
	if livcdc then livcdc = Q212W - livcdc + 1 endif;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if di - udc(i) < yrspcare*12 then
	    livcmc = i;               // assume remaining pregnancies occurred after this one
		break;
	  endif; 
	enddo;
	if livcmc then livcmc = Q212W - livcmc + 1 endif;
	pregpcare = livcdc;
	if livcmc > livcdc then pregpcare = livcmc endif;
  endif;  
  if !pregpcare then 
    endgroup
  endif;
  { initialize heading variables }
  QESEC4 = pregpcare;
  prevb = 0;
  prevs = 0;  
  do i = 1 while i <= max5
    if i <= pregpcare then
      QCOL41(i) = i;
	  idx     = Q212W - i + 1;
	  Q404(i) = idx;
	  pregtype = Q223(idx);
	  recode pregtype :: prevb :: prevs -> temp;
                1     ::   0   ::       -> 1;	// last live birth
                1     ::       ::       -> 2;	// prior live birth
                2     ::       ::   0   -> 3;	// last stillbirth
                2     ::       ::       -> 4;	// prior stillbirth
               3:4    ::       ::       -> 5;	// miscarriage or abortion
      endrecode;
      Q405(i) = temp;
      if temp = 1 then prevb = 1 endif;
      if temp = 3 then prevs = 1 endif;	  
    else
      QCOL41(i) = notappl;
	  Q404(i)   = notappl;
	  Q405(i)   = notappl;
    endif;
  enddo;

PROC Q403
  $ = "";

  if pregpcare & special(visualvalue(Q404(1))) then
    showpreg456("Pregnancies for pregnancy and postnatal care module",Q212W - pregpcare + 1,0);
  endif;

PROC QCOL41
preproc
  if curocc() > 1 then
    SaveData();
  endif;

  if curocc() > pregpcare then
    endgroup
  endif;

PROC Q405
{ leave out this skip, so that date and name are captured for all pregnancies (name may be the type of pregnancy for non-live births)
  if $ in 1,2 then
    skip to Q407
  endif;	
}

PROC Q406D 
preproc
  Q406D = Q220D(Q404);
  Q406M = Q220M(Q404);
  Q406Y = Q220Y(Q404);
  
PROC Q407  
preproc
  Q407 = Q218(Q404);

  if android then 
    setocclabel(QWSEC04_ROSTER(curocc()),maketext("%s %d/%d/%d",Q407,Q406D,Q406M,Q406Y));
  endif;

PROC Q408
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

onfocus
  pregtype = (Q405 in 1,2 );
  mnthstr1 = GetLabel(Q406M, Q406M);

postproc
  if $ = 1 then
    skip to Q411
  endif;

PROC Q409
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

postproc
  if $ <> 1 then
    skip to Q411
  endif;

PROC Q410N
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

onfocus
  protect( Q410U, false );

PROC Q410U
preproc
  if Q410N in 90:98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), QCOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q410N, getsymbol() );

PROC Q411
preproc
  $ = Q405;
  
postproc
  if $ in 2,4 then  
    skip to Q434
  elseif $ = 5 then  
    skip to Q476
  endif;

PROC Q412
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;
{modified for TJ23}
postproc
  if $ = 2 then
    if Q405 = 1 then
	  skip to Q426A
	elseif Q405 = 3 then
	  skip to Q426A
	endif;
  endif;  

PROC Q414
preproc
  if copytwin_a($, QCOL41) then noinput endif;

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q415
preproc
  if copytwin_a($, QCOL41) then noinput endif;

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answer }
  {if pos( "F", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;}
  if pos( "I", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
  if pos( "L", $ ) then
    getother( GetSymbol(), 10*curocc()+3 );
    enter FL_OTHERS
  endif;
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+4 );
    enter FL_OTHERS
  endif;

PROC Q416N
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

onfocus
  protect( Q416U, false );

PROC Q416U
preproc
  if Q416N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), QCOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q416N, getsymbol() );
  
  recode $ :: Q416N -> err;
         1 :: 3:45  -> 0;     { weeks }
	     2 :: 1:9   -> 0;     { months }
         9 :: 98    -> 0;
           ::       -> 1;
  endrecode;
  if err then
    errmsg( 4160 ) select( tr("Timing of 1st antenatal visit"), Q416_BLOCK );
  endif;

PROC Q417
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q418A
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;
  
PROC Q418B
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q418C
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q418D
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q418E
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q418F
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q418G
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q426
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;
{modified for TJ23}
postproc
  if $ <> 1 then
    skip to Q430A
  endif;

PROC Q427
preproc
  if copytwin_a($, QCOL41) then noinput endif;

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answer }
  {if pos( "F", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;}
  if pos( "K", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
  if pos( "R", $ ) then
    getother( GetSymbol(), 10*curocc()+3 );
    enter FL_OTHERS
  endif;
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+4 );
    enter FL_OTHERS
  endif;

PROC Q428
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q434
onfocus
  temp = (Q405 in 1,2);
  mnthstr1 = GetLabel(Q406M, Q406M);

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Check "No one" is only response }
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  { Get other answer }
  elseif pos( "X", $ ) then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q435
onfocus
  temp = (Q405 in 1,2);

postproc
  majorgrp( $ );
  if $ in 26,36,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS;
  endif;
  if $ in 11,12,96,missing then
    skip to Q437
  endif;

PROC Q436
onfocus
  temp = (Q405 in 1,2);

PROC Q437
preproc
  $ = Q405;
  
postproc  
  if $ = 2 then
    skip to Q441;
  elseif $ = 3 then
    skip to Q447_BLOCK;
  elseif $ = 4 then
    skip to next QCOL41;
  endif;

PROC Q438
  if $ <> 1 then
    skip to Q441        // if no Newborn module skip should be to Q441
  endif;

PROC Q439
  if $ <> 1 then
    skip to Q441        // if no Newborn module skip should be to Q441
  endif;
  
PROC Q440
onfocus
  textstr1 = GetValueLabel( Q435 );

{ !!!! remove fields QNB1 to QNB7 and QCH2 to QCH4 if Newborn module not used }
PROC Q442
  if $ <> 1 then
    skip to Q447_BLOCK
  endif;

PROC Q443N
onfocus
  protect( Q443U, false );

PROC Q443U
preproc
  if Q443N in 9.998 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  numeric x443n = Q443N * 1000;
  if (Q443U <> 9 & x443n = 9998) |
     (Q443U  = 9 & !x443n in missing,9998) then
    errmsg( 9994 ) select( tr("Unit"), $ );
  elseif x443n <> missing & x443n < 9998 & x443n%100 <> 0 & x443n%100 <> 50 then
    warning( 9993 ) 
	  select( tr("Weight"), Q443N, tr("Continue"), continue );
  endif;

PROC Q447_BLOCK
preproc
  if Q405 = 2 then // can't use <> 1 due to skip from 437
    skip to Q480
  elseif Q435 in 11:12,96 then	
    skip to Q464
  endif;

onfocus
  temp = (Q405 in 1);
  facility = GetValueLabel(Q435);
  mnthstr1 = GetLabel(Q406M, Q406M);

PROC Q447N
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

onfocus
  protect( Q447U, false );

PROC Q447U
preproc
  if Q447N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), QCOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q447N, getsymbol() );

PROC Q448
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

postproc
  if $ <> 1 then
    skip to Q452
  endif;

PROC Q449N
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

onfocus
  protect( Q449U, false );

PROC Q449U
preproc
  if Q449N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), QCOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q449N, getsymbol() );

PROC Q450
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q452
preproc
  if Q405 <> 1 then
    skip to Q455
  endif;	

postproc
  if $ <> 1 then
    skip to Q455
  endif;

PROC Q453N
onfocus
  protect( Q453U, false );

PROC Q453U
preproc
  if Q453N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q453N, getsymbol() );

PROC Q454
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q455
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

postproc
  if $ <> 1 then
    skip to Q460;
  endif;

PROC Q456N
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

onfocus
  protect( Q456U, false );

PROC Q456U
preproc
  if Q456N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), QCOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q456N, getsymbol() );

PROC Q457
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q458
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ in 26,36,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q460
preproc
  if Q405 <> 1 then
    skip to Q474A
  endif;
  
onfocus
  facility = GetValueLabel(Q435);

postproc
  if $ <> 1 then
    skip to Q473A;
  endif;

PROC Q461N
onfocus
  protect( Q461U, false );

PROC Q461U
preproc
  if Q461N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q461N, getsymbol() );

PROC Q462
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q463
  majorgrp( $ );
  if $ in 27,36,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;
  skip to Q473A;

PROC Q464
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

onfocus
  temp = (Q405 in 1,2);
  mnthstr1 = GetLabel(Q406M, Q406M);

postproc
  if $ <> 1 then
    skip to Q469;
  endif;

PROC Q465N
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

onfocus
  protect( Q465U, false );

PROC Q465U
preproc
  if Q465N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), QCOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q465N, getsymbol() );

PROC Q466
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q467
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ in 26,36,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q469
preproc
  if Q405 <> 1 then
    skip to Q474A
  endif;	

postproc
  if $ <> 1 then
    skip to Q473A
  endif;

PROC Q470N
onfocus
  protect( Q470U, false );

PROC Q470U
preproc
  if Q470N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q470N, getsymbol() );

PROC Q471
  majorgrp( $ );
  { Get other answer }
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q472
  majorgrp( $ );
  { Get other answer }
  if $ in 27,36,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q474A
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q474B
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q474C
preproc
  if copytwin(visualvalue($), QCOL41) then noinput endif;

PROC Q476
preproc
  if QCOL41 <> 1 then
    skip to Q479
  endif;	
  
onfocus
  pregtype = (Q405 in 1,2);  
  mnthstr1 = GetLabel(Q406M, Q406M);
  
PROC Q478
preproc
  if Q232 in 1,8 then
    skip to Q479
  endif;
  
onfocus
  pregtype = (Q405 in 1,2);  
  mnthstr1 = GetLabel(Q406M, Q406M);

PROC Q479
preproc
  $ = Q405;
  
postproc  
  if $ <> 1 then
    skip to next QCOL41
  endif;

PROC Q480
  if $ = 1 then
    skip to Q482_BLOCK
  elseif Q224(Q404) = 1 then
    skip to Q486
  else
    skip to next QCOL41  
  endif;

PROC Q482_BLOCK
preproc
  { filter for Q481 }
  if Q480 = 2 & Q224(Q404) = 1 then
    skip to Q486
  elseif Q480 = 2 then
    skip to next QCOL41
  endif;	
	
PROC Q482U
  { check special answers }
  badspecial( $, Q482N, getsymbol() );

PROC Q485
preproc
  if Q224(Q404) <> 1 then                 { Child is dead }
    skip to next QCOL41
  endif;

postproc
  { Still breastfeeding child that is not last or twin of last }
  if (Q404 <= Q208 - twincode(Q208) - (twincode(Q208) = 0)) & $ = 1 then
    warning( 4280 )
  endif;

PROC QWSEC05_FORM
preproc
  numeric fullcdc, livcdc, livcmc;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  pregvacc = 0;
  fullcdc = count(QWSEC2B where Q220CD <> 0);
  if Q212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if Q224(i) = 1 & int((dicdc - Q220CD(i))/DaysMonth) < yrsvacc*12 then
	    pregvacc = pregvacc + 1;
        do j  = i+1 while j <= totocc(QWSEC2B_ROSTER2)
          if Q224(j) = 1 then
	        pregvacc = pregvacc + 1;
		  endif;
		enddo;
		break;
	  endif;
	enddo;
	indexpreg = i;
  else
    { count pregnancies based on CDC codes } 
	livcdc = 0;
	do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if Q224(i) = 1 & int((dicdc - Q220CD(i))/DaysMonth) < yrsvacc*12 then
	    livcdc = livcdc + 1;               // assume remaining pregnancies occurred after this one
        do j  = i+1 while j <= totocc(QWSEC2B_ROSTER2)
          if Q224(j) = 1 then
	        livcdc = livcdc + 1;
		  endif;
		enddo;
		break;
	  endif; 
	enddo;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if Q224(i) = 1 & di - udc(i) < yrsvacc*12 then
	    livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
        do j = i+1 while j <= totocc(QWSEC2B_ROSTER2)
          if Q224(j) = 1 then
            livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
          endif; 
        enddo;
		break;
	  endif; 
	enddo;
	indexpreg2 = i;
	pregvacc = livcdc;
	if livcmc > livcdc then pregvacc = livcmc; indexpreg = indexpreg2 endif;
  endif;  
  if !pregvacc then 
    endgroup
  endif;
  QESEC5 = pregvacc;
  do i = 1 while i <= max5
    if i <= pregvacc then
      QCOL51(i) = i;
    else
      QCOL51(i) = notappl;
    endif;
  enddo;

PROC Q502
  $ = ""; 
 
  if pregvacc & special(visualvalue(Q503(1))) then
    showpreg456("Children for vaccination module",indexpreg,1);
  endif;

PROC QWSEC05_ROSTER
{preproc
  showcard = 0;}

postproc
{  userbar( remove, ShowID );
  showcard = 0;}
  
PROC QCOL51
preproc
  if curocc() > pregvacc then
    endgroup
  endif;

PROC Q503
preproc
  numeric nextbirth = 0;
  do i = Q212W while i > 0 by (-1)
    if Q224(i) = 1 then
	  nextbirth = nextbirth + 1;
	  if nextbirth = QCOL51 then
	    $ = i;
		break;
	  endif;
    endif;	  
  enddo;

postproc
  Q503N = Q218($);
  if xmodcent & !showcard then
	ShowID = userbar( add button, tr("VaccCard"), ShowVaccCard() );
    showcard = 1;
  endif;
  
  if android then 
    setocclabel(QWSEC05_ROSTER(curocc()),maketext("%s %d/%d/%d",Q218($),Q220D($),Q220M($),Q220Y($)));
  endif;

PROC Q504
  if $ in 1,3 then
    skip to Q507
  endif;

PROC Q505
  if Q504 <> 2 then
    skip to Q513;
  endif;

PROC Q507
  recode Q504 :: Q507 -> err;
           1  ::  2,3 -> 1;
           2  ::  1,3 -> 1;
              ::      -> 0;
  endrecode;
  if err then
    errmsg( 4460, Q504, Q507 ) select( tr("Possession of card"), Q504, tr("Observation of card"), $ );
  endif;
  if !$ in 1:3 then
    skip to Q513
  endif;

PROC Q508D
  if $ = 95 then
    Q508M = 95;
    Q508Y = 9995;
    advance to D509B
  endif;

PROC Q508Y
  if Q508D = 95 & Q508M = 95 & Q508Y = 9995 then
    // No date of birth given on card - continue
  else
    if !DateOK( Q508D, Q508M, Q508Y, QINTD, QINTM, QINTY ) then
      errmsg( 2145 ) select( tr("Date of birth on card"), Q508_BLOCK );
    endif;
	{  error message removed on purpose as per e-mail from Trevor on 9/22/2021
    if Q220D(Q503) <> Q508D | Q220M(Q503) <> Q508M | Q220Y(Q503) <> Q508Y then
      warning( 4475, Q508D, Q508M, Q508Y, Q220D(Q503), Q220M(Q503), Q220Y(Q503) )
	    select( tr("Date of birth on card"), Q508_BLOCK,
                tr("Date of birth in pregnancy history"), Q220_BLOCK(Q503),
			    tr("Continue"), continue );
	endif;
	}
  endif;	
  
PROC D509B
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509B = $;
    Y509B = $*100+$;
    advance to D509H
  endif;

PROC Y509B
  vcheck  ( D509B, M509B, $ );
  vckbirth( D509B, M509B, $, Q503 );

PROC D509H
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509H = $;
    Y509H = $*100+$;
    advance to D509P0
  endif;

PROC Y509H
  vcheck  ( D509H, M509H, $ );
  vckbirth( D509H, M509H, $, Q503 );

PROC D509P0
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509P0 = $;
    Y509P0 = $*100+$;
    advance to D509P1
  endif;

PROC Y509P0
  vcheck  ( D509P0, M509P0, $ );
  vckbirth( D509P0, M509P0, $, Q503 );

PROC D509P1
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509P1 = $;
    Y509P1 = $*100+$;
    advance to D509P2
  endif;

PROC Y509P1
  vcheck  ( D509P1, M509P1, $ );
  vckbirth( D509P1, M509P1, $, Q503 );

PROC D509P2
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509P2 = $;
    Y509P2 = $*100+$;
    advance to D509P3
  endif;

PROC Y509P2
  vcheck  ( D509P2, M509P2, $ );
  vckbirth( D509P2, M509P2, $, Q503 );

PROC D509P3
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509P3 = $;
    Y509P3 = $*100+$;
    advance to D509P4
  endif;

PROC Y509P3
  vcheck  ( D509P3, M509P3, $ );
  vckbirth( D509P3, M509P3, $, Q503 );

PROC D509P4
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509P4 = $;
    Y509P4 = $*100+$;
    advance to D509D1
  endif;
PROC Y509P4
  vcheck  ( D509P4, M509P4, $ );
  vckbirth( D509P4, M509P4, $, Q503 );
PROC D509D1
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509D1 = $;
    Y509D1 = $*100+$;
    advance to D509D2
  endif;

PROC Y509D1
  vcheck  ( D509D1, M509D1, $ );
  vckbirth( D509D1, M509D1, $, Q503 );

PROC D509D2
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509D2 = $;
    Y509D2 = $*100+$;
    advance to D509D3
  endif;

PROC Y509D2
  vcheck  ( D509D2, M509D2, $ );
  vckbirth( D509D2, M509D2, $, Q503 );

PROC D509D3
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509D3 = $;
    Y509D3 = $*100+$;
    advance to D509R1
  endif;

PROC Y509D3
  vcheck  ( D509D3, M509D3, $ );
  vckbirth( D509D3, M509D3, $, Q503 );

PROC D509R1
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509R1 = $;
    Y509R1 = $*100+$;
    advance to D509R2
  endif;

PROC Y509R1
  vcheck  ( D509R1, M509R1, $ );
  vckbirth( D509R1, M509R1, $, Q503 );

PROC D509R2
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509R2 = $;
    Y509R2 = $*100+$;
    advance to D509IPV
  endif;

PROC Y509R2
  vcheck  ( D509R2, M509R2, $ );
  vckbirth( D509R2, M509R2, $, Q503 );

PROC D509IPV
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509IPV = $;
    Y509IPV = $*100+$;
    advance to D509IPV2
  endif;

PROC Y509IPV
  vcheck  ( D509IPV, M509IPV, $ );
  vckbirth( D509IPV, M509IPV, $, Q503 );

PROC D509IPV2
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509IPV2 = $;
    Y509IPV2 = $*100+$;
    advance to D509N1
  endif;
PROC Y509IPV2
  vcheck  ( D509IPV2, M509IPV2, $ );
  vckbirth( D509IPV2, M509IPV2, $, Q503 ); 
PROC D509N1
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509N1 = $;
    Y509N1 = $*100+$;
    advance to D509N2
  endif;

PROC Y509N1
  vcheck  ( D509N1, M509N1, $ );
  vckbirth( D509N1, M509N1, $, Q503 );

PROC D509N2
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509N2 = $;
    Y509N2 = $*100+$;
    advance to D509N3
  endif;

PROC Y509N2
  vcheck  ( D509N2, M509N2, $ );
  vckbirth( D509N2, M509N2, $, Q503 );

PROC D509N3
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509N3 = $;
    Y509N3 = $*100+$;
    advance to D509M1
  endif;

PROC Y509N3
  vcheck  ( D509N3, M509N3, $ );
  vckbirth( D509N3, M509N3, $, Q503 );

PROC D509M1
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509M1 = $;
    Y509M1 = $*100+$;
    advance to D509D4
  endif;

PROC Y509M1
  vcheck  ( D509M1, M509M1, $ );
  vckbirth( D509M1, M509M1, $, Q503 );

PROC D509D4
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509D4 = $;
    Y509D4 = $*100+$;
    advance to D509V
  endif;

PROC Y509D4
  vcheck  ( D509D4, M509D4, $ );
  vckbirth( D509D4, M509D4, $, Q503 );

PROC D509V
onfocus
  if visualvalue(Q512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509V = $;
    Y509V = $*100+$;
    advance to Q510
  endif;

PROC Y509V
  vcheck  ( D509V, M509V, $ );
  vckbirth( D509V, M509V, $, Q503 );

PROC Q510
preproc
  if demode() = add then
    showvaccs(curocc());
  endif;

postproc
  if demode() = add & $ = 1 then
    if android then
      TakePictureA( Q503 )
    else	  
      TakePictureW( Q503 )
    endif;	  
  elseif $ = 6 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;  

PROC Q512
{Modified for TJ23}
preproc
  { if all vaccinations given skip Q512 }
  { !! don't include Vitamin A but include other country specific }
  if vacgiven(D509B ) & vacgiven(D509H ) & vacgiven(D509P0) &
     vacgiven(D509P1) & vacgiven(D509P2) & vacgiven(D509P3) & vacgiven(D509P4) &
	 vacgiven(D509IPV) & vacgiven(D509IPV2) &
     vacgiven(D509D1) & vacgiven(D509D2) & vacgiven(D509D3) & vacgiven(D509D4) &
     vacgiven(D509N1) & vacgiven(D509N2) & vacgiven(D509N3) &
     vacgiven(D509R1) & vacgiven(D509R2) {& vacgiven(ZZZD509R3)} &
     vacgiven(D509M1) {& vacgiven(ZZZD509M2)} then
    skip to Q529;
  endif;

postproc
  { if any vaccinations given, including Vitamin A skip Q529, otherwise Q530 }
  if $ <> 1 then
    if vacgiven(D509B ) | vacgiven(D509H ) | vacgiven(D509P0) |
       vacgiven(D509P1) | vacgiven(D509P2) | vacgiven(D509P3) | vacgiven(D509P4) |
	   vacgiven(D509IPV) | vacgiven(D509IPV2) |
       vacgiven(D509D1) | vacgiven(D509D2) | vacgiven(D509D3) | vacgiven(D509D4) |
       vacgiven(D509N1) | vacgiven(D509N2) | vacgiven(D509N3) |
       vacgiven(D509R1) | vacgiven(D509R2) {| vacgiven(ZZZD509R3) } |
       vacgiven(D509M1) {| vacgiven(ZZZD509M2)} | vacgiven(D509V) then
      skip to Q529;
    else
      skip to next QCOL51;
    endif;
  endif;

PROC Q512W
onfocus
  vaccinations.clear();
  if D509B in 0,66 then
    vaccinations.add(GetLabel(Q509B), "A" );     // BCG
  endif;
  if D509H in 0,66 then
    vaccinations.add(GetLabel(Q509H), "B" );     // Hepatitis B
  endif;
  if D509P0 in 0,66 then
    vaccinations.add(GetLabel(Q509P0), "C" );    // Polio 0
  endif;
  if D509P1 in 0,66 then
    vaccinations.add(GetLabel(Q509P1), "D" );    // Polio 1
  endif;
  if D509P2 in 0,66 then
    vaccinations.add(GetLabel(Q509P2), "E" );    // Polio 2
  endif;
  if D509P3 in 0,66 then
    vaccinations.add(GetLabel(Q509P3), "F" );    // Polio 3
  endif;
  if D509P4 in 0,66 then
    vaccinations.add(GetLabel(Q509P4), "G" );    // Polio 4
  endif;
  if D509D1 in 0,66 then
    vaccinations.add(GetLabel(Q509D1), "H" );    // DPT 1
  endif;
  if D509D2 in 0,66 then
    vaccinations.add(GetLabel(Q509D2), "I" );    // DPT 2
  endif;
  if D509D3 in 0,66 then
    vaccinations.add(GetLabel(Q509D3), "J" );    // DPT 3
  endif;
  if D509N1 in 0,66 then
    vaccinations.add(GetLabel(Q509N1), "K" );    // Pneumococcal 1
  endif;
  if D509N2 in 0,66 then
    vaccinations.add(GetLabel(Q509N2), "L" );    // Pneumococcal 2    
  endif;
  if D509N3 in 0,66 then
    vaccinations.add(GetLabel(Q509N3), "M" );    // Pneumococcal 3
  endif;
  if D509R1 in 0,66 then
    vaccinations.add(GetLabel(Q509R1), "N" );    // Rotavirus 1
  endif;
  if D509R2 in 0,66 then
    vaccinations.add(GetLabel(Q509R2), "O" );    // Rotavirus 2
  endif;
  if D509IPV in 0,66 then
    vaccinations.add(GetLabel(Q509IPV), "P" );    // Polio IPV 1
  endif;
  if D509IPV2 in 0,66 then
    vaccinations.add(GetLabel(Q509IPV2), "Q" );    // Polio IPV 2
  endif; 
{  if ZZZD509R3 in 0,66 then
    vaccinations.add(GetLabel(ZZZQ509R3), "Q" );    // Rotavirus 3
  endif;}
  if D509M1 in 0,66 then
    vaccinations.add(GetLabel(Q509M1), "R" );    // Measles 1
  endif;
  if D509D4 in 0,66 then
    vaccinations.add(GetLabel(Q509D4), "S" );    // DPT 4
  endif;  						
 { if ZZZD509M2 in 0,66 then
    vaccinations.add(GetLabel(ZZZQ509M2), "S" );    // Measles 2
  endif;}
  SetValueSet( $, VACCINATIONS );
  
postproc
  if !length(strip($)) then
    reenter 
  endif;	
  { set vaccination date to 66 if not given, but mother delcared that was given }
  if pos("A",$) then D509B   = 66; M509B   = D509B ;  Y509B   = D509B *101  endif;       // BCG
  if pos("B",$) then D509H   = 66; M509H   = D509H ;  Y509H   = D509H *101  endif;       // Hepatitis B
  if pos("C",$) then D509P0  = 66; M509P0  = D509P0;  Y509P0  = D509P0*101  endif;       // Polio 0
  if pos("D",$) then D509P1  = 66; M509P1  = D509P1;  Y509P1  = D509P1*101  endif;       // Polio 1
  if pos("E",$) then D509P2  = 66; M509P2  = D509P2;  Y509P2  = D509P2*101  endif;       // Polio 2
  if pos("F",$) then D509P3  = 66; M509P3  = D509P3;  Y509P3  = D509P3*101  endif;       // Polio 3
  if pos("G",$) then D509P4  = 66; M509P4  = D509P4;  Y509P4  = D509P4*101  endif;       // Polio 4  
  if pos("H",$) then D509D1  = 66; M509D1  = D509D1;  Y509D1  = D509D1*101  endif;       // DPT 1
  if pos("I",$) then D509D2  = 66; M509D2  = D509D2;  Y509D2  = D509D2*101  endif;       // DPT 2
  if pos("J",$) then D509D3  = 66; M509D3  = D509D3;  Y509D3  = D509D3*101  endif;       // DPT 3
  if pos("K",$) then D509R1  = 66; M509R1  = D509R1;  Y509R1  = D509R1*101  endif;       // Rotavirus 1
  if pos("L",$) then D509R2  = 66; M509R2  = D509R2;  Y509R2  = D509R2*101  endif;       // Rotavirus 2
  if pos("M",$) then D509IPV = 66; M509IPV = D509IPV; Y509IPV = D509IPV*101 endif;       // Polio IPV 1
  if pos("N",$) then D509IPV2 = 66; M509IPV2 = D509IPV2; Y509IPV2 = D509IPV2*101 endif;       // Polio IPV 2
  if pos("O",$) then D509N1  = 66; M509N1  = D509N1;  Y509N1  = D509N1*101  endif;       // Pneumococcal 1
  if pos("P",$) then D509N2  = 66; M509N2  = D509N2;  Y509N2  = D509N2*101  endif;       // Pneumococcal 2 
  if pos("Q",$) then D509N3  = 66; M509N3  = D509N3;  Y509N3  = D509N3*101  endif;       // Pneumococcal 3
  {if pos("Q",$) then ZZZD509R3  = 66; ZZZM509R3  = ZZZD509R3;  ZZZY509R3  = ZZZD509R3*101  endif;       // Rotavirus 3}
  if pos("R",$) then D509M1  = 66; M509M1  = D509M1;  Y509M1  = D509M1*101  endif;       // Measles 1
  {if pos("S",$) then ZZZD509M2  = 66; ZZZM509M2  = ZZZD509M2;  ZZZY509M2  = ZZZD509M2*101  endif;       // Measles 2 }
  if pos("S",$) then D509D4  = 66; M509D4  = D509D4;  Y509D4  = D509D4*101  endif;       // DPT 4
  skip Q529;

PROC Q513
  if $ <> 1 then
    skip to next FA01
  endif;

PROC Q515
  if $ <> 1 then
    skip to Q517
  endif;

PROC Q517
  if $ <> 1 then
    skip to Q520
  endif;

PROC Q520
  if $ <> 1 then
    skip to Q521
  endif;
PROC Q521
  if $ <> 1 then
    skip to Q522A
  endif;

PROC Q523
  if $ <> 1 then
    skip to Q525
  endif;

PROC Q525
  if $ <> 1 then
    skip to Q527
  endif;

PROC Q527
  {if $ <> 1 then
    skip to Q529
  endif;} {Changed in TJ23}

PROC Q529
  majorgrp( $ );
  { Get other answer }
  if $ in 26,37,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC FA01
  if $ <> 1 then
    skip to next QCOL51;
  endif;
PROC QWSEC6A_FORM
preproc
  SaveData();
  numeric fullcdc, livcdc, livcmc;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  preghlth = 0;
  fullcdc = count(QWSEC2B where Q220CD <> 0);
  if Q212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if Q224(i) = 1 & int((dicdc - Q220CD(i))/DaysMonth) < yrshlth*12 then
	    preghlth = preghlth + 1;
        do j = i+1 while j <= totocc(QWSEC2B_ROSTER2)
          if Q224(j) = 1 then
	        preghlth = preghlth + 1;
		  endif;
		enddo;
		break;
	  endif;
	enddo;
	indexpreg = i;
  else
    { count pregnancies based on CDC codes } 
	livcdc = 0;
	do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if Q224(i) = 1 & int((dicdc - Q220CD(i))/DaysMonth) < yrshlth*12 then
	    livcdc = livcdc + 1;               // assume remaining pregnancies occurred after this one
        do j  = i+1 while j <= totocc(QWSEC2B_ROSTER2)
          if Q224(j) = 1 then
	        livcdc = livcdc + 1;
		  endif;
		enddo;
		break;
	  endif; 
	enddo;
	indexpreg = i;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = 1 while i <= totocc(QWSEC2B_ROSTER2)
      if Q224(i) = 1 & di - udc(i) < yrshlth*12 then
	    livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
        do j = i+1 while j <= totocc(QWSEC2B_ROSTER2)
          if Q224(j) = 1 then
            livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
          endif; 
        enddo;
		break;
	  endif; 
	enddo;
	indexpreg2 = i;
	preghlth = livcdc;
	if livcmc > livcdc then preghlth = livcmc; indexpreg = indexpreg2 endif;
  endif;  
  if !preghlth then 
    endgroup
  endif;
  QESEC6 = preghlth;
  do i = 1 while i <= max5
    if i <= preghlth then
      QCOL61(i) = i;
    else
      QCOL61(i) = notappl;
    endif;
  enddo;

PROC Q602
  $ = "";

  if preghlth & special(visualvalue(Q603(1))) then
    showpreg456(tr("Children for child health module"),indexpreg,1);
  endif;

PROC QCOL61
preproc
  SaveData();
  if curocc() > preghlth then        { to run in-Batch }
    endgroup
  endif;

PROC Q603
preproc
  numeric nextbirth = 0;
  do i = Q212W while i > 0 by (-1)
    if Q224(i) = 1 then
	  nextbirth = nextbirth + 1;
	  if nextbirth = QCOL61 then
	    $ = i;
		break;
	  endif;
    endif;	  
  enddo;

postproc
  Q603N  = Q218($);

  if android then 
    setocclabel(QWSEC6A_ROSTER(curocc()),maketext("%s %d/%d/%d",Q218($),Q220D($),Q220M($),Q220Y($)));
  endif;

PROC Q608
  if $ <> 1 then
    skip to Q618
  endif;	

PROC Q609
onfocus
  breastfed = 0;
//  do i = 1 while i <= totocc(QWSEC04_ROSTER)
//    if Q404(i) = Q603 then
//      breastfed = ( Q485(i) = 1 );
//	endif;
//  enddo;	
  i = seek(Q404 = Q603);
  if i then
    breastfed = ( Q485(i) = 1 );
  endif;

PROC Q611
  if $ <> 1 then
    skip to Q615A;
  endif;

PROC Q612
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answers }
  {if pos( "F", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;}
  if pos( "M", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
{  if pos( "P", $ ) then
    getother( GetSymbol(), 10*curocc()+3 );
    enter FL_OTHERS
  endif;}
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+4 );
    enter FL_OTHERS
  endif;

PROC Q614
preproc
  { skip question if only one response in previous question }
  if length( strip(Q612) ) = 1 then
    skip to Q615A;
  endif;

onfocus
  sources.clear();
  do i = 1 while i <= length( strip(Q612) )
    sources.add( getlabel(Q612, Q612[i:1]), Q612[i:1] );
  enddo;
  SetValueSet( $, sources );

postproc
  if !pos( $, strip(Q612) ) then
    errmsg( 4485 ) select( tr("Any treatment"), Q612, tr("First treatment"), $ );
  endif;

PROC Q616
onfocus
  treatment = ( Q615A = 1 {| ZZZQ615B = 1} | Q615C = 1 | Q615D = 1 );

postproc
  if $ <> 1 then
    skip to Q618
  endif;

PROC Q617
onfocus
  treatment = ( Q615A = 1 {| ZZZQ615B = 1} | Q615C = 1 | Q615D = 1 );

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q618
  if $ <> 1 then
    skip to Q621;
  endif;

PROC Q622
  if $ <> 1 then
    skip to Q625
  endif;

PROC Q623
  { Get other answer }
  if $ = 6 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC Q625
preproc
  if Q618 <> 1 & Q622 <> 1 then
    skip to next QCOL61
  endif;

postproc
  if $ <> 1 then
    skip to Q630
  endif;

PROC Q626
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answers }
  {if pos( "F", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;}
  if pos( "M", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
  if pos( "T", $ ) then
    getother( GetSymbol(), 10*curocc()+3 );
    enter FL_OTHERS
  endif;
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+4 );
    enter FL_OTHERS
  endif;

PROC Q628
preproc
  { skip question if only one response in previous question }
  if length( strip(Q626) ) = 1 then
    skip to Q629;
  endif;

onfocus
  sources.clear();
  do i = 1 while i <= length( strip(Q626) )
    sources.add( getlabel(Q626, Q626[i:1]), Q626[i:1] );
  enddo;
  SetValueSet( $, sources );

postproc
  if !pos( $, Q626 ) then
    errmsg( 4485 ) select( tr("Any treatment"), Q626, tr("First treatment"), $ );
  endif;

PROC Q630
  if $ <> 1 then
    skip to next QCOL61
  endif;

PROC Q631
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Check "DK" is only response }
  {if pos( "Z", $ ) & length(strip($)) > 1 then
    errmsg( 9996 ) select( tr("Fix answers marked"), $ );
  endif;
  { Get other answers }
  if pos( "I", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;}
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
  {{ if no antimalarial drug given skip to next child }
  if !pos("A", $) then
    skip to next QCOL61
  endif;}
  
PROC QWSEC6B_FORM
preproc
  SaveData();
  numeric fullcdc, livcdc, livcmc;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  pregfeed = 0;
  fullcdc = count(QWSEC2B where Q220CD <> 0);
  if Q212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    do i = Q212W while i > 0 by (-1)
      if Q224(i) = 1 & Q226(i) = 1 & int((dicdc - Q220CD(i))/DaysMonth) < yrsfeed*12 then
	    pregfeed = i;
		break;
	  endif;
	enddo;
  else
    { count pregnancies based on CDC codes } 
	livcdc = 0;
	do i = Q212W while i > 0 by (-1)
      if Q224(i) = 1 & Q226(i) = 1 & int((dicdc - Q220CD(i))/DaysMonth) < yrsfeed*12 then
	    livcdc = i;               // assume remaining pregnancies occurred after this one
		break;
	  endif; 
	enddo;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = Q212W while i > 0 by (-1)
      if Q224(i) = 1 & Q226(i) = 1 & di - udc(i) < yrsfeed*12 then
	    livcmc = i;               // assume remaining pregnancies occurred after this one
        break;
	  endif; 
	enddo;
	pregfeed = livcdc;
	if livcmc > livcdc then pregfeed = livcmc endif;
  endif;  
  if !pregfeed then 
    skip to Q643_FIX
  endif;
  Q635  = pregfeed;
  Q635N = Q218(pregfeed);
  
onfocus
  if !foodsid then
    foodsid = userbar(add button, tr("Foods and drinks"), FoodDrinks());
  endif;
  
killfocus
  if foodsid then
    userbar(remove,foodsid);
	foodsid = 0;
  endif;

PROC Q636_INTRO
onfocus
  if drinks_popup then	// move forward to the last field if had come back due to pop-up for drinks
    drinks_popup = 0;
	advance to foodfield;
  endif;

postproc
  $ = "";

PROC Q636BN
preproc
  ask if Q636B = 1;

PROC Q636CN
preproc
  ask if Q636C = 1;

PROC Q636CA
preproc
  ask if Q636C = 1;

PROC Q636IA
preproc
  ask if Q636I = 1;

PROC Q636K
preproc
  if other_drinks then
    noinput;	// value already entered, just need to advance
  endif;

postproc
  if $ = 1 & !xmodify then
    if other_drinks then
	  other_drinks = 0;
	else
	  other_drinks = 1;
      drinkgroups();
	endif;
  endif;

PROC Q636KA
preproc
  ask if Q636K = 1 & pos("Z",Q636Z);

PROC Q636Z
onfocus
  protect($, true);
  foods.clear(); $ = "";
  foods.add(replace( GetLabel(Q636A), tr("Child drank: "), "" ), "A" ); if visualvalue(Q636A) = 1 then $ = strip($)+"A" endif;
  foods.add(replace( GetLabel(Q636B), tr("Child drank: "), "" ), "B" ); if visualvalue(Q636B) = 1 then $ = strip($)+"B" endif;
  foods.add(replace( GetLabel(Q636C), tr("Child drank: "), "" ), "C" ); if visualvalue(Q636C) = 1 then $ = strip($)+"C" endif;
  //foods.add(replace( GetLabel(Q636E), tr("Child drank: "), "" ), "E" ); if visualvalue(Q636E) = 1 then $ = strip($)+"E" endif;
  foods.add(replace( GetLabel(Q636F), tr("Child drank: "), "" ), "F" ); if visualvalue(Q636F) = 1 then $ = strip($)+"F" endif;
  foods.add(replace( GetLabel(Q636G), tr("Child drank: "), "" ), "G" ); if visualvalue(Q636G) = 1 then $ = strip($)+"G" endif;
  foods.add(replace( GetLabel(Q636H), tr("Child drank: "), "" ), "H" ); if visualvalue(Q636H) = 1 then $ = strip($)+"H" endif;
  foods.add(replace( GetLabel(Q636I), tr("Child drank: "), "" ), "I" ); if visualvalue(Q636I) = 1 then $ = strip($)+"I" endif;
  foods.add(replace( GetLabel(Q636J), tr("Child drank: "), "" ), "J" ); if visualvalue(Q636J) = 1 then $ = strip($)+"J" endif;
  //foods.add(replace( GetLabel(Q636K), tr("Child drank: "), "" ), "K" );  if visualvalue(Q636K) = 1 then $ = strip($)+"K" endif; // don't include Other drinks
  foods.add(tr("Drinks not included in the options above"), "Z" );      if visualvalue(Q636KZ) = 1 then $ = strip($)+"Z" endif;
  if drinks_popup then
    SetValueSet( $, foods );
    protect($, false);
  endif;

postproc
  Q636KZ = 0;
  if pos("Z", $) then
    Q636KZ = 1;
	if drinks_popup then
      getother( GetSymbol(), 0 );
      enter FL_OTHERS
    endif;	  
  endif;
  
  if pos("A", $) then Q636A = 1 endif;
  if pos("B", $) then Q636B = 1 endif;
  if pos("C", $) then Q636C = 1 endif;
  //if pos("E", $) then Q636E = 1 endif;
  if pos("F", $) then Q636F = 1 endif;
  if pos("G", $) then Q636G = 1 endif;
  if pos("H", $) then Q636H = 1 endif;
  if pos("I", $) then Q636I = 1 endif;
  if pos("J", $) then Q636J = 1 endif;
  //if pos("K", $) then Q636K = 1 endif;
  
  if drinks_popup then		// go back to intro and then move forward to the last field 
	move to Q636_INTRO;
  endif;

PROC Q637_INTRO
preproc
  SaveData();

onfocus
  if foods_popup then	// move forward to the last field if had come back due to pop-up for foods
    foods_popup = 0;
	advance to foodfield;
  endif;

postproc
  $ = "";

PROC Q637AN
preproc
  ask if Q637A = 1;

PROC Q637AY
preproc
  ask if Q637A = 1;

PROC Q637AYA
preproc
  ask if Q637AY = 1;

PROC Q637V
preproc
  if other_foods then
    noinput;	// value already entered, just need to advance - see toggle below
  endif;

postproc
  if $ = 1 & !xmodify then
    if other_foods then		// toggle off or on the capture of the food groups in Q637Z
	  other_foods = 0;
	else
	  other_foods = 1;
      foodgroups();
	endif;  
  endif;
  
PROC Q637Z
onfocus
  protect($, true);
  foods.clear(); $ = "";
  foods.add(replace( GetLabel(Q637A), "Child ate ", "" ), "A" ); if visualvalue(Q637A) = 1 then $ = strip($)+"A" endif;
  foods.add(replace( GetLabel(Q637B), "Child ate ", "" ), "B" ); if visualvalue(Q637B) = 1 then $ = strip($)+"B" endif;
  foods.add(replace( GetLabel(Q637C), "Child ate ", "" ), "C" ); if visualvalue(Q637C) = 1 then $ = strip($)+"C" endif;
  foods.add(replace( GetLabel(Q637D), "Child ate ", "" ), "D" ); if visualvalue(Q637D) = 1 then $ = strip($)+"D" endif;
  foods.add(replace( GetLabel(Q637E), "Child ate ", "" ), "E" ); if visualvalue(Q637E) = 1 then $ = strip($)+"E" endif;
  foods.add(replace( GetLabel(Q637F), "Child ate ", "" ), "F" ); if visualvalue(Q637F) = 1 then $ = strip($)+"F" endif;
  foods.add(replace( GetLabel(Q637G), "Child ate ", "" ), "G" ); if visualvalue(Q637G) = 1 then $ = strip($)+"G" endif;
  foods.add(replace( GetLabel(Q637H), "Child ate ", "" ), "H" ); if visualvalue(Q637H) = 1 then $ = strip($)+"H" endif;
  foods.add(replace( GetLabel(Q637I), "Child ate ", "" ), "I" ); if visualvalue(Q637I) = 1 then $ = strip($)+"I" endif;
  foods.add(replace( GetLabel(Q637J), "Child ate ", "" ), "J" ); if visualvalue(Q637J) = 1 then $ = strip($)+"J" endif;
  foods.add(replace( GetLabel(Q637K), "Child ate ", "" ), "K" ); if visualvalue(Q637K) = 1 then $ = strip($)+"K" endif;
  foods.add(replace( GetLabel(Q637L), "Child ate ", "" ), "L" ); if visualvalue(Q637L) = 1 then $ = strip($)+"L" endif;
  foods.add(replace( GetLabel(Q637M), "Child ate ", "" ), "M" ); if visualvalue(Q637M) = 1 then $ = strip($)+"M" endif;
  foods.add(replace( GetLabel(Q637N), "Child ate ", "" ), "N" ); if visualvalue(Q637N) = 1 then $ = strip($)+"N" endif;
  foods.add(replace( GetLabel(Q637O), "Child ate ", "" ), "O" ); if visualvalue(Q637O) = 1 then $ = strip($)+"O" endif;
  foods.add(replace( GetLabel(Q637P), "Child ate ", "" ), "P" ); if visualvalue(Q637P) = 1 then $ = strip($)+"P" endif;
  {foods.add(replace( GetLabel(Q637Q), "Child ate ", "" ), "Q" ); if visualvalue(Q637Q) = 1 then $ = strip($)+"Q" endif;}
  foods.add(replace( GetLabel(Q637R), "Child ate ", "" ), "R" ); if visualvalue(Q637R) = 1 then $ = strip($)+"R" endif;
  foods.add(replace( GetLabel(Q637S), "Child ate ", "" ), "S" ); if visualvalue(Q637S) = 1 then $ = strip($)+"S" endif;
  foods.add(replace( GetLabel(Q637T), "Child ate ", "" ), "T" ); if visualvalue(Q637T) = 1 then $ = strip($)+"T" endif;
  {foods.add(replace( GetLabel(ZZZQ637U), "Child ate ", "" ), "U" ); if visualvalue(ZZZQ637U) = 1 then $ = strip($)+"U" endif; // don't include Other foods}
  foods.add(tr("Foods not included in the options above"), "Z" );
  if foods_popup then
    SetValueSet( $, foods );
    protect($, false);
  endif;

postproc
  if pos("Z", $) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
  if pos("A", $) then Q637A = 1 endif;
  if pos("B", $) then Q637B = 1 endif;
  if pos("C", $) then Q637C = 1 endif;
  if pos("D", $) then Q637D = 1 endif;
  if pos("E", $) then Q637E = 1 endif;
  if pos("F", $) then Q637F = 1 endif;
  if pos("G", $) then Q637G = 1 endif;
  if pos("H", $) then Q637H = 1 endif;
  if pos("I", $) then Q637I = 1 endif;
  if pos("J", $) then Q637J = 1 endif;
  if pos("K", $) then Q637K = 1 endif;
  if pos("L", $) then Q637L = 1 endif;
  if pos("M", $) then Q637M = 1 endif;
  if pos("N", $) then Q637N = 1 endif;
  if pos("O", $) then Q637O = 1 endif;
  if pos("P", $) then Q637P = 1 endif;
  {if pos("Q", $) then Q637Q = 1 endif;}
  if pos("R", $) then Q637R = 1 endif;
  if pos("S", $) then Q637S = 1 endif;
  if pos("T", $) then Q637T = 1 endif;
  {if pos("U", $) then ZZZQ637U = 1 endif;}
  
  if foods_popup then	// go back to intro and then move forward to the last field 
	if foodfield <> "Q639" then
	  move to Q637_INTRO;
	else				// or if from Q639, just go forward to Q639
      advance to Q639;
	endif;
  endif;

PROC Q639
preproc
  SaveData();
  { skip if any food given }
  if (Q637A = 1 | Q637B = 1 | Q637C = 1 | Q637D = 1 | Q637E = 1 | Q637F = 1 |
      Q637G = 1 | Q637H = 1 | Q637I = 1 | Q637J = 1 | Q637K = 1 | Q637L = 1 | 
	  Q637M = 1 | Q637N = 1 | Q637O = 1 | Q637P = 1 {| Q637Q = 1} | Q637R = 1 |
	  Q637S = 1 | Q637T = 1 {| ZZZQ637U = 1} | Q637V = 1 ) then
    // we don't want to skip this if it was asked once - we want to keep the original response here.
	if special(visualvalue($)) then
      skip to Q640
	endif;
  endif;

  if other_foods then
    noinput		// value already entered, just need to advance - see toggle below
  endif;

postproc
  if $ = 1 & !xmodify then
    if other_foods then		// toggle off or on the capture of the food groups in Q637Z
	  other_foods = 0
	else
	  other_foods = 1;
      foodgroups();
	endif;
  endif;
  
PROC Q640
preproc
  ask if ( Q637A = 1 | Q637B = 1 | Q637C = 1 | Q637D = 1 | Q637E = 1 | Q637F = 1 |
           Q637G = 1 | Q637H = 1 | Q637I = 1 | Q637J = 1 | Q637K = 1 | Q637L = 1 | 
	       Q637M = 1 | Q637N = 1 | Q637O = 1 | Q637P = 1 {| Q637Q = 1} | Q637R = 1 | 
	       Q637S = 1 | Q637T = 1 {| ZZZQ637U = 1 }| Q639 = 1 );

PROC Q642
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q643_FIX
preproc
// this field is included to avoid a bug related to the pop-up
  $ = 0;

postproc
  if foods_popupW then  // move forward to the last field if had come back due to pop-up for foods
    foods_popupW = 0;
    advance to foodfield;
  endif;
  
PROC Q643_INTRO
preproc
  SaveData();

postproc
  $ = "";

PROC Q643X
  if $ = 1 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q643XA
preproc
  ask if Q643X = 1;

PROC Q643Y
preproc
  if other_foodsW then
    noinput;	// value already entered, just need to advance - see toggle below
  endif;

postproc
  if $ = 1 & !xmodify then
    if other_foodsW then	// toggle off or on the capture of the food groups in Q643Z
	  other_foodsW = 0
	else
	  other_foodsW = 1;
      foodgroupsW();
	endif;
  endif;	

PROC Q643Z
onfocus
  protect($, true);
  foods.clear(); $ = "";
  foods.add(replace( GetLabel(Q643A), "Respondent ate: ", ""), "A" ); if visualvalue(Q643A) = 1 then $ = strip($)+"A" endif;
  foods.add(replace( GetLabel(Q643B), "Respondent ate: ", ""), "B" ); if visualvalue(Q643B) = 1 then $ = strip($)+"B" endif;
  foods.add(replace( GetLabel(Q643C), "Respondent ate: ", ""), "C" ); if visualvalue(Q643C) = 1 then $ = strip($)+"C" endif;
  foods.add(replace( GetLabel(Q643D), "Respondent ate: ", ""), "D" ); if visualvalue(Q643D) = 1 then $ = strip($)+"D" endif;
  foods.add(replace( GetLabel(Q643E), "Respondent ate: ", ""), "E" ); if visualvalue(Q643E) = 1 then $ = strip($)+"E" endif;
  foods.add(replace( GetLabel(Q643F), "Respondent ate: ", ""), "F" ); if visualvalue(Q643F) = 1 then $ = strip($)+"F" endif;
  foods.add(replace( GetLabel(Q643G), "Respondent ate: ", ""), "G" ); if visualvalue(Q643G) = 1 then $ = strip($)+"G" endif;
  foods.add(replace( GetLabel(Q643H), "Respondent ate: ", ""), "H" ); if visualvalue(Q643H) = 1 then $ = strip($)+"H" endif;
  foods.add(replace( GetLabel(Q643I), "Respondent ate: ", ""), "I" ); if visualvalue(Q643I) = 1 then $ = strip($)+"I" endif;
  foods.add(replace( GetLabel(Q643J), "Respondent ate: ", ""), "J" ); if visualvalue(Q643J) = 1 then $ = strip($)+"J" endif;
  foods.add(replace( GetLabel(Q643K), "Respondent ate: ", ""), "K" ); if visualvalue(Q643K) = 1 then $ = strip($)+"K" endif;
  foods.add(replace( GetLabel(Q643L), "Respondent ate: ", ""), "L" ); if visualvalue(Q643L) = 1 then $ = strip($)+"L" endif;
  foods.add(replace( GetLabel(Q643M), "Respondent ate: ", ""), "M" ); if visualvalue(Q643M) = 1 then $ = strip($)+"M" endif;
  foods.add(replace( GetLabel(Q643N), "Respondent ate: ", ""), "N" ); if visualvalue(Q643N) = 1 then $ = strip($)+"N" endif;
  foods.add(replace( GetLabel(Q643O), "Respondent ate: ", ""), "O" ); if visualvalue(Q643O) = 1 then $ = strip($)+"O" endif;
{  foods.add(replace( GetLabel(Q643P), "Respondent ate: ", ""), "P" ); if visualvalue(Q643P) = 1 then $ = strip($)+"P" endif;}
  foods.add(replace( GetLabel(Q643Q), "Respondent ate: ", ""), "Q" ); if visualvalue(Q643Q) = 1 then $ = strip($)+"Q" endif;
  foods.add(replace( GetLabel(Q643R), "Respondent ate: ", ""), "R" ); if visualvalue(Q643R) = 1 then $ = strip($)+"R" endif;
  foods.add(replace( GetLabel(Q643S), "Respondent ate: ", ""), "S" ); if visualvalue(Q643S) = 1 then $ = strip($)+"S" endif;
  foods.add(replace( GetLabel(Q643T), "Respondent ate: ", ""), "T" ); if visualvalue(Q643T) = 1 then $ = strip($)+"T" endif;
  foods.add(replace( GetLabel(Q643U), "Respondent ate: ", ""), "U" ); if visualvalue(Q643U) = 1 then $ = strip($)+"U" endif;
  foods.add(replace( GetLabel(Q643V), "Respondent ate: ", ""), "V" ); if visualvalue(Q643V) = 1 then $ = strip($)+"V" endif;
{  foods.add(replace( GetLabel(ZZZQ643W), "Respondent ate: ", ""), "W" ); if visualvalue(ZZZQ643W) = 1 then $ = strip($)+"W" endif;}
  foods.add(replace( GetLabel(Q643X), "Respondent ate: ", ""), "X" ); if visualvalue(Q643X) = 1 then $ = strip($)+"X" endif; // don't include Other foods
  foods.add(tr("Foods not included in the options above"), "Z" );
  if foods_popupW then
    SetValueSet( $, foods );
    protect($, false);
  endif;

postproc
  if pos("Z", $) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
  if pos("A", $) then Q643A = 1 endif;
  if pos("B", $) then Q643B = 1 endif;
  if pos("C", $) then Q643C = 1 endif;
  if pos("D", $) then Q643D = 1 endif;
  if pos("E", $) then Q643E = 1 endif;
  if pos("F", $) then Q643F = 1 endif;
  if pos("G", $) then Q643G = 1 endif;
  if pos("H", $) then Q643H = 1 endif;
  if pos("I", $) then Q643I = 1 endif;
  if pos("J", $) then Q643J = 1 endif;
  if pos("K", $) then Q643K = 1 endif;
  if pos("L", $) then Q643L = 1 endif;
  if pos("M", $) then Q643M = 1 endif;
  if pos("N", $) then Q643N = 1 endif;
  if pos("O", $) then Q643O = 1 endif;
 { if pos("P", $) then Q643P = 1 endif;}
  if pos("Q", $) then Q643Q = 1 endif;
  if pos("R", $) then Q643R = 1 endif;
  if pos("S", $) then Q643S = 1 endif;
  if pos("T", $) then Q643T = 1 endif;
  if pos("U", $) then Q643U = 1 endif;
  if pos("V", $) then Q643V = 1 endif;
 { if pos("W", $) then ZZZQ643W = 1 endif;}
  if pos("X", $) then Q643X = 1 endif;
  
  if foods_popupW then		// go back to intro and then move forward to the last field
	move to Q643_FIX;
  endif;
  
PROC Q701
preproc
  SaveData();

postproc
  relterms();  
  
  inunion = ( $ in 1,2 );
  if inunion then
    skip to Q706A
  endif;

PROC Q702
  if $ = 3 then
    skip to Q722
  endif;

PROC Q703
  skip to Q714

PROC Q706A
  if $ <> 1 then
    skip to Q707
  endif;	

PROC Q706B
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
  skip to Q709;
PROC Q710
onfocus
  individuals.clear();
  do i = 1 while i <= QHMEMBER
    if QH04(i) = 1 & QH07(i) in 10:98,missing then
      individuals.add(QH02(i), i);
    endif;
  enddo;
  individuals.add( tr("Not a household member"), 0 );
  SetValueSet( $, individuals );

postproc
  { Check if line number is out of range }
  if $ > QHMEMBER | $ = QLINE then
    errmsg( 5060 ) select( tr("Line number of husband/partner"), $ );
  elseif $ <> 0 then
    { Check partner is male }
    if QH04($) <> 1 then
      errmsg( 5061, QH04($) ) select( tr("Line number of husband/partner"), $ );
    { Check partner is at least age 15 }
    elseif QH07($) in 0:14 then
      warning( 5062, QH07($), $, 15 ) 
	    select( tr("Line number of husband/partner"), $, tr("Continue"), continue );
    endif;
    { Check relationship of respondent to partner }
    x = QH03(QLINE);
    y = QH03($);
    recode x :: y                 -> err;    { WIFE                  - HUSBAND             }
           1 :: 2                 -> 0;      { Head                  - Spouse              }
           2 :: 1                 -> 0;      { Spouse                - Head                }
           3 :: 4                 -> 0;      { Son/Daughter          - Son/Daughter in-law }
           4 :: 3                 -> 0;      { Son/Daughter in-law   - Son/Daughter        }
           5 :: 9                 -> 0;      { grandchild            - Other relative      }
           6 :: 6                 -> 0;      { Parent                - Parent              }
           7 :: 7                 -> 0;      { Parent in-law         - Parent in-law       }
           8 :: 9                 -> 0;      { Brother/Sister        - Other relative      }
           9 :: 5,8:11,98         -> 0;      { Other relative        - check codes         }
       10:11 :: 10:11             -> 0;      { Adopted/not related   - Adopted/not related }
  98,missing :: 10,11,98,missing  -> 0;      { Unknown               - check codes         }
             ::                   -> 1;      { Invalid relationships                       }
    endrecode;
    if err then
      warning( 5064, $, x, y ) 
	    select( tr("Line number of husband/partner"), $, tr("Continue"), continue );
    endif;
  endif;

PROC Q711
  if $ <> 1 then
    skip to Q714
  endif;

PROC Q713
  if valid($) & $ > Q712 then
    errmsg( 5100, $, Q712 ) 
	  select( tr("Number of wives"), Q712, tr("Wife rank"), $ );
  endif;

PROC Q715Y
  numeric ageatm;
  { Check date of marriage before interview }
  if afterint( Q715M, $, QINTM, QINTY ) then
    errmsg(  89998 ) select( tr("Date of 1st union"), Q715_BLOCK );
  { Compute CMC date of marriage }
  elseif validyr($) then
    ldm = setlb( Q715M, $, 0 );
    udm = setub( Q715M, $, 9999 );
	ageatm = int((ldm-udb)/12);
	if ageatm < 10 then
	  warning( 5140, ageatm ) 
	    select( tr("Date of 1st union"), Q715_BLOCK, 
		        tr("Continue"), continue );
	elseif ageatm > agew then
	  errmsg( 5141, ageatm, agew ) 
	    select( tr("Date of 1st union"), Q715_BLOCK );
	endif;
    skip to Q719M
  endif;

PROC Q716
  if valid($) & $ > agew then
    errmsg( 5131, agew ) select( tr("Age at 1st union"), $ );
  endif;
  if valid($) then
    ldm = ldb+$*12;
    udm = udb+$*12+11;
    if ldm > di then
      if demode() = add then
        warning( 5130, QINTM, QINTY, Q110M, Q110Y, agew, Q715M, Q715Y, $ ) 
		  select( tr("Date of 1st union"), Q715_BLOCK, 
		          tr("Age at 1st union"), $, 
				  tr("Continue"), continue );
      endif
    elseif udm > di then
      udm = di;
    endif;
  else
    { No age and year at marriage given }
    warning( 5135, $, Q715M, Q715Y )
	  select( tr("Date of 1st union"), Q715_BLOCK, 
	          tr("Age at 1st union"), $, 
			  tr("Continue"), continue );
    { Set outer ranges for date of marriage }
    ldm = ldb+minam;
    udm = di;
  endif;

PROC Q719_BLOCK
onfocus
  relterms();  
PROC Q719M
preproc
  if Q714 = 1 | !inunion then
    skip to Q722
  endif;	

PROC Q719Y
  numeric ageatm;
  { Check date of marriage before interview }
  if afterint( Q719M, $, QINTM, QINTY ) then
    errmsg( 89998 ) select( tr("Date of current union"), Q719_BLOCK );
  { Check current date of marriage after date of first marriage }
  elseif afterint( Q715M, Q715Y, Q719M, $ ) then
    errmsg( 89997, Q715M, Q715Y ) 
	  select( tr("Date of 1st union"), Q715_BLOCK, 
	          tr("Date of current union"), Q719_BLOCK );
  { Compute CMC date of marriage }
  elseif validyr($) then
    ldm = setlb( Q719M, $, 0 );
    udm = setub( Q719M, $, 9999 );
	ageatm = int((ldm-udb)/12);
	if ageatm < 10 then
	  warning( 5140, ageatm ) 
	    select( tr("Date of current union"), Q719_BLOCK, 
		        tr("Continue"), continue )
	elseif ageatm > agew then
	  errmsg( 5141, ageatm, agew ) 
	    select( tr("Date of current union"), Q719_BLOCK );
	endif;
    skip to Q722
  endif;

PROC Q720
onfocus
  relterms();  

postproc
  if valid($) & $ > agew then
    errmsg( 5131, agew ) 
	  select( tr("Age at current union"), $ );
  elseif valid($) & valid(Q716) & $ < Q716 then
    errmsg( 5132, Q716 )  
	  select( tr("Age at current union"), $, 
	          tr("Age at 1st union"), Q716 );
  endif;
  if valid($) then
    ldm = ldb+$*12;
    udm = udb+$*12+11;
    if ldm > di then
      if demode() = add then
        warning( 5130, QINTM, QINTY, Q110M, Q110Y, agew, Q719M, Q719Y, $ )
		  select( tr("Date of current union"), Q719_BLOCK, 
		          tr("Age at current union"), Q720,
			      tr("Continue"), continue );
      endif
    elseif udm > di then
      udm = di;
    endif;
  else
    { No age and year at marriage given }
    warning( 5135, $, Q719M, Q719Y )
	  select( tr("Date of current union"), Q719_BLOCK, 
	          tr("Age at current union"), Q720,
			  tr("Continue"), continue );
  endif;

PROC Q721
  $ = "";
PROC Q722
  { Set up ever married status for later use }
  evermarr = ( Q701 in 1,2 | Q702 in 1,2 );

  if $ = 0 then
    if Q212W > 0 | Q232 <> 2 then
      errmsg( 5150 ) select( tr("Age at first intercourse"), $ );
    elseif evermarr then
      if demode() = add then
        warning( 5151 ) 
		  select( tr("Age at first intercourse"), $, 
		          tr("Marital status"), Q701,
		          tr("Continue"), continue );
      endif
    endif;
  elseif $ = 95 & Q702 = 3 then
    errmsg( 5192 ) select( tr("Age at first intercourse"), $ );
  elseif valid($) & $ < 95 & demode() = add then
    if $ > agew then
      warning( 5190, QINTM, QINTY, Q110M, Q110Y, agew, $ )
	    select( tr("Age at first intercourse"), $, 
 		        tr("Current age"), Q111, 
		        tr("Continue"), continue );
    elseif Q212W & $*12 > udc(1)-ldb-7 then
      warning( 5191, Q220M(1), Q220Y(1), Q110M, Q110Y, $ )
	    select( tr("Age at first intercourse"), $, 
		        tr("Date of first pregnancy"), Q220_BLOCK(1), 
				tr("Continue"), continue );
    endif
  endif;
  { skips if never had sex }
  if $ = 0 then
    skip to Q738A;
  endif;

PROC Q723N
onfocus
  protect( Q723U, false );

PROC Q723U
preproc
  if Q723N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { check special answers }
  badspecial( $, Q723N, getsymbol() );

  recode Q723U :: Q723N  -> err;
           3   :: >=12   -> 1;
           2   :: >=52   -> 1;
         <>1   ::  0     -> 1;
               ::        -> 0;
  endrecode;
  if err then
    errmsg( 9994 ) select( tr("Number"), Q723N, tr("Unit"), Q723U );
  elseif Q723U = 4 & Q723N > agew then
    errmsg( 5193, Q723U, Q723N, agew )
	  select( tr("Time since last sex"), Q723_BLOCK, 
 	          tr("Current age"), Q111, 
		      tr("Continue"), continue );
  endif;
  { skips if sex more than a year ago }
  if Q723U in 4,9 then
    skip to Q737
  endif;

PROC Q725
preproc
  if Q232 = 1 then
    skip to Q727
  endif;

postproc
  if $ <> 1 & Q307N <> notappl then
    warning( 3160, GetValuelabel(Q307N) )
      select( tr("Method used during last sex"), $,
		      tr("Method used"), Q307,
		      tr("Continue"), continue );
  endif;
  if $ <> 1 then
    skip to Q727
  endif;	

PROC Q726
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

  { Check all methods are known  }
  {!!! assumes a one to one correspondence between current method and contraceptive table }
  y = length( strip(Q726) );
  do x = 1 while x <= y 
    meth = pos( $[x:1], Q307STR );
    if Q301(meth) <> 1 then
      warning( 3143, GetLabel(Q726, $[x:1]) )
	    select( tr("Method used during last sex"), $,
		        tr("Knowledge of method"), Q301(meth),
		        tr("Continue"), continue );
    endif;
  enddo;
  if poschar("GH",$) then
    skip to Q729
  endif;

PROC Q727
  if $ <> 1 then
    skip to Q730
  endif;

PROC Q729
  majorgrp( $ );
  { Get other answer }
  if $ in 26,37,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q730
  if $ in 1 & !evermarr then
    warning( 5240, Q701, Q702 )
      select( tr("Relationship with last sex partner"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  elseif $ = 2 & Q702 = 3 then
    warning( 5241, Q701, Q702 )
      select( tr("Relationship with last sex partner"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q731
  if $ <> 1 then
    skip to Q737
  endif;

PROC Q733
  if $ in 1 & !evermarr then
    warning( 5240, Q701, Q702 )
      select( tr("Relationship with prior sex partner"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  elseif $ = 2 & Q702 = 3 then
    warning( 5241, Q701, Q702 )
      select( tr("Relationship with prior sex partner"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "Q730", 1 );
    enter FL_OTHERS
  endif;

PROC Q734
  if $ <> 1 then
    skip to Q737
  endif;

PROC Q736
  if $ in 1 & !evermarr then
    warning( 5240, Q701, Q702 )
      select( tr("Relationship with third prior sex partner"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  elseif $ = 2 & Q702 = 3 then
    warning( 5241, Q701, Q702 )
      select( tr("Relationship with third prior sex partner"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "Q730", 2 );
    enter FL_OTHERS
  endif;

PROC Q737
  { minimum should be at 1 + (1 if Q731=1) + (1 if Q734=1) }
  sexp = 1 + (Q731 = 1) + (Q734 = 1);
  if valid($) & $ < sexp then
    warning( 5245, sexp )
      select( tr("Lifetime number of sex partners"), $, tr("Continue"), continue );
  endif;

PROC Q738C
  SaveData();

PROC Q803
preproc
  { skip if respondent or partner sterilized }
  if Q307N in stermeth,stermetm then
    skip to Q813
  { skip if pregnant }
  elseif Q232 <> 1 then
    skip to Q804
  endif;

postproc
  if $ = 1 then
    skip to Q805N
  else
    skip to Q812
  endif;

PROC Q804
  if $ = 2 then
    skip to Q810
  elseif $ = 3 then
    skip to Q813
  elseif $ <> 1 then
    skip to Q812
  endif;

PROC Q805N
onfocus
  protect( Q805U, false );

postproc
  { check consistency with current marital status }
  if $ = 95 & inunion then
    warning( 6032, Q701 )
      select( tr("Timing for future birth"), Q805_BLOCK,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  elseif $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q805U
preproc
  if Q805N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, Q805N, getsymbol() );

  { Check for response of < 9 months }
  if Q805U = 1 & Q805N < 9 & demode() = add then
    warning( 6031 )
	  select( tr("Time to wait for future birth"), Q805N, tr("Continue"), continue );
  endif;

  if Q805U = 9 then
    if Q805N = 94 then
      skip to Q813
    else
      skip to Q812
    endif
  endif;

PROC Q810
preproc
  { if pregnant }
  if Q232 = 1 then
    skip to Q812
  { if currently using }
  elseif Q307N <> notappl then
    skip to Q813
  { Q808 filter }
  elseif Q805U = 1 & Q805N in 0:23 |
         Q805U = 2 & Q805N in 0:1  then
    skip to Q812
  elseif !Q723U in 1:3 then
    skip to Q812
  endif;

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Check "DK" is only response }
  if pos("Z",$) & length(strip($)) > 1 then
    errmsg( 9996 ) select( tr("Fix answers marked"), $ );
  endif;
  { "Not married", but in union }
  if pos( "A", $ ) & inunion then
    warning( 6100, Q701 )
      select( tr("Reason not using"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  endif;
  { "Knows no method", but knows methods }
  if pos( "M", $ ) & count( QWSEC3A_GRP where Q301 = 1 ) then
    warning( 6101 )
      select( tr("Reason not using"), $,
	          tr("Knowledge of methods"), Q301(1),
		      tr("Continue"), continue );
  endif;
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q812
preproc
  { currently using a method }
  if Q307N <> notappl then
    skip to Q813
  endif;

PROC Q813
onfocus
  lchild = count( QWSEC2B_ROSTER2 where Q224 = 1 );

postproc
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS;
  endif;

  if $ in 0,96,missing then
    skip to Q815A
  endif;

PROC Q814B
preproc
  if Q814A = 96 then
    $ = 96;
    noinput
  endif;

postproc
  if ($ = 96 <=> Q814A <> 96) | ($ = missing <=> Q814A <> missing) then
    errmsg( 9994 ) select( tr("Boys"), Q814A, tr("Girls"), Q814B, 
	                       tr("Either"), Q814C, tr("Total"), Q813 );
  endif;

PROC Q814C
preproc
  if Q814A = 96 then
    $ = 96;
    noinput
  endif;

postproc
  if ($ = 96 <=> Q814A <> 96) | ($ = missing <=> Q814A <> missing) then
    errmsg( 9994 )
      select( tr("Ideal number of children by sex"), Q814_BLOCK,
	          tr("Ideal number of children" ), Q813 );
  elseif valid(Q814A) & valid(Q814B) & valid($) & $ < 96 & Q814A+Q814B+$ <> Q813 then
    errmsg( 6131 )
      select( tr("Ideal number of children by sex"), Q814_BLOCK,
	          tr("Ideal number of children"), Q813 );
  endif;

  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q818
preproc
  { skip if not in union }
  if !inunion then
    endgroup
  endif;
  
onfocus
  relterms();  

postproc
  if $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  if $ <> 3 then
    skip to Q820
  endif;	

PROC Q819
onfocus
  relterms();  
  
PROC Q820
onfocus
  relterms();  
  
PROC Q822
preproc
  SaveData();
  { skip if m/f sterilization }
  if Q307N in stermeth,stermetm then
    endgroup
  endif;
  
onfocus
  relterms();  

PROC Q902
preproc
  if !inunion then
    skip to Q909
  endif;
  
onfocus
  relterms();  

PROC Q903
onfocus
  relterms();  

postproc
  if $ = 2 then
    skip to Q906
  endif;

PROC Q904
  if $ = 8 then
    skip to Q906
  endif;

PROC Q905
onfocus
  textstr1 = GetValueLabel(Q904);

  grades.clear();
  grades.add(tr("Less than one year"), 0);
  n = maxgrade(Q904);
  do i = 1 while i <= n
    grades.add(maketext("Year %d", i), i);
    // change the above to match the terms used in the country
    // e.g. it might be "Year" that is used in most levels, but "Form" is used in secondary schooling
    // if Q114 = 2 then
    //   grades.add(maketext("Form %d", i), i);
    // else
    //   grades.add(maketext("Year %d", i), i);
    // endif;
  enddo;
  SetValueSet( $, grades );

postproc
  { Verify the maximum grade for the level }
  if !LevelYears( Q904, $ ) then
    errmsg( 7051 ) 
	  select( tr("Partner's level of education"), Q904, 
	          tr("Partner's grade/year/form"), $ );
  endif;

PROC Q906
onfocus
  relterms();  
  
postproc
  if $ = 1 then
    skip to Q908
  endif;

PROC Q907
onfocus
  relterms();  
  
postproc  
  if $ <> 1 then
    skip to Q909
  endif;

PROC Q908
onfocus
  relterms();  

postproc
  { !!! it is possible that all textual occupation needs to recorded }
  if $ = 96 then           { !!!! Other occupation should be coded as 96 }
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q909
  if $ = 1 then
    skip to Q913
  endif;

PROC Q910
  if $ = 1 then
    skip to Q913
  endif;

PROC Q911
  if $ = 1 then
    skip to Q913
  endif;

PROC Q912
  if $ <> 1 then
    skip to Q919
  endif;

PROC Q913
  { !!! it is possible that all textual occupation needs to recorded }
  if $ = 96 then             { !!!! Other occupation should be coded as 96 }
    getother( "Q908", 1 );   { !!! record others occupation in the question same }
    enter FL_OTHERS
  endif;

PROC Q919
preproc
  if !inunion then
    skip to Q925
  elseif !Q916 in 1,2 then
    skip to Q921
  endif;
  
onfocus
  relterms();  

postproc
  if $ in 2,3 & !inunion then
    warning( 7250, $, Q701 )
      select( tr("Person deciding how earnings are used"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q920
onfocus
  relterms();  

postproc
  if $ = 4 then
    skip to Q922
  endif;

PROC Q921
onfocus
  relterms();  

postproc
  if $ in 2,3 & !inunion then
    warning( 7250, $, Q701 )
      select( tr("Person deciding how husband's earnings are used"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q922
onfocus
  relterms();  

postproc
  if $ in 2,3 & !inunion then
    warning( 7250, $, Q701 )
      select( tr("Final say on health care"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  endif;

PROC Q923
  if $ in 2,3 & !inunion then
    warning( 7250, $, Q701 )
      select( tr("Final say on large purchases"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  endif;

PROC Q924
  if $ in 2,3 & !inunion then
    warning( 7250, $, Q701 )
      select( tr("Final say on visits to family"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  endif;

PROC Q925
onfocus
  if evermarr then
    setvalueset( $, Q925_VS1 );
  else // exclude the husband/partner options for never married
    vs = Q925_VS1;
    vs.remove(2);
    vs.remove(4);
    setvalueset( $, vs );
  endif;
  
 
postproc 
  if $ = 6 then
    skip to Q930A
  endif;

PROC Q926
  if $ <> 1 then
    skip to Q930A
  endif;

PROC Q930A
  if $ <> 1 then
    skip to Q930C
  endif;

PROC Q931B
  if $ in 1,2 & !inunion then
    warning( 7250, $, Q701 )
      select( tr("Presence of husband/partner"), $,
	          tr("Marital status"), Q701,
		      tr("Continue"), continue );
  endif;

PROC Q932E
  SaveData();

PROC Q1000
  $ = "";
PROC Q1001
  if $ <> 1 then
    skip to Q1040
  endif;
  
PROC Q1003
preproc
  if agew >= 25 then
    skip to Q1008
  endif;

PROC Q1010
  if $ <> 1 then
    skip to Q1014
  endif;	

PROC Q1014
preproc
  { skip if no children born after feeding year }
  births2 = 0;
  do i = 1 while i <= totocc(QWSEC04_ROSTER)
    idx = Q404(i);
    if Q405(i) = 1 & ( int((dicdc - Q220CD(idx))/DaysMonth) < yrsfeed*12 | di - udc(idx) < yrsfeed*12 ) then
      births2 = i;
	  break;
    endif;
  enddo;
  if !births2 then
    skip to Q1024
  elseif Q412(births2) <> 1 then
    skip to Q1019
  endif;

postproc
  $ = "";

PROC Q1015
  if $ <> 1 then
    skip to Q1019
  endif;	

PROC Q1016
  majorgrp( $ );
  if $ in 26,37,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q1019
preproc
  if !Q435(births2) in 21:46 then
    skip to Q1022
  endif;

postproc
  if $ <> 1 then
    skip to Q1022
  endif;

PROC Q1022
preproc
  if Q1015 <> 1 & Q1019 <> 1 then
    skip to Q1024
  endif;

postproc
  if $ = 1 then
    skip to Q1025M
  endif;

PROC Q1023Y
  if afterint(Q1023M,$,QINTM,QINTY) then
	errmsg( 89998 ) select( tr("Date most recent HIV test"), Q1023_BLOCK );
  endif;
  ldth = setlb( Q1023M, Q1023Y, 0 );
  if ldth < ldb then
    errmsg( 11012, Q110M, Q110Y ) select( tr("Date most recent HIV test"), Q1023_BLOCK );
  endif;
  skip to Q1028;

PROC Q1024
  if $ <> 1 then
    skip to Q1032
  endif;

PROC Q1025Y
  if afterint(Q1025M,$,QINTM,QINTY) then
	errmsg( 89998 ) select( tr("Date most recent HIV test"), Q1025_BLOCK );
  endif;
  ldth = setlb( Q1025M, Q1025Y, 0 );
  if ldth < ldb then
    errmsg( 11012, Q110M, Q110Y ) select( tr("Date most recent HIV test"), Q1023_BLOCK );
  endif;

PROC Q1026
  majorgrp( $ );
  if $ in 26,37,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q1027
  if $ <> 1 then
    skip to Q1031
  endif;

PROC Q1028
// Add in a test for code 5 versus Q1027 = 1, or restrict valueset if coming from Q1027 (code is needed if coming from Q1023)
  if $ <> 1 then
    skip to Q1031
  endif;	

PROC Q1029M
  if $ = 95 then
    skip to Q1030
  endif;

PROC Q1029Y
  if afterint(Q1029M,$,QINTM,QINTY) then
	errmsg( 89998 ) select( tr("Date tested positive"), Q1029_BLOCK );
  endif;
  udth = setlb( Q1029M, Q1029Y, 9999 );
  if udth > ldth+1 then   // give one month to allow time to get results from last test
    if Q1023M <> notappl then
      errmsg( 11010 ) select( tr("Date tested positive"), Q1029_BLOCK,
                              tr("Date most recent HIV test"), Q1023_BLOCK );
    else
      errmsg( 11010 ) select( tr("Date tested positive"), Q1029_BLOCK,
                              tr("Date most recent HIV test"), Q1025_BLOCK );
    endif;							  
  endif;
  if udth < ldb then
    errmsg( 11011, Q110M, Q110Y ) select( tr("Date tested positive"), Q1029_BLOCK );
  endif;

PROC Q1032
  if $ <> 1 then
    skip to Q1034
  endif;
  
PROC Q1043
preproc
  if Q722 = 0 then
    skip to Q1046;
  elseif Q1040 <> 1 then
    skip to Q1044
  endif;

PROC Q1049
preproc
  SaveData();
  if !inunion then
    endgroup;
  endif;

PROC Q1102
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC CD02
  if $ <> 1 then
    skip to CD06
  endif;
PROC CD07
  if $ <> 1 then
    skip to Q1103
  endif;
PROC Q1104
  $ = "";
  
  
PROC Q1106
  if $ <> 1 then
    skip to Q1108
  endif;

PROC Q1108
  if !$ in 1,2 then
    skip to Q1110
  endif;

PROC Q1109
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC Q1110
  if $ <> 1 then
    skip to Q1113A
  endif;	

PROC Q1111
  if $ = 0 then
    skip to Q1113A
  endif;

PROC DV01
preproc
  { check if woman is selected for domestic violence }
  if QVIOLEN <> 1 then
    endgroup
  endif;

postproc
  if $ <> 1 then
    // skip to capture reason for not completing DV module in a note?
    skip to DV37
  endif;

PROC DV02
  $ = "";

PROC DV04
preproc
  anyviol = 0;

  if evermarr then
    skip to DV06A1
  endif;

postproc
  relterms2();
  if $ = 1 then
    skip to DV06A1
  endif;

PROC DV05
  if $ <> 1 then
    skip to DV20
  endif;

PROC DV06A1
onfocus
  relterms2();

PROC DV06A2
preproc
  ask if DV06A1 = 1;
  
PROC DV06B2
preproc
  ask if DV06B1 = 1;
  
PROC DV06C2
preproc
  ask if DV06C1 = 1;
  
PROC DV06D2
preproc
  ask if DV06D1 = 1;
  
PROC DV06E2
preproc
  ask if DV06E1 = 1;
  
PROC DV07A1
onfocus
  relterms2();
PROC DV07A2
preproc
  ask if DV07A1 = 1;

PROC DV07B2
preproc
  ask if DV07B1 = 1;

PROC DV07C2
preproc
  ask if DV07C1 = 1;

PROC DV08A1
onfocus
  relterms2();
PROC DV08B2
preproc
  ask if DV08B1 = 1;

PROC DV08C2
preproc
  ask if DV08C1 = 1;

PROC DV08A2
preproc
  ask if DV08A1 = 1;

PROC DV08D2
preproc
  ask if DV08D1 = 1;

PROC DV08E2
preproc
  ask if DV08E1 = 1;

PROC DV08F2
preproc
  ask if DV08F1 = 1;

PROC DV08G2
preproc
  ask if DV08G1 = 1;

PROC DV08H2
preproc
  ask if DV08H1 = 1;

PROC DV08I2
preproc
  ask if DV08I1 = 1;

PROC DV08J2
preproc
  ask if DV08J1 = 1;

PROC DV10_BLOCK
preproc
  anyviol = ( DV08A1 = 1 | DV08B1 = 1 | DV08C1 = 1 | DV08D1 = 1 | DV08E1 = 1 |
              DV08F1 = 1 | DV08G1 = 1 | DV08H1 = 1 | DV08I1 = 1 | DV08J1 = 1 );
  if !anyviol then		
    skip to DV11
  endif;

onfocus
  relterms2();
PROC DV11
onfocus
  relterms2();

postproc
  if $ <> 1 then
    skip to DV13
  endif;

PROC DV12
onfocus
  relterms2();
PROC DV13
onfocus
  relterms2();

postproc
  if $ <> 1 then
    skip to DV15
  endif;

PROC DV15
onfocus
  relterms2();
PROC DV16A1
onfocus
  relterms2();

postproc
  if $ = 6 then
    skip to DV18
  endif;

PROC DV16A2
preproc
  ask if DV16A1 = 1;

PROC DV16B2
preproc
  ask if DV16B1 = 1;

PROC DV16C2
preproc
  ask if DV16C1 = 1;

PROC DV18
preproc
  numeric phyviol = ( DV08H1 = 1 | DV08I1 = 1 | DV08J1 = 1 | DV16B1 = 1 );
  if !phyviol then	
    skip to DV20
  endif;	

postproc
  { check years in abusive relationship with current age }
  if valid($) & $ < 95 & $ > agew then
    warning( 11001, agew )
	  select( tr("Age at first time forced to have sex"), $, tr("Continue"), continue );
  endif;

PROC DV20
preproc
  if Q212W = 0 & Q232 <> 1 then    { No pregnancies and not pregnant }
    skip to DV22
  endif;

postproc
  if $ <> 1 then
     skip to DV22
  endif;

PROC DV21
  $ = SortAlpha( $ );
  { Get other answer }
  if pos("X",$) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC DV22
  if $ <> 1 then
    skip to DV26
  endif;

PROC DV23
  $ = SortAlpha( $ );
  { Get other answer }
  if pos("X",$) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC DV26
preproc
  if DV06A1 = notappl then
    skip to DV27
  endif;

postproc
  if $ = 1 then
    skip to DV28
  else
    skip to DV32
  endif;

PROC DV27
  if $ <> 1 then
    skip to DV32
  endif;

PROC DV28
  { check age at first abusive sexual intercourse with current age }
  if valid($) & $ < 95 & $ > agew then
    warning( 11001, agew )
	  select( tr("Age at first time forced to have sex"), $, tr("Continue"), continue );
  endif;

PROC DV29
  $ = SortAlpha( $ );
  { Get other answer }
  if pos("X",$) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC DV32
preproc
  if !anyviol & !(DV16A1 = 1 | DV16B1 = 1 | DV20 = 1 | DV22 = 1 | DV26 = 1 | DV27 = 1) then
    skip to DV35
  endif;

postproc
  if $ <> 1 then
    skip to DV34
  endif;

PROC DV33
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

  skip to DV35;

PROC DV36C
preproc
  SaveData();
  { @@@ End Domestic Violence }

{ @@@ Begin Female Genital Cutting Module for Women }
PROC DV37
onfocus
  $ = " ";

postproc
  if demode() = add then
    strnotes = editnote();
  endif;

PROC DVFIN
  $ = "";
PROC QWSEC2C_FORM
preproc
  savedata();
{ displays last form for women's questionnaire }
{ copy temporary to final calendar }
  do i = 1 while i <= callen
    QCAL(1)[i:1] = QCAL1[i:1];
    QCAL(2)[i:1] = QCAL2[i:1];
  enddo;
  
PROC Q1116H
preproc
  if visualvalue( $ ) = notappl then
    time = systime();
    $ = int( time/10000 );
  endif;

PROC Q1116M
preproc
  if visualvalue( $ ) = notappl then
    time = systime();
    $ = int( time/100 ) % 100;
  endif;
  
postproc  
  skip to QLANGQ
  
{ @@@ Ends the entire women's questionnaire }

{ @@@ Begin Men's Questionnaire }

PROC QLANGI
preproc
if Q1116H in 0:5,23 then
	warning( 0184 ) 
	select( tr("Check tablet clock" ), $, tr("Continue"), continue );;
  endif;
PROC QLANGQ
preproc
  savedata();

  if special(visualvalue($)) then
    $ = 1;
    if getlanguage() = "RU" then
	  $ = 2;
	endif;
    if getlanguage() = "TJ" then
	  $ = 3;
	endif;	
  endif;

{ @@@ taking GPS coordinates for individual }
PROC GIAUX
preproc
skip to QFINAL;

{preproc
  capturecoor = ( visualvalue(GILATITUDE) = notappl );
  if capturecoor then
    skip to GIINTRO
  endif;  

onfocus
  $ = 2;
  capturecoor = ( visualvalue(GILATITUDE) = notappl );
  
postproc
  if $ <> 1 then
    advance to QFINAL
  endif;  
 } 
PROC GIINTRO
onfocus
  capturecoor = ( visualvalue(GILATITUDE) = notappl );

postproc
  { open the GPS dongle to capture GPS coordinates }
  { !!! verify using the device manager the port number used by the dongle       }
  {     in ICF laptops port 3 is reserved and erroneously taken as a dongle port }
  {     in ASUS tablets ports are assigned starting from port 3 and above        }
  capturecoor = ( visualvalue(GILATITUDE) = notappl );
  if $ = 1 & GIAUX <> 2 then 
    if GIAUX = 1 & accept( tr("Coordinates were already collected. Are you sure that you need to recollect them?"),
                           tr("No, do not recollect the coordinates"),
                           tr("Yes, recollect the coordinates") ) <> 2 then
      reenter GIAUX
    endif;	  
	if android then
      gpsopen = GPS( open );
    else // Windows
      do i = 3 while i <= 10
        if GPS( open, i, 4800 ) then
          break
        endif;
      enddo;
	  gpsopen = (i <= 10);
    endif;	  
    if !gpsopen then
      errmsg( 60045 );
      if capturecoor then
        skip to QFINAL
      else
        advance to QFINAL
      endif;
    endif;
  else
    if capturecoor then
      skip to QFINAL
    else
      advance to QFINAL
	endif;
  endif;

PROC GILATITUDE
preproc
  string gpstitle;
  capturecoor = ( visualvalue(GILATITUDE) = notappl );
  if GIINTRO = 1 & GIAUX <> 2 then 
    gpstitle = tr("GPS device acquiring GPS satellites. Please wait to complete its capture");
    if gps(read, 25, gpstitle ) then
      GILATITUDE  = gps(latitude);
      GILATPOLE   = "N";
      if gps(latitude) < 0 then	{ negative = south }
        GILATPOLE = "S";
      endif;
      GILONGITUDE = gps(longitude);
      GILNGPOLE  = "E";
      if gps(longitude) < 0 then	{ negative = west }
        GILNGPOLE = "W";
      endif;
      GIALTITUDE = gps(altitude);
      GISATELLIT = gps(satellites);	  { no. of satellites, at least 3-4 is recommended }
      GIACCURACY = gps(accuracy);	  { precision level, 1 is the best possible and 50 the least accurate }
    else
      errmsg( 60050 );
      if !capturecoor then 
        advance to QFINAL
      else
        skip to QFINAL
      endif;
    endif;
  else
    if !capturecoor then 
      advance to QFINAL
    else
      skip to QFINAL
    endif;
  endif;
  { @@@ end taking GPS coordinates for individual }

PROC QFINAL
preproc
  savedata();

onfocus
  $ = " ";

postproc
  if demode() = add then
    strnotes = editnote();
    if endmess() then
      reenter $
    endif;
  endif;
  endlevel;
  
PROC OTHSEC
  { Check text of response has changed and if so write it out }
  if compare(OTHRESP,wothresp) <> 0 | OTHCODE <> wothcode then
    writecase( OTHERS );
  endif;

PROC OTHRESP
  $ = toupper($);
  { Check that response is alphabetic and starts in the first column }
  if !pos($[1:1],alphalst) then
    errmsg( 89991 ) select( tr("Enter text"), $ );
  endif;

PROC OTHCODE
preproc
  { Initialize code for other answer to zero and skip variable }
  noinput;

