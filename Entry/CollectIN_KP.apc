PROC GLOBAL
{ CAPI for DHS-8 surveys - version 1.2.0 December 2022 }

  { Definitions of working variables }
  alpha(60) wothresp;     { Other answers response }
  numeric   wothcode;     { Other answers code }
  numeric   meth;         { modified method number to be used with calendar }

  string textstr1;        { Alpha variable for customized text for questions }
  string textstr2;        { Alpha variable for customized text for questions }
  string event1;          { Alpha variable for 1st event in the calendar }
  string event2;          { Alpha variable for 2nd event in the calendar }
  string mnthstr1;        { Alpha variable for 1st month's name }
  string mnthstr2;        { Alpha variable for 2nd month's name }
  string alphmeth;        { Alpha variable to get method's name }
  string facility;        { Alpha variable for the type of facility }
  string asource;         { source of methods for calendar column 3 }
  string strnotes;        { for editnote at the end of the interview }
  
  string fname;           { String for data filenames }
  string pregstr;         { Pregnancy codes for the calendar }
  string methstr;         { Method codes for the calendar }
  string alphalst;        { The alphabet }
  string A307str;         { string of codes used in A307 }
  string am439str;        { string of codes for methods used in AM418 }
  string spec;            { String of special codes WXYZ used in checking alpha vars }
  string calw;            { Working calendar variable }
  string methname;        { method name }
  string relpast;         { whether relation is current or past }
  string rellast;         { whether relation is NULL or past }
  string partype;         { type of partner husband/male partner }
  string lastfield;       { last field application was on - used in onkey function - do not reuse }
  string foodfield;       { name of the last food or drink field that the cursor was on }
  string id;              { questionnaire full ID }
  string partner;         { to customize questions where husband and partenr are used }
  array string orderstr(5);
  
  alpha(1)  calcode;      { one digit code to be used by the calendar }
  alpha(1)  codemar;      { code for marriage to be used in calendar }
  alpha(1)  codeb;        { Code for births }
  alpha(1)  codep;        { Code for pregnancies }
  alpha(1)  codet;        { Code for terminations }
  alpha(1)  onemeth;      { current method to check with calendar }

  array twincode(24);            { Codes for checking twins in birth history }
  array ldc(24);                 { Lower bound of CMC date of birth for children }	
  array udc(24);                 { Upper bound of CMC date of birth for children }
  array calrow(24);              { Row of calendar for pregnancy }
  array birthrow(80);            { number of pregnancy in calendar row, i.e pregnancy 07 is in row 60 }
  array string womevents(20,3);  { women events }
  array string months_array(12) = "Dec","Nov","Oct","Sep","Aug","Jul","Jun","May","Apr","Mar","Feb","Jan";
  array string cal_array(72,7);  { used to display calendar from toolbar }
  array string BloodCat(6) = "Acceptable range", "At the high end of acceptable range",
                             "Above acceptable range", "Moderately high", "High", "Very high";
  array string BloodCon(6) = "24 months", "12 months", "2 months",
                             "1 month", "7 days", "Today";
  numeric disp1, disp2;          { used for current episode indicators to display calendar }

  numeric i, n, j, t, x, y, b, m, p, err, InEntry, android, capturecoor, gpsopen;
  numeric sday, smonth, syear, di, dicdc, time, ch, checkx, minab, minam, minabm, minamm, max5, maxsib;
  numeric calint, calbeg, calend, callen, calendy, calbegy, yrspcare, yrsvacc, yrshlth, yrsfeed;
  numeric calterm, xrow, ycmc, pregtype, pregpcare, pregvacc, preghlth, pregfeed, births2;
  numeric endevent, begevent, cmcend, cmcbeg, endrowint, begrowint, caluse, calmeth, calcmc, beguse, begcheck;
  numeric uniocal, cmcdm, begrow, endrow, prev, maxd, mind, adeath, wives;
  numeric ldb, udb, ldth, udth, lds, uds, xl, xu, ldm, udm, upto;
  numeric xintnum, xsupnum, xmodcent, xrvisit, xmodify, xpartial, xentryhw, xhhnum, xline, xteam, reviewsup;
  numeric methoth, methem, methsupp, stermeth, stermetm, used, usem, methpos, discont, xusing, condom, method;
  numeric vcheckx, temp, evermarr, inunion, prostit, sexp, agric, ch014, ch017, daughter;
  numeric goodval, oldval, maxchild, twins, age, aold, iold, aoldest, anew; 
  numeric month, year, year1, month1, year2, month2, mstat, lchild, daughty;
  numeric older, order, agew, agem, agedau, breastfed, treatment, marriages;
  numeric NSibs, xMM03, xMM04, xMM05, xMM06, xMM08, xMM10;
  numeric relprev, anyviol, nhhold, showcard, showID;
  numeric DaysMonth = 30.4375, WeeksMonth = 0.23;
  numeric idx, durpreg;
  numeric drinks_popup   = 0;	// used in handling A636
  numeric foods_popup    = 0;	// used in handling A637
  numeric foods_popupW   = 0;	// used in handling A643 for foods
  numeric other_drinks   = 0;   // toggle for "other" drinks for children
  numeric other_foods    = 0;   // toggle for "other" foods for children
  numeric other_foodsW   = 0;   // toggle for "other" foods for women
  numeric foodsid  = 0;         // resource id for foods userbar button
  numeric preghid  = 0;         // resource id for pregnancy history userbar button
  numeric pregsid  = 0;         // resource id for pregnancies userbar button
  numeric eventsid = 0;         // resource id for events display
  numeric matmortid= 0;         // resource id for maternal mortality display
  numeric moving   = 0;         // when moving pregnancies
  numeric calendid = 0;         // resource id for calendar display
  numeric goback222 = 0;        // manages when to go back to 222
  numeric indexpreg, indexpreg2, childecd;
  numeric twinnum;

  valueset individuals, vs;
  valueset string vaccinations, foods, sources;
  valueset grades;

  { used to move to a specific section in the questionnaire } 
  function toSection();
    numeric ix = 0;
    numeric sec = 0;
    array string formname(20);
    string formstr;
    if AQTYPE = 2 then
      sec = accept( tr("Go to section:"),
        getlabel( ASECOVER  ), 
        getlabel( AWSEC01   ), 
        getlabel( AWSEC2A   ), 
        getlabel( AWSEC2B   ), 
        getlabel( AWSEC2D   ), 
        getlabel( AWSEC3A   ), 
        getlabel( AWSEC3B   ), 
        getlabel( AWSEC3C   ), 
        getlabel( AWSEC04   ), 
        getlabel( AWSEC05   ), 
        getlabel( AWSEC6A   ), 
        getlabel( AWSEC6B   ), 
        getlabel( AWSEC07   ), 
        getlabel( AWSEC08   ), 
        getlabel( AWSEC09   ), 
        getlabel( AWSEC10   ), 
        getlabel( AWSEC11   ), 
        getlabel( AWSECMH   ), 
        getlabel( AWSECM1   ), 
        getlabel( AWSECM2   ), 
        getlabel( AWSECDV   ), 
        getlabel( AWSECG1   ), 
        getlabel( AWSECG2   ), 
        getlabel( AWSECECD  ), 
        getlabel( AWSECSBC  ), 
        getlabel( AWSECFIS  ), 
        tr("End of questionnaire"),
        tr("Cancel") );
      if     sec =  1 & totocc(ASECOVER_FORM) then move to ASECOVER_FORM advance
      elseif sec =  2 & totocc(AWSEC01_FORM)  then move to AWSEC01_FORM  advance
      elseif sec =  3 & totocc(AWSEC2A_FORM)  then move to AWSEC2A_FORM  advance
      elseif sec =  4 & totocc(AWSEC2B_FORM)  then move to AWSEC2B_FORM  advance
      elseif sec =  5 & totocc(AWSEC2D_FORM)  then move to AWSEC2D_FORM  advance
      elseif sec =  6 & totocc(AWSEC3A_FORM)  then move to AWSEC3A_FORM  advance 
      elseif sec =  7 & totocc(AWSEC3B_FORM)  then move to AWSEC3B_FORM  advance 
      elseif sec =  8 & totocc(AWSEC3C_FORM)  then move to AWSEC3C_FORM  advance 
      elseif sec =  9 & totocc(AWSEC04_FORM)  then move to AWSEC04_FORM  advance 
      elseif sec = 10 & totocc(AWSEC05_FORM)  then move to AWSEC05_FORM  advance 
      elseif sec = 11 & totocc(AWSEC6A_FORM)  then move to AWSEC6A_FORM  advance 
      elseif sec = 12 & totocc(AWSEC6B_FORM)  then move to AWSEC6B_FORM  advance 
      elseif sec = 13 & totocc(AWSEC07_FORM)  then move to AWSEC07_FORM  advance 
      elseif sec = 14 & totocc(AWSEC08_FORM)  then move to AWSEC08_FORM  advance 
      elseif sec = 15 & totocc(AWSEC09_FORM)  then move to AWSEC09_FORM  advance 
      elseif sec = 16 & totocc(AWSEC10_FORM)  then move to AWSEC10_FORM  advance 
      elseif sec = 17 & totocc(AWSEC11_FORM)  then move to AWSEC11_FORM  advance 
      elseif sec = 18 & totocc(AWSECMT_FORM)  then move to AWSECMT_FORM  advance 
      elseif sec = 19 & totocc(AWSECM1_FORM)  then move to AWSECM1_FORM  advance 
      elseif sec = 20 & totocc(AWSECM2_FORM)  then move to AWSECM2_FORM  advance 
      elseif sec = 21 & totocc(AWSECDV_FORM)  then move to AWSECDV_FORM  advance 
      elseif sec = 22 & totocc(AWSECG1_FORM)  then move to AWSECG1_FORM  advance 
      elseif sec = 23 & totocc(AWSECG2_FORM)  then move to AWSECG2_FORM  advance 
      elseif sec = 24 & totocc(AWSECECD_FORM) then move to AWSECECD_FORM advance 
      elseif sec = 25 & totocc(AWSECSBC_FORM) then move to AWSECSBC_FORM advance 
      elseif sec = 26 & totocc(AWSECFIS_FORM) then move to AWSECFIS_FORM advance 
      elseif sec = 27 & totocc(ALANG_FORM)    then move to ALANG_FORM    advance 
	  elseif sec = 28 then   // Cancel - do nothing
	  else
	    errmsg( 0005 );
      endif;
    elseif AQTYPE = 1 then
      sec = accept( tr("Go to section:"),
        getlabel( ASECOVER  ), 
        getlabel( AMSEC01   ), 
        getlabel( AMSEC02   ), 
        getlabel( AMSEC3A   ), 
        getlabel( AMSEC3B   ), 
        getlabel( AMSEC04   ), 
        getlabel( AMSEC05   ), 
        getlabel( AMSEC06   ), 
        getlabel( AMSEC07   ), 
        getlabel( AMSEC08   ), 
        getlabel( AMSECGC   ), 
        tr("End of questionnaire"),
        tr("Cancel") );
      if     sec =  1 & totocc(ASECOVER_FORM) then move to ASECOVER_FORM advance
      elseif sec =  2 & totocc(AMSEC01_FORM)  then move to AMSEC01_FORM  advance
      elseif sec =  3 & totocc(AMSEC02_FORM)  then move to AMSEC02_FORM  advance
      elseif sec =  4 & totocc(AMSEC3A_FORM)  then move to AMSEC3A_FORM  advance
      elseif sec =  5 & totocc(AMSEC3B_FORM)  then move to AMSEC3B_FORM  advance
      elseif sec =  6 & totocc(AMSEC04_FORM)  then move to AMSEC04_FORM  advance
      elseif sec =  7 & totocc(AMSEC05_FORM)  then move to AMSEC05_FORM  advance
      elseif sec =  8 & totocc(AMSEC06_FORM)  then move to AMSEC06_FORM  advance
      elseif sec =  9 & totocc(AMSEC07_FORM)  then move to AMSEC07_FORM  advance
      elseif sec = 10 & totocc(AMSEC08_FORM)  then move to AMSEC08_FORM  advance
      elseif sec = 11 & totocc(AMSECGC_FORM)  then move to AMSECGC_FORM  advance
      elseif sec = 12 & totocc(ALANG_FORM)    then move to ALANG_FORM    advance 
	  elseif sec = 13 then   // Cancel - do nothing
	  else
	    errmsg( 0005 );
      endif;
    endif;
  end;

  { to position window with answers: 0-Next to answers window -1-Next to field }
  function responseloc( loc );
    if loc = 1 then
      setproperty( ccIN80, "captureposx", "0" );
      setproperty( ccIN80, "captureposy", "0" );
	elseif loc = 2 then
      setproperty( ccIN80, "captureposx", "-1" );
      setproperty( ccIN80, "captureposy", "-1" );
    endif;
  end;

  { to select where to position window with answers }
  function responses( loc );
    if !loc in 1,2 then
      loc = accept( tr("Select location for responses"),
	                tr("Top left corner beneath questions"),
		            tr("Next to field on the form") );
	endif;
	responseloc( loc );
    reenter; // force reposition of labels - only works when called from a field
  end;

  { setup basic user bar }
  function userbase();
    userbar( clear );
    userbar( add button, "<",    do("PreviousField") );
    userbar( add button, ">",    do("NextField") );
    userbar( add button, ">>|",  do("AdvanceToEnd") );
    userbar( add button, tr("Note"), do("EditNote") );
    userbar( add button, tr("Lang"), do("ChangeLanguage") );
	userbar( add button, tr("Ver"),  GetPubDate(2) );
	userbar( add button, tr("Section"), toSection() );
	if !android then // Response location only works for Windows
	  userbar( add button, tr("Responses"), Responses( 0 ) );
	endif;
  end;

  { set value sets based on language }
  function OnChangeLanguage()
    SetLanguage( getlanguage() );
    savesetting("Language", getlanguage());
  end;

  { list all pictures and use the last last one taken }
  function string GetPicture()
    string picfile;
    list string PictureList;
    picfile = "C:/Users/" + GetUserName() + "/Pictures/Camera Roll";
    dirlist( PictureList, picfile, "WIN*.JPG" );
    do j = 1 while j <= PictureList.length()
      Textstr2 = PictureList(j);
    enddo;
    GetPicture = Textstr2;
  end;

  { function to take picture with a windows tablet }
  function TakePictureW( child )
    image VCardPic;
    { take as many pictures as necessary }
    do i = 1 while i
      execsystem( "cmd /c start microsoft.windows.camera:", wait ); 	
      display( tr("Click OK to continue") );	  
      textstr1 = GetPicture();
      VCardPic.load(textstr1);
      VCardPic.resample(width := 800, height := 600);
	  FileDelete( textstr1 );
      { find if there are pictures previusly taken for that child  and generate different versions }
      textstr2 = "../PII/Pictures/P" + id + edit("99",child);
      do n = 1 while FileExist( textstr2 + "_" + edit("99",n) + ".jpg" ) enddo;
      textstr2 = textstr2 + "_" + edit("99",n) + ".jpg";
      VCardPic.save( textstr2 );	  
      view( textstr2 );
      if accept( tr("Do you want to take another picture of the document"), tr("Yes"), tr("No") ) <> 1 then
        break
      endif;
    enddo;
  end;

  { function to take picture with an android tablet }
  function TakePictureA( child )
    image VCardPic;
    { take as many pictures as necessary }
    do i = 1 while i
	  if VCardPic.TakePhoto( tr("Photo of the document with vaccinations") ) then
        VCardPic.resample(width := 800, height := 600);
        { find if there are pictures previusly taken for that child  and generate different versions }
        textstr2 = "../PII/Pictures/P" + id + edit("99",child);
        do n = 1 while FileExist( textstr2 + "_" + edit("99",n) + ".jpg" ) enddo;
        textstr2 = textstr2 + "_" + edit("99",n) + ".jpg";
        VCardPic.save( textstr2 );
        view( textstr2 );
        if accept( tr("Do you want to take another picture of the document"), tr("Yes"), tr("No") ) <> 1 then
          break
        endif;
      endif;		
    enddo;
  end;

  { used by the central office to show a vaccination card picture display  }
  function ShowVaccCard()
    textstr2 = "../PII/Pictures/P" + id + edit("99",A503);
    do n = 1 while FileExist( textstr2 + "_" + edit("99",n) + ".jpg" ) enddo;
    textstr2 = textstr2 + "_" + edit("99",n-1) + ".jpg";
    if !fileExist(textstr2) then
      errmsg( 4465, A503, strip(A218(A503)) );
    else
      view( textstr2 );
    endif;
  end;

  array string preghist(24,9);
  function ph_array();
    do i = 1 while i <= maxchild
	  if maxchild > A212W & special( visualvalue( A215L(i) ) ) & special( visualvalue( A215(i) ) ) & special( visualvalue( A216(i) ) ) then
	    break
	  else
	    preghist(i,1) = maketext( "%2d", visualvalue( A215L(i) ) );
	    preghist(i,2) = A218(i);
	    preghist(i,3) = replace(maketext( "%1d", visualvalue( A216(i) ) ), "NOTAPPL", "") + "-" + getlabel( A216, visualvalue( A216(i) ) );
	    preghist(i,4) = getlabel( A223, visualvalue( A223(i) ) );
		recode visualvalue( A219(i) ) -> preghist(i,5);
								  1   -> tr("Boy");
								  2   -> tr("Girl");
								      -> "";
		endrecode;
		if special( visualvalue( A220D(i) ) ) & special( visualvalue( A220M(i) ) ) & special( visualvalue( A220Y(i) ) ) then
		  preghist(i,6) = "";
		else
		  preghist(i,6) = maketext( "%d/%d/%d", visualvalue( A220D(i) ), visualvalue( A220M(i) ), visualvalue( A220Y(i) ) );
		endif;
		recode visualvalue( A224(i) ) -> preghist(i,7);
								  1   -> tr("Alive");
								  2   -> tr("Dead");
								      -> "";
		endrecode;
		recode visualvalue( A225(i) ) -> preghist(i,8);
						       0:40   -> maketext( "%d", visualvalue( A225(i) ) );
							     98   -> tr("DK");
								      -> "";
		endrecode;
		recode visualvalue( A226(i) ) -> preghist(i,9);
								  1   -> tr("Yes");
								  2   -> tr("No");
								      -> "";
		endrecode;
	  endif;
	enddo;
	ph_array = i-1;
  end;

  array string hhmember(50,7);
  function hhm_array();
    do i = 1 while i <= AHMEMBER
	  {Line number}
	  hhmember(i,1) = maketext( "%2d", AH01(i) );
      { First/last name }
	  hhmember(i,2) = AH02(i);
      { Relationship with head of household }
	  hhmember(i,3) = getlabel(AHRELAT, AH03(i));
      { Update labels to be sex specific where we can - otherwise leave as in dictionary }
      if AH04(i) = 1 then
		recode AH03(i) -> hhmember(i,3);
                 2     -> tr("Husband");
                 3     -> tr("Son");
                 4     -> tr("Son-in-law");
                 6     -> tr("Father");
                 7     -> tr("Father-in-law");
                 8     -> tr("Brother");
        endrecode;
      else
        recode AH03(i) -> hhmember(i,3);
                 2     -> tr("Wife");
                 3     -> tr("Daughter");
                 4     -> tr("Daughter-in-law");
                 6     -> tr("Mother");
                 7     -> tr("Mother-in-law");
                 8     -> tr("Sister");
        endrecode;
      endif;
      { Sex }
      hhmember(i,4) = getlabel(AH04, AH04(i));
      { Usual residence }
      hhmember(i,5) = getlabel(AH05, AH05(i));
      { Slept the night before }
      hhmember(i,6) = getlabel(AH06, AH06(i));
	  hhmember(i,7) = maketext( "%2d", AH07(i) );
	enddo;
	hhm_array = i-1;
  end;

  array string SiblingsList(20,7);
  function sib_array();
    do i = 1 while i <= maxsib
	  if i > totocc(AWSECMM_ROSTER) then
	    break
	  else
	    SiblingsList(i,1) = maketext( "%2d", visualvalue( AMM13(i) ) );
	    SiblingsList(i,2) = AMM13N(i);
		recode visualvalue( AMM14(i) ) -> SiblingsList(i,3);
								  1    -> tr("Male");
								  2    -> tr("Female");
								       -> "";
		endrecode;
		recode visualvalue( AMM15(i) ) -> SiblingsList(i,4);
								  1    -> tr("Alive");
								  2    -> tr("Dead");
								       -> "";
		endrecode;
		if visualvalue(AMM15(i)) = 1 then
	      SiblingsList(i,5) = maketext( "%2d", visualvalue( AMM16(i) ) );
		  SiblingsList(i,6) = "";
	      SiblingsList(i,7) = "";
		else
	      SiblingsList(i,5) = "";
	      SiblingsList(i,6) = maketext( "%2d", visualvalue( AMM17(i) ) );		
	      SiblingsList(i,7) = maketext( "%2d", visualvalue( AMM18(i) ) );		
        endif;
	  endif;
	enddo;
	sib_array = i-1;
  end;

  { help function to display pregnancy history, household members }
  function showroster( rtype )
    numeric npregs;
	numeric nsibls;
    numeric sr = 0;
    if rtype = 1 then   // pregnancy history
	  npregs = ph_array();
      sr = showarray( tr("Pregnancy history")+" ("+tr("expecting")+" "+edit("9",visualvalue(A212W))+" "+tr("pregnancy outcomes")+")",
 	      preghist, npregs, 
          title( tr("Line"), tr("Name"), tr("Initial Outcome"), tr("Final Outcome"), tr("Sex"), tr("Date"), tr("Alive"), tr("Age"), tr("Live Mother") ) );
    elseif rtype = 2 then  // siblings
	  nsibls = sib_array();
      sr = showarray( tr("Maternal mortality: siblings"), SiblingsList, nsibls,
          title( tr("Line"), tr("Name"), tr("Sex"), tr("Alive"), tr("Age"), tr("Years-D"), tr("Age-D") ) );
    elseif rtype = 3 then   // events
      sr = showarray( tr("List of events"), womevents, title(tr("Event"), tr("Date"), tr("Dur/Preg")) );
    elseif rtype = 4 then  // household members
      sr = showarray( tr("Household members"), hhmember, nhhold, 
          title( tr("Line"), tr("Name"), tr("Relation"), tr("Sex"), tr("Usual"), tr("Stayed"), tr("Age") ) );	
    endif;
    showroster = sr;
  end;

  { function to show the pregnancies to include in sections 4, 5, and 6 of the questionnaire }
  function showpreg456(string titlestr, index, birth)
    // index is the index of the earliest pregnancy to include
	// birth is whether to include only live births (1) or all pregnancies (0)
    show( titlestr, ccIN80.AWSEC2B, A215L, A218, A220,
    where A215L >= index & (birth = 0 | A224 = 1) // include either all pregnancies (birth = 0) or living children only (q224 = 1)
    title( tr("Line number"), tr("Name"), tr("Date of birth/end of pregnancy") ));
  end;

  { Function to ensure proper entry and updating of "Other" answers }
  function getother( alpha(10) questnum, questocc );
    { Create alpha id for other answers file }
    { If your ID is not 10 characters in length, remember to fix the length of the level 1 ID and of OTHID in OTHERS.DCF }
    OTHID   = id;
    OTHQUES = questnum;   { question number }
    OTHOCC  = questocc;   { occurrence for multiple section/group or
                                           multipart question }
    { Get the previous response back if already entered
      in case of backtabbing or updating }
    if !loadcase( OTHERS, OTHID, OTHQUES, OTHOCC ) then
      { Otherwise initialize to blanks }
      OTHRESP = " ";
      OTHCODE = 0;
    endif;
    wothresp = OTHRESP;
    wothcode = OTHCODE;
  end;

  { to customize questions involving husband/partner }  
  function relterms()              // relationship terms
    if A701 = 1 then
      partner = tr("husband")
	elseif AM401 = 1 then
      partner = tr("wife")
    elseif A701 = 2 | AM401 = 2 then
      partner = tr("partner")
    else
      partner = tr("partner"); // just in case
    endif;
  end;

  { to customize questions DV06 to DV16 in DV module }  
  function relterms2()              // relationship terms
    relprev = ( inunion = 1 | DV04 = 1 );
    rellast = "";
    relpast = tr("current");
    if !relprev then 
      rellast = tr("last") + " ";   // with a blank
      relpast = tr("last");         // without a blank
    endif;
    if A701 = 1 | A702 = 1 then     // only married, not living with
      partype = tr("husband");
    else	
      partype = tr("male partner");
    endif;
  end;

  { Function to convert a CMC code to a calendar row }
  function cmcrow( xcmc )
    if !(xcmc in calbeg:calend) then
      xrow = 0
    else
      xrow = calend-xcmc+1
    endif;
    cmcrow = xrow;
  end;

  { Function to convert a calendar row to a CMC code }
  function rowcmc( yrow )
    if !(yrow in 1:callen) then
      ycmc = 0
    else
      ycmc = calend-yrow+1
    endif;
    rowcmc = ycmc;
  end;

  { Function to generate month labels (mnthstr1) and years (year) based on a calendar row }
  { to be used when displaying error messages                                             }
  function MnthYear( yrow );
    ycmc   = rowcmc( yrow );
    month  = ( ycmc-1 ) % 12 + 1;
    mnthstr1 = GetLabel( AINTM, month );
    year   = int( (ycmc-1)/12 ) + 1900;
  end;

  { Function to check all possible combinations of day, month and year of vaccination in section 5 }
  function vcheck( vcheckd, vcheckm, vchecky )
    recode  vchecky         :: vcheckm               :: vcheckd    -> x;       { !!! }
                       9998 :: 98                    :: 98         -> 1; { can't all be 98's - would use 44 in that case }
        2015:2025,9997,9998 :: 1,3,5,7,8,10,12,97,98 :: 1:31,97,98 -> 0;
        2015:2025,9997,9998 :: 4,6,9,11              :: 1:30,97,98 -> 0;
        2015:2025,9997,9998 :: 2                     :: 1:28,97,98 -> 0;
        2016,2020,2024      :: 2                     :: 29         -> 0;       { Leap year }
                 6666       :: 66                    :: 66         -> 0;
                 4444       :: 44                    :: 44         -> 0;
                    0       :: 0                     :: 0          -> 0;
                            ::                       ::            -> 1;
    endrecode;
    if vchecky < 2050 & vchecky > AINTY then
	  x = 2
    elseif vchecky = AINTY & vcheckm <= 12 & vcheckm > AINTM then
      x = 2
    elseif vchecky = AINTY & vcheckm = AINTM &
           vcheckd <= 31 & vcheckd > AINTD then
      x = 2
    endif;
    vcheck = x;
	if x then
	  errmsg( 4470, vcheckd, vcheckm, vchecky );
      reenter;
    endif;
  end;

  { check that a given date is greater or equal to child's date of birth }
  function vckbirth( vcheckd, vcheckm, vchecky, chidx )
    vcheckx = 0;
    if vchecky in 2015:2025 & A220Y(chidx) in 2015:2025 & vchecky < A220Y(chidx) then
      vcheckx = 1
    elseif vchecky in 2015:2025 & vchecky = A220Y(chidx) &
           vcheckm in 1:12 & A220M(chidx) in 1:12 & vcheckm < A220M(chidx) then
      vcheckx = 1
    elseif vchecky in 2015:2025 & vchecky = A220Y(chidx) &
           vcheckm in 1:12 & A220M(chidx) = vcheckm &
           vcheckd in 1:31 & A220D(chidx) in 1:31 & vcheckd < A220D(chidx) then
      vcheckx = 1
    endif;
    vckbirth = vcheckx;
	if vcheckx then
      errmsg( 4471, vcheckd, vcheckm, vchecky, A503, A220D(A503), A220M(A503), A220Y(A503) );
      reenter;
    endif;
  end;

  { function to know if a vaccination was given – excludes 66 }
  function vacgiven( xvar )
    if xvar in 1:31,44,97,98 then
      vacgiven = 1
    else
      vacgiven = 0
    endif;
  end;

  { function to check if the current pregnancy is a love birth or not }
  function livebirth();
    livebirth = (A216 = 1 | A216 = 2 & A217 = 1);
  end;

  { function to renumber the rows of the pregnancy history when insertion or deletion takes place }
  function renum_pregs()
    do i = 1 while i <= maxchild
      if i <= A212W then
        A215L(i) = i;
		APLINE(i) = i;
      else
        A215L(i) = notappl;        { blank out unused lines }
		APLINE(i) = notappl;
      endif;
    enddo;
  end;

  { function to insert a new pregnancy into the pregnancy history before the occurrence given in pocc }
  function insert_preg( pocc )
    numeric occno;
	goback222 = (pocc>A212W); // if adding after last then need to go back to A222 after adding - used in PROC A222A
    if moving | // if we are moving a pregnancy the message has already been displayed
       accept( maketext(2400+goback222), tr("Yes"), tr("No") ) = 1 then // otherwise display message to insert before pregnancy (2400), or after the last pregnancy (2401)

	  // reset 222 if insertion was because of 222, saving the information that A222 = 1 was used. Needs to be done before the insertion.  Similar for 229.
	  if lastfield = "A222" & A222 = 1 then
	    A222W(A215L) = 1;
		A222 = 2;
	  elseif lastfield = "A222A" & A222A = 1 then
	    A222AW = 1;
		A222A = 2;
	  endif;

	  // remove the 24th pregnancy first to avoid an error message
      if totocc( AWSEC2B_ROSTER1 ) = maxchild then delete( AWSEC2B_ROSTER1(maxchild) ) endif; { needed as totocc is set to the maximum for Partial save in add mode }
      if totocc( AWSEC2B_ROSTER2 ) = maxchild then delete( AWSEC2B_ROSTER2(maxchild) ) endif; { needed as totocc is set to the maximum for Partial save in add mode }
	  // insert the new pregnancy entry in roster 1
      insert( AWSEC2B_ROSTER1(pocc) );
	  A215L(pocc) = pocc;
	  // and in roster 2 if that has been started
	  if !special( visualvalue(A223(pocc)) ) then // check this works
        insert( AWSEC2B_ROSTER2(pocc) );
		APLINE(pocc) = pocc;
	  endif;

	  // increase the total number of pregnancies
	  inc( A212W );
	  // renumber all of the pregnancies
	  renum_pregs();

	  // and in Android, reset the occurence labels
	  if android then
	    // get the occurence number for the last one used
	    do occno = pocc while !special( visualvalue( A215L(occno) ) ) enddo; 
        inc( occno, -1 );
		// shift all of the occurence labels up by 1
  	    while occno > pocc do
	      setocclabel( AWSEC2B_ROSTER1(occno), getocclabel( AWSEC2B_ROSTER1(occno-1) ) );
	      setocclabel( AWSEC2B_ROSTER2(occno), getocclabel( AWSEC2B_ROSTER1(occno-1) ) );
          inc( occno, -1 );
	    enddo;
		// add in the new occurence labels
	    setocclabel( AWSEC2B_ROSTER1(pocc), maketext("%d",pocc) );
	    setocclabel( AWSEC2B_ROSTER2(pocc), maketext("%d",pocc) );
	  endif;

	  // just to blank out the field as the current value is often left behind
	  setvalue( lastfield, notappl, pocc); 

	  // if not moving pregnancies (i.e. just inserting) then move to the first field
	  if !moving then
        display(tr("Pregnancy inserted")); // included to force correct display of the screen
	    if goback222 then
		  move to A222(pocc-1) // go back to A222 as we can't go to A215 or A215L for a new occurence, when adding on the end of the roster
		else
	      move to A215L(pocc)
		endif;
	  endif;
	elseif !moving then
	  // reset 222 or 229 before moving on if needed.
	  if lastfield = "A222" & A222 = 1 then
	    A222 = 2;
	  elseif lastfield = "A222A" & A222A = 1 then
	    A222A = 2;
	  endif;
    endif;
  end;

  { function to date a pregnancy from the pregnancy history at the occurrence given in pocc }
  function delete_preg( pocc )
    numeric occno;
    if moving | // if we are moving a pregnancy the message has already been displayed
	   // otherwise display message to delete pregnancy
	   accept( maketext( 2402, strip(A218), getlabel(A220M, visualvalue(A220M)), visualvalue(A220Y) ),
               maketext( tr("Yes, delete the pregnancy of %s in %s %d"), strip(A218), getlabel(A220M, visualvalue(A220M)), visualvalue(A220Y) ),
                         tr("No, make no change") ) = 1 then
	  // delete the pregnancy in roster 1 and roster 2
      delete( AWSEC2B_ROSTER1(pocc) );
	  if !special( visualvalue(A223(pocc)) ) then
        delete( AWSEC2B_ROSTER2(pocc) );
	  endif;
	  // decrease the total number of pregnancies
	  if A212W > 0 & A212W > A212 then
        inc( A212W, -1 );
	  endif;
	  // renumber all of the pregnancies
	  renum_pregs();
	  // and in Android, reset the occurence labels
	  if android then 
		// shift all of the occurence labels up by 1
	    do occno = pocc while !special( visualvalue( A215L(occno) ) ) 
	      setocclabel( AWSEC2B_ROSTER1(occno), getocclabel( AWSEC2B_ROSTER1(occno+1) ) );
	      setocclabel( AWSEC2B_ROSTER2(occno), getocclabel( AWSEC2B_ROSTER1(occno+1) ) );
	    enddo;
	  endif;

	  // if not moving pregnancies (i.e. just deleting) then move to the first field of the next pregnancy
	  if !moving then
        display(tr("Pregnancy deleted")); // included to force correct display of the screen
	    if special( visualvalue(A215L(pocc)) ) then
		  if pocc = 1 then
		    move to A214 // no more pregnancies left so move back to A214
		  else
		    move to A215(pocc-1) // move back to the pregnancy before
		  endif;
		else
          move to A215L(pocc) advance // move to the pregnancy following
		endif;
	  endif;
    endif;
  end;

  { function to copy a pregnancy into the pregnancy history from the occurrence given in pocc1 into the occurrence given in pocc2 }
  function copy_preg( pocc1, pocc2 );
	A215 (pocc2) = visualvalue( A215 (pocc1) );
	A216 (pocc2) = visualvalue( A216 (pocc1) );
	A217 (pocc2) = visualvalue( A217 (pocc1) );
	A218 (pocc2) =              A218 (pocc1)  ;
	A219 (pocc2) = visualvalue( A219 (pocc1) );
	A220D(pocc2) = visualvalue( A220D(pocc1) );
	A220M(pocc2) = visualvalue( A220M(pocc1) );
	A220Y(pocc2) = visualvalue( A220Y(pocc1) );
	A221U(pocc2) = visualvalue( A221U(pocc1) );
	A221N(pocc2) = visualvalue( A221N(pocc1) );
	A222 (pocc2) = visualvalue( A222 (pocc1) );
	A222W(pocc2) = visualvalue( A222W(pocc1) );
	A223 (pocc2) = visualvalue( A223 (pocc1) );
	A224 (pocc2) = visualvalue( A224 (pocc1) );
	A225 (pocc2) = visualvalue( A225 (pocc1) );
	A226 (pocc2) = visualvalue( A226 (pocc1) );
	A227 (pocc2) = visualvalue( A227 (pocc1) );
	A228U(pocc2) = visualvalue( A228U(pocc1) );
	A228N(pocc2) = visualvalue( A228N(pocc1) );
  end;

  { function to move a pregnancy in the pregnancy history from the occurrence given in pocc1 before the occurrence given in pocc2 }
  { uses insert_preg, copy_preg, delete_preg, renum_pregs to move the pregnancy }
  function move_preg( pocc1, pocc2 )
    if pocc2 < 1 | pocc2 >= pocc1 then
      display( tr("No change made") );
    elseif accept( maketext( 2403, strip(A218), getlabel(A220M, visualvalue(A220M)), visualvalue( A220Y ), 
	                      strip( A218(pocc2) ), getlabel(A220M, visualvalue(A220M(pocc2))), visualvalue( A220Y(pocc2) ) ),
                   maketext(tr("Yes, move the pregnancy of %s in %s %d before the pregnancy of %s in %s %d"),
  				          strip(A218), getlabel(A220M, visualvalue(A220M)), visualvalue( A220Y ), 
				          strip(A218(pocc2)), getlabel(A220M, visualvalue(A220M(pocc2))), visualvalue( A220Y(pocc2) ) ),
                   tr("No, make no change") ) = 1 then
      moving = 1;						
      insert_preg( pocc2 );
      if pocc1 > pocc2 then inc( pocc1 ) endif;
      copy_preg( pocc1, pocc2 );
      delete_preg( pocc1 );
      renum_pregs();
      display(tr("Pregnancy moved")); // included to force correct display of the screen
	  moving = 0;
      move to A215L(pocc2) advance;
	endif;
  end;

  { function to display the pregnancy history and select a particular pregnancy, possibly excluding a certain pregnancy }
  function select_preg(exclude_occ);
	select_preg = show( tr("Select the pregnancy to move the current pregnancy before"),
	                    ccIN80.AWSEC2B, A218, A216, A219, A220, A224, A225
      title( tr("Name"), tr("Outcome"), tr("Sex"), tr("Date"), tr("Alive"), tr("Age") ) where A215L <> exclude_occ );
  end;

  { Popup for adding, inserting, deleting, moving pregnancies, or showing the pregnancy history }
  function preg_tools()
    numeric newocc;
    lastfield = getsymbol();
    if getrecord( lastfield ) = "AWSEC2B" then
      x = accept( tr("Pregnancies"),
	              tr("Insert pregnancy before current pregnancy"),
				  tr("Delete current pregnancy"),
				  tr("Move current pregnancy"),
				  tr("Cancel") );
      if     x = 1 then insert_preg( curocc() );
	  elseif x = 2 then delete_preg( curocc() );
	  elseif x = 3 then newocc = select_preg( curocc() ); 
	                    move_preg( curocc(), newocc );
	  elseif x in 0,4 then // do nothing
	  endif;
	else // just show the roster
      showroster(1)
	endif;
  end;

  { Copy the value from a prior twin for numeric fields }
  function copytwin(xval, nocc)
    n = nocc;
    numeric val = notappl;
    string var = getsymbol();         // get the name of the field we are on
    if special(xval) then             // check if there is already a value in the field
      do i = n-1 while i by (-1)      // loop over the other pregnancies
        if twincode(A404(n)) > 0 & twincode(A404(n)) = twincode(A404(i))-(n-i) then // twin of the same pregnancy
          val = getvalue(var, i);     // get the value from the twin
          if !special(val) then       // the same variable for the twin has a response
            setvalue(var, val, n);    // set the code to the same as the twin
            break;                    // found a value for this twin and set the variable, so break out of the loop
          endif;
        endif;
      enddo;
    endif;
    copytwin = (!special(val));
  end;

  { Copy the value from a prior twin for alpha fields }
  function copytwin_a(string xval, nocc)
    n = nocc;
    string val = "";
    string var = getsymbol();          // get the name of the field we are on
    if length(strip(xval)) = 0 then    // check if there is already a value in the field
      do i = n-1 while i by (-1)       // loop over the other pregnancies
        if twincode(A404(n)) > 0 & twincode(A404(n)) = twincode(A404(i))-(n-i) then // twin of the same pregnancy
          val = getvaluealpha(var, i); // get the value from the twin
          if length(strip(val)) then   // the same variable for the twin has a response
            setvalue(var, val, n);     // set the code to the same as the twin
            break;                     // found a value for this twin and set the variable, so break out of the loop
          endif;
        endif;
      enddo;
    endif;
    copytwin_a = (length(strip(val)) > 0);
  end;

  { function to check certain key combinations and disable them, also enables Ctrl-I, Ctrl-D, Ctrl-M. 
    Also captures the last field in use }
  function OnKey( I_Key )
    numeric newocc;
    lastfield = getsymbol(); // used in a number of other procs - keep this here
	if I_key in 114,2114,115,116 then { F3, Ctrl-F3, F4, F5 - block these }
	  I_key = 0;
	endif;
    if I_Key in {114,2114,}2073 then { F3, Ctrl-F3, Ctrl-I - insert }
      if getrecord( lastfield ) = "AWSEC2B" then
        insert_preg( curocc() );
	  endif;
	  I_key = 0;
    elseif I_Key in {115,}2068 then { F4, Ctrl-D - delete }
      if getrecord( lastfield ) = "AWSEC2B" then
        delete_preg( curocc() );
	  endif;
	  I_key = 0;
    elseif I_Key in {116,}2068 then { F5, Ctrl-M - move }
      if getrecord( lastfield ) = "AWSEC2B" then
	    select_preg( curocc() ); 
		newocc = showroster(1); 
		move_preg( curocc(), newocc );
	  endif;
	  I_key = 0;
	endif;
	Onkey = I_key;
  end;

  { function to get the position that the current source of method }
  { occupies in the string of sources in calendar for column 3     }
  function calsource()
    temp = A322;
    if A307N in stermeth,stermetm then
      temp = A312
    endif;
    recode temp   -> methpos;
           11:16  -> temp-10;  { public sector 1-6 }
           21:26  -> temp-14;  { private sector    }
           31:33  -> temp-18;  { other source      }
             96   -> 16;       { other             }
    endrecode;
    calsource = methpos;
  end;
  
  { displays calendar on call from toolbar }
  function showcal();
    numeric ycal, mcal;
    numeric cal_ctr;
    numeric cal_idx = 0;
	numeric preg;
    string str_year, str_month, str_disp;
    // fill calendar array from working calendar
    cal_array.clear();
    do cal_ctr = 1 until cal_ctr > 72
      if cal_ctr < cmcrow(di)  then // don't show rows after date of interview
        next;
      endif;
      inc(cal_idx);
      ycal = int(cal_ctr/12);
      mcal = cal_ctr % 12;
      if !mcal then mcal = 12 endif;
      if cal_idx = 1 | mcal = 7 then
        str_year = edit("9999", calendy - ycal );
      elseif mcal = 12 then
        str_year = "____";
      else
        str_year = "";
      endif;
      // set up strings to display current episode rows
      if disp1 <> notappl then
        if disp1 = 72 then inc(disp1) endif; // if beginning of calendar move arrow 1 row back
        if     cal_ctr = disp1-1 then str_disp = ">>"
        elseif cal_ctr in disp2+2:disp1-2 then str_disp = "||"
        elseif cal_ctr = disp2+1 then str_disp = "<<"
        else str_disp = "";
        endif;
      endif;
      str_month = months_array(mcal);
      cal_array(cal_idx,1) = str_year;
      cal_array(cal_idx,2) = str_month;
      cal_array(cal_idx,3) = edit("99", cal_ctr);
      cal_array(cal_idx,4) = str_disp;
      cal_array(cal_idx,5) = ACAL1[cal_ctr:1];
      cal_array(cal_idx,6) = ACAL2[cal_ctr:1];
	  cal_array(cal_idx,7) = "";
	  if cal_array(cal_idx,5) in codeb,codet then
	    do preg = totocc(AWSEC2B_ROSTER1) while preg > 0 by (-1)
          calcmc = rowcmc(cal_ctr);
          if calcmc in ldc(preg):udc(preg) then
		    cal_array(cal_idx,7) = strip(A218(preg));
		    break;
		  endif;
		enddo;
	  elseif cal_array(cal_idx,6) <> "" then
	    cal_array(cal_idx,7) = getlabel(ACAL_VS2,cal_array(cal_idx,6));
	  elseif !cal_array(cal_idx,5) in "" & cal_ctr < 72 & ACAL1[cal_ctr:1] <> ACAL1[cal_ctr+1:1] then
	    cal_array(cal_idx,7) = getlabel(ACAL_VS1,cal_array(cal_idx,5));
	  endif;
    enddo;
    // show calendar array
    showarray (tr("Calendar"), cal_array, cal_idx, title(tr("Year"), tr("Month"), tr("Row"), 
	           tr("Episode"), tr("Use"), tr("Disc"), tr("Label")));
  end;

  { function to assign births, current pregnancy and terminations to calendar }
  function FillC1Cal( event )
    { blank out working calendar column 1 }
    do i = 1 while i <= callen
      ACAL1[i:1] = " ";
      birthrow(i) = 0;
    enddo;
    { assign pregnancies outcomes along with pregnancy durations }
    do i = 1 while i <= totocc( AWSEC2B_ROSTER1 )
      if ALAST5(i) then
        xrow = cmcrow( ldc(i) );    { assign birth }
        pregtype = (A216(i) = 1 | A216(i) = 2 & A217(i) = 1);
		if pregtype then
          ACAL1[xrow:1]  = codeb;
		else
          ACAL1[xrow:1]  = codet;
		endif;
        birthrow(xrow) = A215L(i);
        do j = xrow + 1 while j <= callen & j <= xrow+A221DUR(i)-1   { assign pregnancies }
          ACAL1[j:1]  = codep;
          birthrow(j) = A215L(i);    { number of birth in calendar row j }
        enddo;
      endif;
    enddo;
    { assign current pregnancy along with its duration }
    if event >= 2 & A232 = 1 & !special(A233N) then
      do i = calint while i <= calint+A233DUR-1    { first check that there are no data collisions }
        if ACAL1[i:1] <> " " then
          MnthYear( i );
          errmsg(82283, mnthstr1, year) select( tr("Currently pregnant"), A232, tr("Duration of pregnancy"), A233_BLOCK);
        endif;
      enddo;
      do i = calint while i <= calint+A233DUR-1    { second assign pregnancies to calendar }
        ACAL1[i:1]  = codep;
        birthrow(i) = 77;           { code 77 is pregnancy in calendar row i }
      enddo;
    endif;
  end;

  { function to assign current method to the calendar based on date started using }
  function col1currm( cmcstart )
    if cmcstart >= calbeg then
      upto = cmcrow( cmcstart );
    else
      upto = callen;
    endif;
    meth    = MethInStr( A307N, methoth );
    onemeth = methstr[meth:1];            { to check date started using any method }
    i = calint;
    while i <= callen & i <= upto do
      if ACAL1[i:1] = codeb | ACAL1[i:1] = codet then
        if i < upto then
          MnthYear( i );
          if ACAL1[i:1] = codeb then
		    if meth in stermeth, stermetm then
              errmsg( 83132, mnthstr1, year )
			    select( tr("Date started using") + " " + getlabel( A307N, meth ), A313_BLOCK,
				        tr("Current method"), A307 );
			else
              errmsg( 83132, mnthstr1, year )
			    select( tr("Date started using") + " " + getlabel( A307N, meth ), A314_BLOCK,
				        tr("Current method"), A307 );
			endif;
          else
		    if meth in stermeth, stermetm then
              errmsg( 83133, mnthstr1, year )
			    select( tr("Date started using") + " " + getlabel( A307N, meth ), A313_BLOCK,
				        tr("Current method"), A307 );
			else
              errmsg( 83133, mnthstr1, year )
			    select( tr("Date started using") + " " + getlabel( A307N, meth ), A314_BLOCK,
				        tr("Current method"), A307 );
			endif;
          endif;
        endif;
        i = i + 1;
        while i <= callen & i <= lds & ACAL1[i:1] = codep do
          i = i + 1;
        enddo;
        i = i - 1;
      else
        ACAL1[i:1] = onemeth;
      endif;
      i = i + 1;
    enddo;
  end;

  { function to identify the beginning and end of an interval between pregnancies or terminations }
  { going from the month of the interview down.  The function establishes two global variables    }
  { endrowint : the row where the open interval ends                                              }
  { begrowint : the row where the open interval begins                                            }
  function goingdown( rowbeg, occur )
    { find the beginning of the episode }
    calcode = ACAL1[rowbeg:1];
    endevent = rowbeg;
    cmcend = rowcmc( endevent );
    ACAUXM2(occur) = ( cmcend-1 ) % 12 + 1;
    ACAUXY2(occur) = int( (cmcend-1)/12 ) + 1900;
    do i = rowbeg while i <= callen & ACAL1[i:1] = calcode
    enddo;
    if i <= callen then
      begevent = i - 1;
      cmcbeg = rowcmc( begevent );
      ACAUXM1(occur) = ( cmcbeg-1 ) % 12 + 1;
      ACAUXY1(occur) = int( (cmcbeg-1)/12 ) + 1900;
    else
      begevent = callen;
      cmcbeg = rowcmc( begevent );
      ACAUXM1(occur) = ( cmcbeg-1 ) % 12 + 1;
      ACAUXY1(occur) = int( (cmcbeg-1)/12 ) + 1900;
    endif;
    endrowint = endevent;
    begrowint = begevent;
    { display( "going down occur=%02d rowbeg=%02d endevent=%d begevent=%d", occur, rowbeg, endrowint, begrowint ); }
  end;

  { clean the remains of the event to properly back-tab within the calendar }
  { the cleaning begins in the month following the episode until endrowint  }
  { endrowint : the row where the open interval ends                        }
  function CleanCal( rowbeg, occur )
    { display( "cleaning rowbeg=%04d endevent=%d", rowbeg, ACFEVENT(occur) ); }
    do i = rowbeg while i >= ACFEVENT(occur) by (-1)
      ACAL1[i:1] = " ";
      ACAL2[i:1] = " ";
    enddo;
  end;

  { function to close the gap between events }
  { going from the beginning of the event towards the month of the interview }
  function goingup( rowbeg, occur )
    { find the beginning of the episode }
    calcode = ACAL1[rowbeg-1:1];
    cmcbeg = rowcmc( rowbeg );
    ACAUXM1(occur) = ( cmcbeg ) % 12 + 1;
    ACAUXY1(occur) = int( (cmcbeg )/12 ) + 1900;
    do i = rowbeg-1 while i >= calint & ACAL1[i:1] = calcode by (-1)
    enddo;
    endevent = i + 1;
    cmcend = rowcmc( endevent );
    ACAUXM2(occur) = ( cmcend-1 ) % 12 + 1;
    ACAUXY2(occur) = int( (cmcend-1)/12 ) + 1900;
   { display( "going up occur=%02d Episode-begin=%d Episode-end=%d", occur, rowbeg, endevent ); }
  end;

  { function to customize text for the first part of the question for contraceptive use episodes }
  function textbegin( occur )
    cmcend = cmcode( A317AM(occur), A317AY(occur) );
    xrow   = cmcrow( cmcend );
//    display( "Row Begin=%d", xrow ); 
    if xrow >= callen then
      event1 = tr("(the beginning of the calendar)") + " ";
    elseif !pos( ACAL1[xrow+1:1], pregstr ) then
      if pos( ACAL1[xrow+1:1], methstr ) then
        event1 = tr("the time when you were using the") + " " + GetLabel(A317C, ACAL1[xrow+1:1]);
      elseif xrow = calint & ACAL1[calint:1] = " " then
        event1 = tr("the month of the interview") + " ";
      else
        event1 = tr("the time when you were not using any method") + " ";
      endif;
    else
      if ACAL1[xrow+1:1] = codet then
        event1 = tr("the time when the") + " " + strip(A218(birthrow(xrow+1))) + " " + tr("ended");
      elseif ACAL1[xrow+1:1] = codeb then
        event1 = tr("the time when") + " " + strip(A218(birthrow(xrow+1))) + " " + tr("was born") + " ";
      elseif ACAL1[calint:1] = " " then
        event1 = tr("the month of the interview") + " ";
      elseif i < calint then
        event1 = tr("the time when the current pregnancy started") + " ";
      else
        event1 = tr("has an undefined error") + " ";
      endif;
    endif;
  end;

  { function to customize text for the second part of the question for contraceptive use episodes }
  function textend( occur )
    cmcbeg = cmcode( ACAUXM2(occur), ACAUXY2(occur) );
    xrow   = cmcrow( cmcbeg );
    { display( "Row=%d End=%02d/%04d", xrow, ACAUXM2(occur), ACAUXY2(occur) ); }
    if xrow-1 <= calint then
      event2 = tr("the month of the interview") + " ";
    elseif pos( ACAL1[xrow-1:1], pregstr ) then
      do i = xrow-1 while i >= calint & pos( ACAL1[i:1], pregstr ) by (-1)
      enddo;
      if ACAL1[i+1:1] = codeb then
        event2 = tr("the start of the pregnancy of") + " " + A218(birthrow(i+1));
      elseif ACAL1[i+1:1] = codet then
        event2 = tr("the start of the pregnancy that ended in") + " " + A218(birthrow(i+1)) + " ";
      elseif ACAL1[i+1:1] = codep then
        event2 = tr("the start of the current pregnancy") + " ";
      endif;
    elseif pos( ACAL1[xrow-1:1], methstr ) then
      event2 = tr("when you started to use the") + " " + GetLabel(A317C, ACAL1[xrow-1:1]);
    else
      event2 = tr("when you were not using any method") + " ";
    endif;
  end;

  { function to handle the drinks popup for A636 }
  function drinkgroups()
    foodfield = getsymbol();
	drinks_popup = 1;
	move to A636Z;
  end;

  { function to handle the foods popup for A637 }
  function foodgroups()
    foodfield = getsymbol();
	foods_popup = 1;
	move to A637Z;
  end;
  
  { function to handle the food and drinks popup for A643 }
  function foodgroupsW()
    foodfield = getsymbol();
	foods_popupW = 1;
	move to A643Z;
  end;

  { function to display the relevant food and drinks popup for A636, A637, or A643 }
  function fooddrinks()
    foodfield = getsymbol();
    if accept(tr("Display food or drink categories"),tr("Yes"),tr("No")) = 1 then
      if     pos("A636",foodfield) & length(foodfield) = 5 & foodfield[5:1] in "A":"X" then drinkgroups()
      elseif pos("A637",foodfield) & length(foodfield) = 5 & foodfield[5:1] in "A":"X" then foodgroups()
      elseif pos("A643",foodfield) & length(foodfield) = 5 & foodfield[5:1] in "A":"X" then foodgroupsW()
	  else   display(tr("No food or drink categories exist for this question"))
	  endif;
	endif;
  end;

  array string vacc_array(20,3);
  { function to prepare an array of vaccinations and their dates for display (and selection for reentry) }
  function getvaccs(vc);
    { array elements:
	  1 - Name of vaccination
	  2 - Date of vaccination
	  3 - Name of variable for reentry
	}
    numeric v = 0;
	inc(v); vacc_array(v,3) = "D509B"  ; vacc_array(v,1) = "BCG"                            ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509B  (vc)), visualvalue(M509B  (vc)), visualvalue(Y509B  (vc)) );
	inc(v); vacc_array(v,3) = "D509H"  ; vacc_array(v,1) = "Hep.B at birth"                 ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509H  (vc)), visualvalue(M509H  (vc)), visualvalue(Y509H  (vc)) );
	inc(v); vacc_array(v,3) = "D509P0" ; vacc_array(v,1) = "Oral Polio at birth (OPV0)"     ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509P0 (vc)), visualvalue(M509P0 (vc)), visualvalue(Y509P0 (vc)) );
	inc(v); vacc_array(v,3) = "D509P1" ; vacc_array(v,1) = "Oral Polio (OPV) 1"             ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509P1 (vc)), visualvalue(M509P1 (vc)), visualvalue(Y509P1 (vc)) );
	inc(v); vacc_array(v,3) = "D509P2" ; vacc_array(v,1) = "Oral Polio (OPV) 2"             ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509P2 (vc)), visualvalue(M509P2 (vc)), visualvalue(Y509P2 (vc)) );
	inc(v); vacc_array(v,3) = "D509P3" ; vacc_array(v,1) = "Oral Polio (OPV) 3"             ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509P3 (vc)), visualvalue(M509P3 (vc)), visualvalue(Y509P3 (vc)) );
	inc(v); vacc_array(v,3) = "D509IPV"; vacc_array(v,1) = "Inactivated Polio Vaccine (IPV)"; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509IPV(vc)), visualvalue(M509IPV(vc)), visualvalue(Y509IPV(vc)) );
	inc(v); vacc_array(v,3) = "D509D1" ; vacc_array(v,1) = "DPT-Hep.B-Hib (Pentavalent) 1"  ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509D1 (vc)), visualvalue(M509D1 (vc)), visualvalue(Y509D1 (vc)) );
	inc(v); vacc_array(v,3) = "D509D2" ; vacc_array(v,1) = "DPT-Hep.B-Hib (Pentavalent) 2"  ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509D2 (vc)), visualvalue(M509D2 (vc)), visualvalue(Y509D2 (vc)) );
	inc(v); vacc_array(v,3) = "D509D3" ; vacc_array(v,1) = "DPT-Hep.B-Hib (Pentavalent) 3"  ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509D3 (vc)), visualvalue(M509D3 (vc)), visualvalue(Y509D3 (vc)) );
	inc(v); vacc_array(v,3) = "D509D4" ; vacc_array(v,1) = "DPT-Hep.B-Hib (Pentavalent) 4"  ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509D4 (vc)), visualvalue(M509D4 (vc)), visualvalue(Y509D4 (vc)) );
	inc(v); vacc_array(v,3) = "D509N1" ; vacc_array(v,1) = "Pneumococcal 1"                 ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509N1 (vc)), visualvalue(M509N1 (vc)), visualvalue(Y509N1 (vc)) );
	inc(v); vacc_array(v,3) = "D509N2" ; vacc_array(v,1) = "Pneumococcal 2"                 ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509N2 (vc)), visualvalue(M509N2 (vc)), visualvalue(Y509N2 (vc)) );
	inc(v); vacc_array(v,3) = "D509N3" ; vacc_array(v,1) = "Pneumococcal 3"                 ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509N3 (vc)), visualvalue(M509N3 (vc)), visualvalue(Y509N3 (vc)) );
	inc(v); vacc_array(v,3) = "D509R1" ; vacc_array(v,1) = "Rotavirus 1"                    ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509R1 (vc)), visualvalue(M509R1 (vc)), visualvalue(Y509R1 (vc)) );
	inc(v); vacc_array(v,3) = "D509R2" ; vacc_array(v,1) = "Rotavirus 2"                    ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509R2 (vc)), visualvalue(M509R2 (vc)), visualvalue(Y509R2 (vc)) );
	inc(v); vacc_array(v,3) = "D509R3" ; vacc_array(v,1) = "Rotavirus 3"                    ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509R3 (vc)), visualvalue(M509R3 (vc)), visualvalue(Y509R3 (vc)) );
	inc(v); vacc_array(v,3) = "D509M1" ; vacc_array(v,1) = "Measles containing vaccine 1"   ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509M1 (vc)), visualvalue(M509M1 (vc)), visualvalue(Y509M1 (vc)) );
	inc(v); vacc_array(v,3) = "D509M2" ; vacc_array(v,1) = "Measles containing vaccine 2"   ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509M2 (vc)), visualvalue(M509M2 (vc)), visualvalue(Y509M2 (vc)) );
	inc(v); vacc_array(v,3) = "D509V"  ; vacc_array(v,1) = "Vitamin A (most recent)"        ; vacc_array(v,2) = maketext( "%02d/%02d/%04d", visualvalue(D509V  (vc)), visualvalue(M509V  (vc)), visualvalue(Y509V  (vc)) );
    getvaccs = v;
  end;

  { display the list of vaccinations prepared in the getvaccs function, and reenter if one is selected }
  function showvaccs(vc);
    numeric vacc, nvaccs;
    nvaccs = getvaccs(vc);
    vacc = showarray( maketext( "Vaccinations for %s. Select vaccination to modify or exit to continue", strip(A503N(vc)) ), vacc_array, nvaccs,
          title( tr("Vaccination"), tr("Date of vaccination") ) );
    if vacc then
	  string vaccstr = vacc_array(vacc,3);
	  reenter vaccstr;
	endif;
  end;
  
  { function to determine if a blood pressure is valid }
  function ValidBP( xvar )  
    x = 0;
    if xvar in 1:900 then
	  x = 1;
    endif;
    ValidBP = x;
  end;	
  
  { function to determine the blood pressure test result }
  function BloodResult( systolic, diastolic )  
  recode systolic  :: diastolic -> $;
          0:129    ::     <84   -> 1;
          0:129    ::   85:89   -> 2;
          0:129    ::   90:99   -> 3;
          0:129    ::  100:109  -> 4;
          0:129    ::  110:119  -> 5;
          0:129    ::           -> 6;
        130:139    ::     <90   -> 2;
        130:139    ::   90:99   -> 3;
        130:139    ::  100:109  -> 4;
        130:139    ::  110:119  -> 5;
        130:139    ::           -> 6;
        140:159    ::    <100   -> 3;
        140:159    ::  100:109  -> 4;
        140:159    ::  110:119  -> 5;
        140:159    ::           -> 6;
        160:179    ::    <110   -> 4;
        160:179    ::  110:119  -> 5;
        160:179    ::           -> 6;
        180:209    ::    <120   -> 5;
        180:209    ::           -> 6;
          >=210    ::           -> 6;
                   ::           -> 0;
    endrecode;
  end;
  
  { displays blood pressure result for reporting form } 
  function DisplayBloodResult( systolic, diastolic, ires);    
	textstr1 = tr("Read aloud to the respondent the following information: \n");
    textstr1 = textstr1 + maketext(tr("Your final blood pressure is: Systolic=%d Diastolic=%d\n"), systolic, diastolic);
	textstr1 = textstr1 + maketext(tr("Your blood pressure category is: %s"), toupper(BloodCat(ires))) + " ";
	textstr1 = textstr1 + maketext(tr("Consult health provider to check blood pressure within: %s"), toupper(BloodCon(ires))); 
	textstr1 = textstr1 + maketext(tr("\n\nCircle %d in the blood pressure reporting form and "), ires ); 
	textstr1 = textstr1 + tr("then give the form to the respondent and answer any questions the respondent may have.");
	putnote(textstr1);
	textstr1 = editnote();
  end;	
  
  { function to get the right score for depression variables }
  function ScorePHQ( xvar )  
    x = 0;
    if xvar in 1:3 then
	  x = xvar;
    endif;
    ScorePHQ = x;
  end;	

PROC CCIN80_FF
preproc

  { Get the system date to ensure the date is set up correctly }
  sday   = sysdate("dd");
  smonth = sysdate("mm");
  syear  = sysdate("yyyy");
  if CDCode(syear,smonth,sday) < CDCode(2021,1,1) then    { !!! Fix to minimum date of interview }
    errmsg( 0003, sday, smonth, syear );
    endlevel;
  endif;

  { Set the applications minimum and maximum parameters }
  alphalst = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

  { Set the application parameters }
  minab    = 120;                           { !!! minimum age at first birth in months - women }
  minam    = 96;                            { !!! minimum age at marriage in months - women }
  minabm   = 180;                           { !!! Minimum age at first birth in months at birth - men }
  minamm   = 144;                           { !!! minimum age at marriage in months - men }
  maxchild = 24;                            { !!! maximum number of children in birth history }
  max5     = 6;                             { !!! maximum number of births since '0? in section 4 & 5 }
  maxsib   = 20;                            { !!! maximum number of siblings in mat.mort. section }
  stermeth = 1;                             { Method number for female sterilization }
  stermetm = 2;                             { Method number for male   sterilization }
  yrspcare = 3;                             { !!! Number of years worth of pregnancies for pregnancy and postnatal section }
  yrsvacc  = 3;                             { !!! Number of years worth of births for immunization section }
  yrshlth  = 5;                             { !!! Number of years worth of births for child health }
  yrsfeed  = 2;                             { !!! Number of years used as cutoff for nutrition  }
  daughty  = 2005;                          { !!! Year used as cutoff for daughters to be included in the FGC roster }
  android  = (getos() = 20);                { !!! 1-to use application in android machine }

  calendy  = 2020;                          { !!!! year when calendar ends }
  calbegy  = 2015;                          { !!!! Year when calendar begins }
  calend   = cmcode(12,calendy);            { last date of calendar }
  calbeg   = cmcode( 1,calbegy);            { first date of calendar }
  callen   = calend-calbeg+1;               { length of calendar }

  pregstr  = "BPT";                         { Codes for Birth, Pregnancy and Termination }
  codeb    = pregstr[1:1];
  codep    = pregstr[2:1];
  codet    = pregstr[3:1];
  methstr  = "123456789JKLMXY";             { !!! Codes for contraceptive methods in calendar }
  a307str  = "ABCDEFGHIJKLMXY";             { !!! Codes for contraceptive methods in A307    }
  am439str = "ABCDEFGHIJKLMXY";             { !!! Codes for contraceptive methods in AM418   }
  asource  = "123456789ABCDEFX";            { !!!! source of method, calendar column 3 }

  methoth  = 14;                            { !!! Occurrence number of "other" method }
  InEntry   = ( demode() = add | demode() = modify );   { it will essentially sets inEntry = 0 to properly run it in batch }

  orderstr(1) = tr("first twin");
  orderstr(2) = tr("second twin");
  orderstr(3) = tr("third twin");
  orderstr(4) = tr("fourth twin");
  orderstr(5) = tr("fifth twin");

  { converts parameter to numbers  }
  xintnum  = tonumber( sysparm()[1:4] );    { interviewer number }
  xsupnum  = tonumber( sysparm()[5:4] );    { supervisor number }
  xmodcent = tonumber( sysparm()[9:1] );    { modify by central office }
  xrvisit  = tonumber( sysparm()[10:1] );   { revisit }
  xmodify  = tonumber( sysparm()[11:1] );   { modify completed }
  xpartial = tonumber( sysparm()[12:1] );   { if case has been saved partially }
  xentryhw = tonumber( sysparm()[13:1] );   { enter height & weight data }
  xhhnum   = tonumber( sysparm()[14:4] );   { household number }
  xline    = tonumber( sysparm()[18:2] );   { individual line number }
  xteam    = tonumber( sysparm()[24:2] );   { team number }

  if !xmodify then
    YCLUSTER = tonumber( sysparm()[20:4] );
    if !loadcase( CLUSTERS, YCLUSTER ) then
      errmsg( 0001, YCLUSTER );
      endlevel
    endif;
  endif;

  { settings for CAPI }
  reviewsup = ( xmodcent & xmodify & xsupnum <> 0 );         { indicates supervisor is reviewing, therefore exit the application }
  if !xmodcent | reviewsup then                              { central office desn't have to exit after reviewing one HH }
    set behavior() exit on;
  endif;
  set attributes(ccIN80) assisted off (variable(title));
  
  { avoid radio buttons for months in blocks for android }
  if android then
    setproperty(A106M,   "CaptureType", "ComboBox" );
    setproperty(A110M,   "CaptureType", "ComboBox" );
    setproperty(A220M,   "CaptureType", "ComboBox" );
    setproperty(A313M,   "CaptureType", "ComboBox" );
    setproperty(A314M,   "CaptureType", "ComboBox" );
    setproperty(A317EM,  "CaptureType", "ComboBox" );
    setproperty(A317GM,  "CaptureType", "ComboBox" );
    setproperty(M509B,   "CaptureType", "ComboBox" );
    setproperty(M509H,   "CaptureType", "ComboBox" );
    setproperty(M509P0,  "CaptureType", "ComboBox" );
    setproperty(M509P1,  "CaptureType", "ComboBox" );
    setproperty(M509P2,  "CaptureType", "ComboBox" );
    setproperty(M509P3,  "CaptureType", "ComboBox" );
    setproperty(M509IPV, "CaptureType", "ComboBox" );
    setproperty(M509D1,  "CaptureType", "ComboBox" );
    setproperty(M509D2,  "CaptureType", "ComboBox" );
    setproperty(M509D3,  "CaptureType", "ComboBox" );
    setproperty(M509D4,  "CaptureType", "ComboBox" );
    setproperty(M509N1,  "CaptureType", "ComboBox" );
    setproperty(M509N2,  "CaptureType", "ComboBox" );
    setproperty(M509N3,  "CaptureType", "ComboBox" );
    setproperty(M509R1,  "CaptureType", "ComboBox" );
    setproperty(M509R2,  "CaptureType", "ComboBox" );
    setproperty(M509R3,  "CaptureType", "ComboBox" );
    setproperty(M509M1,  "CaptureType", "ComboBox" );
    setproperty(M509M2,  "CaptureType", "ComboBox" );
    setproperty(M509V,   "CaptureType", "ComboBox" );
    setproperty(A715M,   "CaptureType", "ComboBox" );
    setproperty(A719M,   "CaptureType", "ComboBox" );
    setproperty(A1023M,  "CaptureType", "ComboBox" );
    setproperty(A1025M,  "CaptureType", "ComboBox" );
    setproperty(A1029M,  "CaptureType", "ComboBox" );
    setproperty(AM106M,  "CaptureType", "ComboBox" );
    setproperty(AM110M,  "CaptureType", "ComboBox" );
    setproperty(AM411M,  "CaptureType", "ComboBox" );
    setproperty(AM714M,  "CaptureType", "ComboBox" );
    setproperty(AM718M,  "CaptureType", "ComboBox" );
  endif;

  { set font for value sets }
  setfont( ALL, "Arial", 16, bold );

  { set up minimal user bar }
  userbase();
  userbar( show );
  { set language at start of the program, defaulting to language passed by menu }
  setlanguage(loadsetting("Language", getlanguage()));

  responseloc( 1 );  // 1 = top left corner, under the questions, 2 = next to the field

postproc
  if !xmodcent then
    stop(1);
  endif;

PROC INDIVIDUAL
preproc
  if xmodify then
    advance to ACORRECT;
  endif;

postproc
  endlevel;

PROC ASECOVER_FORM
  if ARESULT <> 1 then
    { Check that questionnaire finished OK }
#if AppType(Entry)
    if endmess() then
      reenter ACORRECT
    endif;
    endlevel
#else
    skip case
#endif;
  endif;

PROC ACLUSTER
preproc
  { Set cluster and other geographical variables from CLUSTERS file }
  if demode() = add then
    $ = YCLUSTER;
    AREGION = YREGION;
	ATYPE   = YURBRUR;
  endif;

PROC ANUMBER
preproc
  if demode() = add then
    $ = xhhnum;
  endif;

postproc
  { loads household questionnaire }
  if !loadcase( ccHH80, ACLUSTER, ANUMBER ) then
    errmsg( 80006, ANUMBER, ACLUSTER );
    stop(1);
  endif;
  nhhold = hhm_array();
  userbar( add button, tr("Household"),   showroster(4) );

PROC ALINE
preproc
  if demode() = add then
    $ = xline;
  endif;
  
postproc
  id = edit("9999",ACLUSTER)+edit("9999",ANUMBER)+edit("99",ALINE);

PROC AVIOLEN
preproc
  { AHNUMDV is a variable in the household questionnaire }
  { indicating the woman who is selected for the DV module }
  if AHNUMDV = ALINE then
    $ = 1
  else
    $ = 2
  endif;

PROC AQTYPE
preproc
  $ = AH04(ALINE);
  
postproc  
  AQTYPET = GetValueLabel( $ );

PROC ANAME
preproc
  if !xmodify then
    $ = AH02( ALINE );
  endif;

PROC ACORRECT
  if $ <> 1 then
    stop(1);
  endif;

PROC AINTNUM
preproc
  if demode() = add then
    $ = xintnum;
  endif;

PROC ATEAM
preproc
  if demode() = add then
    $ = xteam;
  endif;

PROC ASUPERV
preproc
  if demode() = add then
    $ = xsupnum;
  endif;

PROC AVLINE
preproc
  n = curocc();
  { if in modify mode and result = NA skip }
  if xmodify & visualvalue(AVRESULT(n)) = notappl then
    skip to AINTD;
  { partial save with modification doesn't create a new visit }
  elseif xpartial = 2 & visualvalue($(n)) = notappl then
    skip to AINTD
  { assign new visit for add, partial save with add }
  elseif visualvalue( $(n) ) = notappl | n >= maxocc() then
    $ = n;
  { incomplete cases are called as if they were partially saved }
  { in addmode to generate an entry in visits table             }
  elseif xpartial = 1 & visualvalue( AVRESULT(n) ) <> 1 then
    advance to AVLINE(n+1);
  { change result code to postponed when partial visit to previous visit }
  elseif xpartial = 1 & visualvalue( $(n+1) ) = notappl then
    AVRESULT(n) = 3;
    advance to AVLINE(n+1);
  { revisit generates another entry in visit }
  elseif xrvisit then
    advance to AVLINE(n+1);
  endif;

PROC AVDAY
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    $ = sysdate( "dd" );
  endif;

PROC AVMONTH
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    $ = sysdate( "mm" );
  endif;

PROC AVYEAR
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    $ = sysdate( "YYYY" );
  endif;

PROC AVHOUR
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    time = systime();
    $ = int( time/10000 );
  endif;

PROC AVMINUTE
preproc
  n = curocc();
  if visualvalue( $(n) ) = notappl then
    time = systime();
    $ = int( time/100 ) % 100;
  endif;

PROC AVRESULT
preproc
  n = curocc();
  oldval = visualvalue( $(n) );
  { a partial case in addmode is assigned a completed interview }
  if ( oldval = notappl | n >= maxocc() ) & xpartial = 1  then
    $ = 1;
  endif;

onfocus
  n = curocc();
  oldval = visualvalue( $(n) );

postproc
  { Verify that household questionnaire was incomplete }
  if $ <> 1 & oldval in 1,notappl then
    if visualvalue(A101H) = notappl then
      warning( 0014 ) select( tr("Interview result"), $, tr("Continue"), continue );
    else
      warning( 0019 ) select( tr("Interview result"), $, tr("Continue"), continue );
    endif;
  endif;

  { Get Other Answer for result of household interview }
  if $ = 7 & oldval <> 7 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;
  n = curocc();
  if !xrvisit & n >= maxocc() then
    skip to AINTD;
  elseif !xrvisit & visualvalue( AVLINE(n+1) ) = notappl then
    skip to AINTD;
  elseif oldval = notappl then
    skip to AINTD;
  endif;

PROC AINTD
preproc
  if InEntry then
    n = totocc( AVISITS_ROSTER );
    $ = AVDAY( n );
  endif;	

PROC AINTM
preproc
  if InEntry then
    n = totocc( AVISITS_ROSTER );
    $ = AVMONTH( n );
  endif;	

PROC AINTY
preproc
  if InEntry then
    n = totocc( AVISITS_ROSTER );
    $ = AVYEAR( n );
  endif;	

PROC ARESULT
preproc
  if InEntry then
    $ = AVRESULT( n );
  endif;	

PROC AVISITS
preproc
  if InEntry then
    $ = totocc( AVISITS_ROSTER );
  endif;	

postproc
  { a partial save is forced for incomplete interviews to allow }
  { revisiting the woman in add mode                            }
  if !xmodcent & ARESULT <> 1 then
    savepartial( clear );
    stop(1);
  endif;

PROC ACONSENT_FORM
  if ARESULT <> 1 then
#if AppType(Entry)
    endlevel
#else
    skip case
#endif;
  endif;

PROC ACONSENT
preproc
  if ARESULT <> 1 & special(visualvalue($)) then
    endgroup
  elseif visualvalue($) = 1 then
    advance to A101H
  endif;

postproc
  n = totocc( AVISITS_ROSTER );
  if $ <> 1 then
    x = accept( tr("Please confirm that the result of this interview is a refusal"), 
	            tr("Yes, Refused"), tr("No, Consent given") );
    if x <> 1 then
      reenter
    endif;
    AVRESULT( n ) = 4;
    ARESULT       = 4;
    endgroup;
  elseif $ = 1 & AVRESULT(n) <> 1 then
    AVRESULT(n) = 1
  endif;

  { Initialize top row of calendar to use }
  di = cmcode( AINTM, AINTY );
  calint = cmcrow( di );            { first row to use of calendar }
  { calculate interview CDC }
  dicdc = CDCode( AINTY, AINTM, AINTD );
  { *** skip to men's background characteristics if men's interview }
  if AQTYPE = 1 then
    skip to AM101H
  endif;

PROC A101H
preproc
  if InEntry then
    n = totocc( AVISITS_ROSTER );
    $ = AVHOUR( n );
  endif;

PROC A101M
preproc
  if InEntry then
    n = totocc( AVISITS_ROSTER );
    $ = AVMINUTE( n );
  endif;
  
PROC A102
  if $ <> 96 then
    skip to A104
  endif;

PROC A103
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
PROC A104
  if $ = 96 & AH05(ALINE) = 1 then
    warning( 1031, AH05(ALINE) ) 
	  select( tr("Time living in place of interview"), $, tr("Continue"), continue );
  endif;
  if $ in 95,96 then
    skip to A110M
  elseif !$ in 0:4 then
    skip to A107
  endif;
  
PROC A106Y
  di = cmcode(AINTM, AINTY);
  if afterint(A106M,$,AINTM,AINTY) then
	errmsg( 89998 ) select( tr("Date moved here"), A106_BLOCK );
  endif;
  if validyr(A106Y) then
    temp = setub(A106M, A106Y, 9999);
	if int((di-temp)/12) <> A104 then
	  warning( 1035, A104 ) 
	    select( tr("Date moved here"), A106_BLOCK, 
	            tr("Years living in place of residence"), A104,
				tr("Continue"), continue );
	endif;
  endif;

PROC A109
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A111
  { Set up CMC for date of interview }
  di = cmcode(AINTM, AINTY);
  { Initial ranges for CMC date of birth }
  if validyr(A110Y) then
    ldb = setlb(A110M, A110Y, 0);
    udb = setub(A110M, A110Y, 9999);
  else
    ldb = di - 599;
    udb = di - 180;
  endif;

  { Check either year of birth or age given for all women }
  if !validyr(A110Y) & !valid($) then
    errmsg( 1060, A110M, A110Y, $ ) 
	  select( tr("Date of birth"), A110_BLOCK, 
	          tr("Age"), $ );
  { Compare age of woman with age in household to look for typos }
  elseif $ <> AH07(ALINE) & demode() = add then
    warning( 1061, $, AH07(ALINE) ) 
	  select( tr("Age"), $, 
	          tr("Continue"), continue );
  endif;

  { Adjust ranges for CMC date of birth based on age }
  if valid($) then
    { Lower bound of CMC }
    t = ndjlba(ldb, udb, di, di, $);
    if t < 0 then
      errmsg( 1062, A110M, A110Y, $, AINTM, AINTY ) 
	    select( tr("Date of birth"), A110_BLOCK, 
		        tr("Age"), $ ); 
    else
      ldb = t
    endif;
    { Upper bound of CMC }
    t = adjuba(ldb, udb, di, di, $);
    if t < 0 then
      errmsg( 1062, A110M, A110Y, $, AINTM, AINTY ) 
	    select( tr("Date of birth"), A110_BLOCK, 
		        tr("Age"), $ );
    else
      udb = t
    endif;
  endif;

  { calculate woman's age }
  agew = int( (di - ldb) / 12 );

  { checks duration of current residence against age }
  if A104 in 0:49 & A104 > agew then
    errmsg( 1030, A104 )
	  select( tr("Years living in place of residence"), A104, 
	          tr("Age"), $ );
  endif;

PROC A113
  if $ <> 1 then
    skip to A117
  endif;

PROC A114
  { Check education in individual questionnaire agrees with education in hh }
  if $ <> AH17A(ALINE) & demode() = add then
    warning( 1080, $, AH17A(ALINE) ) 
	  select( tr("Level of education" ), $, tr("Continue"), continue );
  endif;

PROC A115
onfocus
  grades.clear();
  grades.add(tr("Less than one year"), 0);
  n = maxgrade(A114);
  do i = 1 while i <= n
    grades.add(maketext("Year %d", i), i);
    // change the above to match the terms used in the country
    // e.g. it might be "Year" that is used in most levels, but "Form" is used in secondary schooling
    // if A114 = 2 then
    //   grades.add(maketext("Form %d", i), i);
    // else
    //   grades.add(maketext("Year %d", i), i);
    // endif;
  enddo;
  SetValueSet( $, grades );
  
postproc
  { Verify the maximum grade for the level }
  if !levelYears( A114, $ ) then
    errmsg( 1091 ) 
	  select( tr("Level of education"), A114, tr("Grade/year/form"), $ );
  endif;

  { Check education in individual questionnaire agrees with education in hh }
  if $ <> AH17B(ALINE) & demode() = add then
    warning( 1090, $, AH17B(ALINE) ) 
	  select( tr("Grade/year/form"), $, tr("Continue"), continue );
  endif;

PROC A117
preproc
  if A114 = 3 then
    skip to A119
  endif;

postproc
  if $ in 1,5 then
     skip to A120
  { Get Other Answer }
  elseif $ = 4 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A122
  if $ <> 1 then
    skip to A127
  endif;

PROC A127
  if $ <> 1 then
    skip to A130
  endif;

PROC A128
  if $ <> 1 then
    skip to A130
  endif;

PROC A130
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A131
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
PROC A201
  SaveData();
  if $ = 2 then
    skip to A206
  endif;

PROC A202
  if $ = 2 then
    skip to A204
  endif;

PROC A203B
  { Check for at least one child living at home - otherwise 202 must be 2 }
  if !A203A & !$ then
    errmsg( 2030 ) select( tr("Any children living at home"), A202, 
	                       tr("Number of children living at home"), A203_BLOCK );
  endif;

PROC A204
  if $ = 2 then
    skip to A206
  endif;

PROC A205B
  { Check for at least one child living away from home - otherwise 204 must be 2 }
  if !A205A & !$ then
    errmsg( 2030 ) select( tr("Any children living away"), A204, 
	                       tr("Number of children living away"), A205_BLOCK );
  endif;

PROC A206
  if $ = 2 then
    skip to A208
  endif;

PROC A207B
  { Check for at least one child to have died - otherwise 206 must be 2 }
  if !A207A & !$ then
    errmsg( 2030 ) select( tr("Any boys or girls who died"), A206, 
	                       tr("Number of boys or girls who died"), A207_BLOCK );
  endif;

PROC A208
preproc
  { Count up total children ever born }
  $  = NAtoZero(A203A)+NAtoZero(A203B)+
       NAtoZero(A205A)+NAtoZero(A205B)+
       NAtoZero(A207A)+NAtoZero(A207B);

postproc
  if $ = 0 & A201 = 1 then
    errmsg( 02080 ) select( tr("Any children ever born"), A201 );
  endif;

PROC A209
  if $ <> 1 then
    errmsg( 02090 ) select( tr("Check children ever born"), A201, 
	                        tr("Reconfirm number of children"), $ );
  endif;

PROC A210
  if $ <> 1 then
    skip to A212
  endif;

PROC A212
preproc
  numeric oldA212 = visualvalue(A212);
  { Count up total pregnancies }
  $  = NAtoZero(A208)+NAtoZero(A211);

postproc
  { Working version of total pregnancies - used instead of A212 from here on }
  if special(visualvalue(A212W)) | visualvalue(A212W) < A212 then 
    A212W = A212
  elseif A212 <> oldA212 then // new value for A212 - do we update A212W?
    // get a count of pregnancies currently entered
    numeric totpregs = 0;
    do i = 1 while i <= maxchild
      if !special( visualvalue( A215(i) ) ) | !special( visualvalue( A216(i) ) ) then // check A215 and A216 to see if they are not blank
           inc(totpregs);
      endif;
    enddo;
    if visualvalue(A212W) > A212 & totpregs > A212 then // check if there are currently more pregnancies entered than recorded in A212
      errmsg(2100, totpregs, A212) 
	  select( tr("Correct the number of pregnancies in A201-A212"), A201, 
	          tr("Continue to pregnancy history to remove the incorrect pregnancy"), continue )
    else // can safely reduce A212W if there are not already more pregnancies than reported in A212
      A212W = A212
    endif;
  endif;

PROC A212W
  if A212 = 0 then
    skip to ACAL1
  endif;

PROC AWSEC2B_FORM
preproc
  { Initialize line numbers of each pregnancy }
  do i = 1 while i <= maxchild
    calrow(i) = 0;              { row of calendar containing pregnancy }
  enddo;

onfocus
  if !preghid then
    preghid = userbar( add button, tr("Pregnancy history"), showroster( 1 ) );
  endif;
  if !pregsid then
    pregsid = userbar( add button, tr("Pregnancies"), preg_tools() ); // add userbar for pregnancies once we get to pregnacy history
  endif;

killfocus
  if pregsid then
    userbar(remove,pregsid);
	pregsid = 0;
  endif;

postproc
  n = noccurs(AWSEC2B);

  { Check counts of children living at home }
  ch = count( AWSEC2B where A219 = 1 & A224 = 1 & A226 = 1 );
  if lessthan( ch, A203A ) then
    errmsg( 02240, tr("Boys at home"), "A203A", A203A, ch )
      select( tr("Begin reproduction"), A201, 
	          tr("Begin pregnancy history"), A215(1) );
  endif;
  ch = count( AWSEC2B where A219 = 2 & A224 = 1 & A226 = 1 );
  if lessthan( ch, A203B ) then
    errmsg( 02240, tr("Girls at home"), "A203B", A203B, ch )
      select( tr("Begin reproduction"), A201, 
	          tr("Begin pregnancy history"), A215(1) );
  endif;

  { Check counts of children living away }
  ch = count( AWSEC2B where A219 = 1 & A224 = 1 & A226 = 2 );
  if lessthan( ch, A205A ) then
    errmsg( 02240, tr("Boys living away"), "A205A", A205A, ch )
      select( tr("Begin reproduction"), A201, 
	          tr("Begin pregnancy history"), A215(1) );
  endif;
  ch = count( AWSEC2B where A219 = 2 & A224 = 1 & A226 = 2 );
  if lessthan( ch, A205B ) then
    errmsg( 02240, tr("Girls living away"), "A205B", A205B, ch )
      select( tr("Begin reproduction"), A201, 
	          tr("Begin pregnancy history"), A215(1) );
  endif;

  { Check counts of children who have died }
  ch = count( AWSEC2B where A216 = 1 & A219 = 1 & A224 = 2 );
  if lessthan( ch, A207A ) then
    errmsg( 02240, tr("Boys who died"), "A207A", A207A, ch )
      select( tr("Begin reproduction"), A201, 
	          tr("Begin pregnancy history"), A215(1) );
  endif;
  ch = count( AWSEC2B where A216 = 1 & A219 = 2 & A224 = 2 );
  if lessthan( ch, A207B ) then
    errmsg( 02240, tr("Girls who died"), "A207B", A207B, ch )
      select( tr("Begin reproduction"), A201, 
	          tr("Begin pregnancy history"), A215(1) );
  endif;

  if A212W then
    { Checking of minimum interval between pregnancies }
    x = A212W - twincode(A212W) - (twincode(A212W) = 0);
    do i = 1 while i <= x
      j = i + 1;
      while twincode(j) > 1 do
        j = j + 1
      enddo;
      t = adjlbi( ldc(i), udc(i), ldc(j), udc(j), 7 );
      if t < 0 then
        warning( 2241, i, A220M(i), A220Y(i), j, A220M(j), A220Y(j) ) 
		  select( maketext( tr("Date of pregnancy") + " %d", i), A220_BLOCK(i),
		          maketext( tr("Date of pregnancy") + " %d", j), A220_BLOCK(j),
				  tr("Continue"), continue );
      else
        ldc(j) = t;
      endif;
      t = adjubi( ldc(i), udc(i), ldc(j), udc(j), 7 );
      if t < 0 then
        warning( 2241, i, A220M(i), A220Y(i), j, A220M(j), A220Y(j) ) 
		  select( maketext( tr("Date of pregnancy") + " %d", i), A220_BLOCK(i),
		          maketext( tr("Date of pregnancy") + " %d", j), A220_BLOCK(j),
				  tr("Continue"), continue );
      else
        udc(i) = t;
      endif;
    enddo;
  endif;

  { check that children declared as of respondent in HH are also declared in pregnancy history }
  do i = 1 while i <= AHMEMBER
    if AH13(i) = ALINE & count( AWSEC2B where A227 = i ) <> 1 then
      if demode() = add then
        warning( 2185, i ) select( tr("Begin pregnancy history"), A215L(1),
		                           tr("Continue"), continue );
      endif;
    endif;
  enddo;

PROC A214
  $ = "";

PROC AWSEC2B_ROSTER1
preproc
  { Initialize line number of each pregnancy }
  do i = 1 while i <= maxchild
    ALAST5(i) = 0;  { initialize child as if not born in the last 5 years }
  enddo;
  renum_pregs();

postproc
  { Check counts of boys }
  numeric boys = NAToZero(A203A) + NAToZero(A205A) + NAToZero(A207A);
  ch = count( $ where A216 = 1 & A219 = 1 );
  if lessthan( ch, boys ) then
    errmsg( 02240, tr("Boys"), "A203A+A205A+A207A", boys, ch )
      select( tr("Begin reproduction"), A201, 
	          tr("Begin pregnancy history"), A215L(1) );
  endif;
  { Check counts of girls }
  numeric girls = NAToZero(A203B) + NAToZero(A205B) + NAToZero(A207B);
  ch = count( $ where A216 = 1 & A219 = 2 );
  if lessthan( ch, girls ) then
    errmsg( 02240, tr("Girls"), "A203B+A205B+A207B", girls, ch )
      select( tr("Begin reproduction"), A201, 
	          tr("Begin pregnancy history"), A215L(1) );
  endif;
  { checks that the number of pregnancy losses consistent with reproduction }
  numeric losses = count( $ where A216 in 2,3,4 );
  if lessthan( losses, A211) then
    errmsg( 02240, tr("Pregnancy losses"), "A211", A211, losses )
      select( tr("Pregnancy losses"), A211, 
	          tr("Begin pregnancy history"), A215L(1));
  endif;
  
  { check order of pregnancies }
  do p = 2 while p < A212W
    do i = p-1 while i & (A220Y(i) = missing | A220Y(i) > AINTY) by (-1) enddo;
    { Check pregnancies are given in order }
    if i & validyr(A220Y(i)) &
      ( A220Y(p) < A220Y(i) |
       (A220Y(p) = A220Y(i) & (valid(A220M(i)) & (A220M(p) < A220M(i) |
	                                             (A220M(p) = A220M(i) & (valid(A220D(i)) & A220D(p) < A220D(i)))
      )))) then
      errmsg( tr("Date of end of pregnancy for %s in %s %d is before date of end of pregnancy for %s in %s %d. Reorder these pregnancies?"), 
	          strip(A218(i)),getlabel(A220M,visualvalue(A220M(i))),visualvalue(A220Y(i)),
			  strip(A218(p)),getlabel(A220M,visualvalue(A220M(p))),visualvalue(A220Y(p)))
			  select( maketext(tr("Correct date of pregnancy for %s"), A218(i)), A220D(i), 
			          maketext(tr("Correct date of pregnancy for %s"), A218(p)), A220D(p));
    endif;
  enddo;
  if android then
    show( tr("Pregnancy history"), $, A215L, A218, A216, A219
      title( tr("Line"), tr("Name"), tr("Outcome"), tr("Sex") ) where A215L <> notappl );
  endif;

PROC A215L
preproc
  SaveData();
  renum_pregs();

  { Check for list of pregnancies }
  if curocc() > A212W then
    endgroup
  endif;

PROC A215
preproc
  { If a twin of prior outcome, automatically set to the same code }
  if A215L > 1 & $(A215L-1) > high(twincode(A215L-1),1) then
    if special(visualvalue($)) then
      $ = A215(A215L-1);
      noinput;
    endif;
  endif;

postproc
  { Check twin codes }
  { Last pregnancy can not be 1st of multiple pregnancy }
  if $ > 1 & A212W = 1 then
    errmsg( 02122, A212W ) select( tr("Single or multiple pregnancy"), $,
                                   tr("Reconfirm number of children"), A209 );
  elseif $ > 1 & A215L > 1 & $(A215L-1) = 1 then
    if A215L = A212W then
      errmsg( 02120 ) select( tr("Single or multiple pregnancy"), $ );
    endif
  { Previous pregnancy is first of multiple, but current is single pregnancy }
  elseif $ = 1 & A215L > 1 & $(A215L-1) = 2 then
    if A215L = 2 | A215L > 2 & $(A215L-2) <> 2 then
      errmsg( 02120 ) select( tr("Single or multiple pregnancy"), $ );
    endif;
  endif;

  { Set up twin code variable coded as follows:
    0 - Single birth
    1 - 1st of multiple
    2 - 2nd of multiple
    3 - 3rd of multiple
    etc.
    This variable easier to use in controlling twins.
  }
  if $ = 1 then
    twincode(A215L) = 0
  { first pregnancy or the prior pregnancy last the last of a set of twins or triplets, in which case this is the first of the next set of twins/triplets }	
  elseif A215L = 1 | A215(A215L-1) = twincode(A215L-1) then
    twincode(A215L) = 1
  else
    twincode(A215L) = twincode(A215L-1) + 1
  endif;
  
  if $ > 1 & A215L+$-twincode(A215L) > A212W then
    errmsg( 2123, tolower(getlabel($, $)), A212W ) select( tr( "Number of pregnancies" ), A201, tr( "Single or multiple pregnancy" ), A215 );
    reenter
  endif;

PROC A216
onfocus
  twinnum = twincode(A215L);

postproc
  { check correct outcome combinations for twins }
  if A215 = 2 & A215L > 1 & A215L(A215L-1) = 2 then
    if $ <> $(A215L-1) then           // ??? if different, add code to check valid twins combinations  
	  warning( 2121 ) select( tr("Pregnancy outcome"), $, 
	                          tr("Prior pregnancy outcome"), $(A215L-1), 
							  tr("Continue"), continue );
	endif;
  endif;
  if $ <> 2 then
    skip to A218
  endif;	

PROC A218
onfocus
  protect($, false);
  if !livebirth() then
    recode A216 -> $;
             2  -> tr("STILLBIRTH");
             3  -> tr("MISCARRIAGE");
             4  -> tr("ABORTION");
    endrecode;
    protect( $, true );
  endif;

postproc
  if !pos( $[1:1], alphalst ) then
    errmsg( 89991 ) select( tr("Name"), $ );
  endif;

  if android then 
    setocclabel(AWSEC2B_ROSTER1(curocc()),maketext("%d %s",A215L,strip($)));
  endif;

PROC A219
preproc
  if !livebirth() then
    skip to A220_BLOCK;
  endif;

PROC A220_BLOCK
onfocus
  pregtype = livebirth();

postproc
  if android then 
    setocclabel(AWSEC2B_ROSTER1(curocc()),maketext("%d %s %d/%d/%d",A215L,strip(A218),A220D,A220M,A220Y));
  endif;

PROC A220Y
  if !DateOK( A220D, A220M, $, AINTD, AINTM, AINTY ) then
    errmsg( 2145 ) select( tr("Date of end of pregnancy"), A220D );
  endif;

  prev = A215L - 1;
  { Update twin code variable in case of two pairs of twins together }
  { Twincode is 0-Single birth, 1-1st of multiple, 2-2nd of multiple, ... }
  if A215 = 2 & prev & twincode(prev) >= 2 then
    if ($ <> $(prev) | A220M <> A220M(prev)) then
      twincode(A215L) = 1
    endif
  endif;

  { Check twin codes }
  { Last pregnancy can not be 1st of multiple pregnancy }
  if twincode(A215L) = 1 then
    if A215L = A212W then
      errmsg( 2120 ) select( tr("Single or multiple pregnancy"), A215 );
    endif
  { Current twin code must be 1 higher than previous }
  elseif twincode(A215L) >= 2 then
    if A215L = 1 | twincode(prev) <> twincode(A215L) - 1 then
      errmsg( 2120 ) select( tr("Single or multiple pregnancy"), A215 );
    endif
  { Previous pregnancy is first of multiple, but current is single pregnancy }
  elseif A215L > 1 & twincode(prev) = 1 then
    errmsg( 2120 ) select( tr("Single or multiple pregnancy"), A215 );
  endif;

  { Find prior pregnancy with year of pregnancy to check order }
  do i = A215L-1 while i & ($(i) = missing | $(i) > AINTY) by (-1)
  enddo;
  { Check pregnancies are given in order }
  if i & validyr($) &
    ( $ < $(i) |
     ($ = $(i) & valid(A220M(i)) & A220M < A220M(i)) |
     ($ = $(i) & valid(A220M(i)) & A220M = A220M(i) & valid(A220D(i)) & A220D < A220D(i))
    ) then
    if errmsg( 2152 ) select( tr( "Date of delivery" ), A220_BLOCK,
                              tr( "Date of prior delivery" ), A220_BLOCK(i),
                              tr( "Move pregnancy" ), continue ) = 3 then
      numeric newocc = select_preg( curocc() );
      move_preg( curocc(), newocc );
    endif;
    reenter;
  endif;

  { Check that twin code is correct when dates are identical }
  if A215L > 1 & validyr($) & valid(A220M) &
    ($ = $(prev) & A220M = A220M(prev)) & (A215 = 1 | A215(prev) = 1) then
    errmsg( 2153 ) select( tr("Date of pregnancy"), A220_BLOCK, 
	                       tr("Date of prior pregnancy"), A220_BLOCK(prev), 
						   tr("Single or multiple pregnancy"), A215 );
  endif;

  { Initialize logical ranges for date of pregnancy in CMC }
  if validyr($) then
    ldc(A215L) = setlb( A220M, $, 0 );
    udc(A215L) = setub( A220M, $, 9999 );
  else
    ldc(A215L) = ldb + minab;
    udc(A215L) = di;
  endif;
  { calculate CDC for pregnancy date if at least year and month are valid } 
  A220CD(A215L) = 0;
  if validyr($) & valid(A220M) then
    temp = A220D;
    if !valid(A220D) then // using the last day of the month to be on the conservative side
	  recode A220M -> temp;
   1,3,5,7,8,10,12 -> 31;
	  	  4,6,9,11 -> 30;
		         2 -> 28+($%4=0);
	  endrecode;
	endif;
	A220CD(A215L) = CDCode( $, A220M, temp );
  endif;

  if twincode(A215L) > 1 then // check dates are within one day for twins    
    if A220CD(A215L) = 0 <=> A220CD(prev) <> 0 then  // day known for one, but not the other
      errmsg( 2155, strip(A218), A220D, A220M, A220Y, strip(A218(prev)), A220D(prev), A220M(prev), A220Y(prev) )
      select( tr("Date of")+" "+tr(orderstr(twincode(prev ))), A220_BLOCK(prev), // prior twin - %s will be "first twin", "second twin", etc.
	          tr("Date of")+" "+tr(orderstr(twincode(A215L))), A220_BLOCK);      // later twin - %s will be "second twin", "third twin", etc.
    elseif A220D = 0 & (A220M <> A220M(prev) | $ <> $(prev)) then // day not given - month and year must be the same
      errmsg( 2151 )
      select( tr("Date of")+" "+tr(orderstr(twincode(prev ))), A220_BLOCK(prev), // prior twin - %s will be "first twin", "second twin", etc.
	          tr("Date of")+" "+tr(orderstr(twincode(A215L))), A220_BLOCK);      // later twin - %s will be "second twin", "third twin", etc.
    elseif abs(A220CD(A215L) - A220CD(prev)) > 1 then
      errmsg( 2156, strip(A218), A220D, A220M, A220Y, strip(A218(prev)), A220D(prev), A220M(prev), A220Y(prev) )
      select( tr("Date of")+" "+tr(orderstr(twincode(prev ))), A220_BLOCK(prev), // prior twin - %s will be "first twin", "second twin", etc.
	          tr("Date of")+" "+tr(orderstr(twincode(A215L))), A220_BLOCK);      // later twin - %s will be "second twin", "third twin", etc.
    endif
  endif;

PROC A221_BLOCK
preproc
  if twincode(A215L) > 1 then // second or later of multiple pregnancy, so copy the duration
    if special(visualvalue(A221N)) then
      A221N = A221N(A215L-1);
      A221U = A221U(A215L-1);
      advance to A222;
    endif;
  endif;

PROC A221U
preproc
  { check if pregnancy ended since start of calendar }
  ALAST5(A215L) = 0;
  if ldc(A215L) >= calbeg then
    ALAST5(A215L) = 1
  elseif A215L > 1 & ALAST5(A215L-1) = 1 then
    ALAST5(A215L) = 1
  endif;

postproc
  pregtype = livebirth();
  if !pregtype then pregtype = A216 endif;
  recode $ :: A221N -> err;
         1 :: 3:45  -> 0;     { weeks }
	     2 :: 1:10  -> 0;     { months }
	       ::       -> 1;
  endrecode;
  if err then
    errmsg( 2142 ) select( tr("Duration of pregnancy"), A221_BLOCK ) ;
  endif;

  recode pregtype :: A221N  :: A221U -> err;
            1     ::   0:4  ::   2   -> 1;  { born alive }
            1     ::   0:21 ::   1   -> 1;  { born alive }
            1     ::   5:6  ::   2   -> 2;  { born alive - very early }
            1     ::  22:27 ::   1   -> 2;  { born alive - very early }
            2     ::   0:3  ::   2   -> 2;  { born dead }
            2     ::   0:16 ::   1   -> 2;  { born dead }
            3     ::   8:10 ::   2   -> 2;  { miscarriage }
            3     ::  28:50 ::   1   -> 2;  { miscarriage }
            4     ::   8:10 ::   2   -> 1;  { abortion }
            4     ::  28:50 ::   1   -> 1;  { abortion }
                  ::        ::       -> 0;
  endrecode;
  // code 2 is only a warning
  if err = 2 then
    warning( 2143, A221N, getlabel(A221U, A221U), getlabel(A216,A216) ) select( tr("Duration of pregnancy"), A221_BLOCK,
                   tr("Pregnancy outcome"), A216, tr("Continue"), continue );
  elseif err then
    errmsg( 2143, A221N, getlabel(A221U, A221U), getlabel(A216,A216) ) select( tr("Duration of pregnancy"), A221_BLOCK,
                  tr("Pregnancy outcome"), A216 );
  endif;

  { Check the units and number for the duration are the same for twins }
  if twincode(A215L) > 1 & (A221U <> A221U(A215L-1) | A221N <> A221N(A215L-1)) then
    errmsg( 2144, A221N, getlabel($,$), A221N(A215L-1), getlabel($,$(A215L-1)) )
	select( tr("Duration of pregnancy of")+" "+tr(orderstr(twincode(A215L  )) ), A221_BLOCK,             // later twin - will be "second twin", "third twin" etc.
	        tr("Duration of pregnancy of")+" "+tr(orderstr(twincode(A215L-1)) ), A221_BLOCK(A215L-1) );  // prior twin - will be "first twin", "second twin" etc.
  endif;
  
  numeric durmnth = A221N; 
  if $ = 1 then durmnth = int(A221N * WeeksMonth) endif;
  A221DUR(A215L) = durmnth;
  if ALAST5(A215L) = 1 then
    FillC1Cal( 1 );
  endif;

PROC A222
preproc
  n = curocc();
  if n > 1 & twincode(n) > 1 then
    skip to next A215L
  endif;	
  
onfocus
  // special goback code used with A222
  if goback222 then
	goback222 = 0;
    advance to A215L(curocc()+1);
  endif;

postproc
  // Hold on to values of A222. Will be set to 1 by insert_preg function if needed.
  if A222W = notappl then
    A222W = 2;
  endif;
  // Insertion of pregnancy before current pregnancy
  if $ = 1 & !xmodify then
    insert_preg(curocc())
  endif;

PROC A222A
  // Hold on to values of A222A. Will be set to 1 by insert_preg function if needed.
  if A222AW = notappl then
    A222AW = 2;
  endif;
  // Addition of pregnancy after last pregnancy
  if $ = 1 & !xmodify then
    insert_preg(curocc(AWSEC2B_ROSTER1)+1)
  endif;

PROC A222B
onfocus
  if android then
	showroster( 1 );
  endif;

postproc
  if $ <> 1 then
    reenter A215(1);
  endif;

PROC AWSEC2B_ROSTER2
preproc
  SaveData();

PROC APLINE
preproc
  { Check for list of children }
  if curocc() > A212W then
    endgroup
  endif;

postproc
  if android then 
    setocclabel(AWSEC2B_ROSTER2(curocc()),getocclabel(AWSEC2B_ROSTER1(curocc())));
  endif;

PROC A223
preproc
  // TC Need additional checking here for miscarriages and abortions as per questionnaire.
  idx = APLINE;
  recode A221U(idx) :: A221N(idx) -> durpreg;
             1      ::   28:90    -> 1;
             2      ::    7:10    -> 1;
			        ::   95:99    -> 9; // special values are left unchanged below - in case they are allowed
                    ::            -> 0;
  endrecode;				  
  recode A216(idx) :: A217(idx) :: durpreg -> $;
            1      ::           ::         -> 1;  // born alive
            2      ::      1    ::         -> 1;  // born alive
            2      ::           ::   1     -> 2;  // stillbirth
            2      ::           ::   0     -> 3;  // miscarriage
            3      ::           ::   1     -> 2;  // stillbirth
            3      ::           ::   0     -> 3;  // miscarriage
                   ::           ::         -> A216(idx);
  endrecode;

postproc
  if $ <> A216(idx) & demode() = add then
    if $ = 1 then
      display( 2231, A220D(idx), A220M(idx), A220Y(idx) );
	else
      display( 2232, replace(getlabel(A216,A216(idx)),tr("Born dead"),tr("Stillbirth")), A220D(idx), A220M(idx), A220Y(idx), 
	                 replace(getlabel(A223,A223(idx)),tr("Born dead"),tr("Stillbirth")), A221N(idx), getlabel(A221U,A221U(idx)) );
	endif;
  endif;

PROC A224
preproc
  if A223 <> 1 then
    skip to next APLINE
  endif;	

postproc
  if $ = 1 & A216(APLINE) = 2 then
    errmsg( 2160 ) select( tr("Child alive"), $, 
	                       tr("Pregnancy outcome"), A216(APLINE) );
  elseif $ = 2 then
    skip to A228_BLOCK
  endif;

PROC A225
  { Check that twins have same age if both are alive }
  if twincode(APLINE) >= 2 then
    j = default;
    do i = APLINE - twincode(APLINE) + 1 while i < APLINE
      if A224(i) = 1 then
        j = $(i);
      endif;
    enddo;
    if j <> default & j <> $ then
      errmsg( 2170 ) select( tr("Age of child"), $, tr("Age of twin"), $(i) );
    endif;
  endif;
  if age_day_check(A220D(APLINE), A220M(APLINE), A220Y(APLINE),  AINTD, AINTM, AINTY, A225) >  0 then
    warning( 2175, A225, A220D(APLINE), A220M(APLINE), A220Y(APLINE) )
      select( tr("Date of birth"), A220_BLOCK(APLINE), 
	          tr("Age"), A225, 
			  tr("Continue"), continue);
  endif;

  { Adjust ranges for date of birth of child }
  if valid($) then
    { Lower bound of CMC date of birth }
    t = ndjlba( ldc(APLINE), udc(APLINE), di, di, $ );
    if t < 0 then
      errmsg( 2171, A225, A220D(APLINE), A220M(APLINE), A220Y(APLINE) ) 
	    select( tr("Date of birth"), A220_BLOCK(APLINE), 
		        tr("Age"), $ );
    else
      ldc(APLINE) = t
    endif;
    { Upper bound of CMC date of birth }
    t = adjuba( ldc(APLINE), udc(APLINE), di, di, $ );
    if t < 0 then
      errmsg( 2171, A225, A220D(APLINE), A220M(APLINE), A220Y(APLINE) ) 
	    select( tr("Date of birth"), A220_BLOCK(APLINE), 
		        tr("Age"), $ );
    else
      udc(APLINE) = t
    endif;
  endif;

PROC A227
onfocus
  individuals.clear();
  do i = 1 while i <= AHMEMBER
    if AH04(i) = A219(APLINE) & i <> ALINE then   // condition for same sex maybe commented out or develop a more smart checking
      individuals.add(AH02(i), i);
    endif;
  enddo;
  individuals.add(tr("Child not listed in household"), 0);
  SetValueSet( $, individuals );

postproc
  { Check child's line number is not greater than max }
  if $ > AHMEMBER then
    errmsg( 2181 ) select( tr("Line number in the household"), $ );
  { If child is listed in HH }
  elseif $ > 0 then
    { check for duplicates }
    do i = 1 while i < curocc()
      if A227(i) = $ then
        errmsg( 2184, i ) 
		  select( tr("Line number for this child"), $, 
		          maketext( tr("Line number for child") + "%d", i ), $(i) );
      endif;
    enddo;
    { Check mother's line number agrees with line number of mother in household questionnaire }
    if AH12($) <> notappl & AH13($) <> ALINE then
      if demode() = add then
        warning( 2182, AH13($), ALINE ) 
		  select( tr("Line number in the household"), $, tr("Continue"), continue );
      endif
    endif;
    { Check sex of child against sex in household questionnaire }
    if A219(APLINE) <> AH04($) then
      if demode() = add then
        warning( 2141, AH04($), A219(APLINE) ) 
		  select( tr("Line number in the household"), $, 
		          tr("Sex of child"), A219(APLINE), 
                  tr("Continue"), continue );
      endif;
    endif;
    { Check age of child against age in household questionnaire }
    if !special(A225) & !special(AH07($)) then
      if !( (A225-AH07($)) in (-2):2 ) then
        if demode() = add then
          warning( 2173, AH07($), A225 ) 
		  	select( tr("Line number in the household"), $, 
		            tr("Age of child"), A225, 
                    tr("Continue"), continue )
        endif;
      endif
    endif;
    { Check living status of child against status in household questionnaire }
    if AH05(ALINE) = 1 & A226 <> AH05($) |
       A226 = 1 & AH05(ALINE) <> AH05($) then
      if demode() = add then
        warning( 2183, AH05($), A226 )
          select( tr("Line number in the household"), $, 
		          tr("Child living with respondent"), A226, 
                  tr("Continue"), continue )
      endif;
    endif;
  endif;
  skip to next APLINE;

PROC A228U
preproc
  protect( $, false );
  if A228N in 94:96 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { check unit is for special answer, number must be a special answer,
    but special answers are allowed for number when unit is given }
  badspecial( $, A228N, getsymbol() );
  
  if A216(APLINE) = 2 & !(A228U = 1 | A228N in 0,1) then  // accepts age at death as 0 or 1 day for child originally reported as stillbirth
    errmsg( 2194 ) 
	  select( tr("Age at death number"), A228N, 
	          tr("Unit"), A228U,    
		      tr("Pregnancy outcome"), A216(APLINE) );
  endif;

  { Check maximum and minimum values }
  recode A228U -> maxd;
            1  -> 30;       { 0-30 days   }
            2  -> 23;       { 1-23 months }
            3  -> 40;       { 2-40 years  }
               -> 99;
  endrecode;
  mind = A228U-1;
  if A228U = 9 then mind = 0 endif;
  if A228U = 3 & A228N = 1 then           { requested by Bernard on 11/12/2015 }
    errmsg( 2193 ) select( tr("Age at death number"), A228N, 
	                       tr("Unit"), A228U );
  elseif !( A228N in mind:maxd ) then
    errmsg( 2191, mind, maxd, A228U ) 
	  select( tr("Age at death number"), A228N, 
	          tr("Unit"), A228U );
  endif;

  { Check age at death plausible considering date of birth }
  recode A228U :: A228N   -> adeath;
               :: missing -> 0;
               ::  >=97   -> 0;
            1  ::         -> int(A228N/30);
            2  ::         -> A228N;
            3  ::         -> A228N*12;
               ::         -> 0;
  endrecode;
  if ldc(APLINE) + adeath > di then
    if demode() = add then
      warning( 2192, {ldc(APLINE), adeath, di} A220D, A220M, A220Y, A228N, GetLabel( A228U, A228U ), AINTD, AINTM, AINTY )
	    select( tr("Date of birth"), A220_BLOCK, 
		        tr("Age at death"), A228_BLOCK, 
				tr("Continue"), continue );
    endif
  elseif udc(APLINE) + adeath > di then
    udc(APLINE) = di - adeath
  endif;

PROC A232
preproc
  if !calendid then
    calendid = userbar( add button, tr("Calendar"), showcal());
  endif;

postproc
  { use to clear calendar from current pregnancy in case of back+tab }
  { and a change from 1-currently pregnant to 2-no pregnant          }
  FillC1Cal( 2 );
  if $ <> 1 then
    skip to A236N
  endif;

PROC A233U
  recode $ :: A233N -> err;
         1 :: 5:45  -> 0;     { weeks }
	     2 :: 1:10  -> 0;     { months }
	       ::       -> 1;
  endrecode;
  if err then
    errmsg( 2142 ) select( tr("Duration of pregnancy"), A233_BLOCK );
  endif;

  A233DUR = A233N; 
  if $ = 1 then A233DUR = int(A233N * WeeksMonth) endif;
  { Assign pregnancy and duration of pregnancy to the calendar }
  FillC1Cal( 2 );

PROC A234
  if $ = 1 then
    skip to A236N
  endif;

PROC A236N
onfocus
  protect( A236U, false );

PROC A236U
preproc
  if A236N in 94:96 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, A236N, getsymbol() );

  { menopause/hysterectomy before age 30 }
  if A236N = 94 & agew in 15:29 & demode() = add then
    warning( 82363, agew ) 
	  select( tr("Time since last period"), A236_BLOCK, tr("Continue"), continue );
  endif;
  { check current age with time since last period }
  if A236U = 4 & valid(A236N) & A236N > agew - 10 & demode() = add then
    warning( 82364, agew ) 
	  select( tr("Time since last period"), A236_BLOCK, tr("Continue"), continue )
  endif;
  { Check response "before last pregnancy" given only when had one or more pregnancies }
  if A236N = 95 & !A212W & demode() = add then
    warning( 02360 ) 
	  select( tr("Time since last period"), A236_BLOCK, tr("Continue"), continue )
  endif;
  { Never menstruated but had pregnancy or is currently pregnant }
  if A236N = 96 & ( A212W > 0 | A232 = 1 ) then
    warning( 82369, A212W, A232 ) 
	  select( tr("Time since last period"), A236_BLOCK, tr("Continue"), continue );
  endif;
  recode  $ -> temp;
          1 -> int(A236N/365);
	      2 -> int(A236N/52);
	      3 -> int(A236N/12);
          4 -> A236N;
            -> 99;
  endrecode;
  if A236N in 94:95 then
    skip to A240
  elseif A236N = 96 then
    skip to A241
  elseif temp <> 0 then
    skip to A240
  endif;

PROC A238
  $ = SortAlpha( $ );
  { Check "Nothing" only response }
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  { Get other answer }
  elseif pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A240
  { check current age with age at menarchy }
  if valid($) & $ > agew then
    warning( 82365, agew ) 
	  select( tr("Age at menarche"), $, 
	          tr("Continue"), continue);
  endif;

PROC A241
  if $ <> 1 then
    skip to A243
  endif;

PROC A242
  if $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AWSEC3A_FORM
preproc
  do i = 1 while i <= maxocc( AWSEC3A_GRP )
    A301N(i) = i
  enddo;
  A307N = notappl;

{ !!! This procedure is used in case the survey implements the spontaneous knowledge of method.
      If that is the case variable AALLMETH must be included as the first field in the
      contraceptive table form
PROC AALLMETH
  $ = SortAlpha( $ );
  { Check "No one" is only response }
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  endif;
  *** end of procedure for AALLMETH }

PROC A301_INTRO
  $ = "";
  SaveData();

PROC A301N
  if android then 
    setocclabel(AWSEC3A_GRP(curocc()),getlabel($,$));
  endif;

PROC A301
preproc
  numeric oldvalm = visualvalue( $(A301N) );
  if A301N >= methoth then
    if visualvalue($(A301N)) in 1,2 then
      $ = oldvalm;
    else
      $ = 2
    endif;
    noinput;
  { !!! Logic used in conjunction with the use of AALLMETH
  elseif A301N in 1:13 & pos( "ABCDEFGHIJKLM"[A301N:1], AALLMETH ) then
    $ = 1;
    noinput;
   *** end of logic to be used with field AALLMETH }
  endif;

onfocus
  methname = GetLabel( A301, A301N );

PROC A301OT
  $ = SortAlpha( $ );
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  endif;
  if pos( "A", $ ) then
    A301(methoth) = 1
  else
    A301(methoth) = 2
  endif;
  if pos( "B", $ ) then
    A301(methoth+1) = 1
  else
    A301(methoth+1) = 2
  endif;
  if pos( "A", $ ) then
    if demode() = add then
      display( tr("Record other modern method") );
	endif;
    getother( GetSymbol(), methoth );
    enter FL_OTHERS
  endif;
  if pos( "B", $ ) then
    if demode() = add then
      display( tr("Record other traditional method") );
	endif;
    getother( GetSymbol(), methoth+1 );
    enter FL_OTHERS
  endif;

PROC A303
preproc
  { currently pregnant }
  if A232 = 1 then
    skip to AWSEC3C_FORM
  endif;

onfocus
  A307N = notappl;

postproc
  if $ = 1 then
    skip to A307
  endif;

PROC A304
  if $ in 1:3 then
    skip to A307
  endif;	

PROC A306
onfocus
  A307N = notappl;
  
postproc 
  if $ <> 1 then
    A307N = notappl;
    skip to AWSEC3C_FORM
  endif;	

PROC A307
preproc
  SaveData();

onfocus
  protect($, false);
  if A304 = 1 then
    $ = "A";
    protect( $, true );
  elseif A304 = 2 then
    $ = "B";
    protect( $, true );
  elseif A304 = 3 then
    $ = "AB";
    protect( $, true );
  endif;

postproc
  $ = SortAlpha( $ );
  { "?" not allowed }
  if pos( "?", $ ) then
    errmsg( 9997, "?" ) select( tr("Fix answers marked"), $ );
  elseif A304 in 1,3 & !pos( "A", $ ) then
    errmsg( 3145 ) select( tr("Fix answers marked"), $ );
  elseif A304 in 2,3 & !pos( "B", $ ) then
    errmsg( 3146 ) select( tr("Fix answers marked"), $ );
  elseif A304 = 4 & poschar("AB",$) then
    errmsg( 3150, A304 )
	  select( tr("Current method"), $,
	          tr("Respondent or partner sterilized"), A304 );
  endif;

  { Check all methods are known  }
  {!!! assumes a one to one correspondence between current method and contraceptive table }
  y = length( strip(A307) );
  do x = 1 while x <= y 
    meth = pos( $[x:1], a307str );
    if A301(meth) <> 1 then
      errmsg( 3142, GetLabel(A307, $[x:1]) )
	    select( tr("Current method"), $,
		        tr("Knowledge of") + " " + GetLabel(A307, $[x:1]), A301(meth) );
    endif;
  enddo;

  { Get other answer }
  if pos( "X", $ ) then
    if demode() = add & pos( "XY", $ ) then
      display( tr("Record other modern method") );
	endif;
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  if pos( "Y", $ ) then
    if demode() = add & pos( "XY", $ ) then
      display( tr("Record other traditional method") );
	endif;
    getother( GetSymbol(), 1 );
    enter FL_OTHERS
  endif;

  { Numeric code for highest ranking method }
  A307N = pos( $[1:1], A307STR );
  if A307N = methoth then   { !! adjust according to position of other code (X) in A307STR }
    A307N = 95;
  elseif A307N = methoth+1 then
    A307N = 96;
  endif;

  if A307N in stermeth,stermetm then  { Female or male sterilization }
    skip to A312
  elseif A307N in 3,5,8:96 then       { IUD, implants, f/condom, emergency, SDM, LAM, rhythm, withdrawal, others }
    skip to A314M
  elseif A307N in 6 then              { pill }
    skip to A310
  elseif A307N in 7 then              { condom }
    skip to A311
  endif;

PROC A308
  if $ <> 1 then
    skip to A314M
  endif;	

PROC A309
  skip to A314M;

PROC A310
  { Get other answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  skip to A314M

PROC A311
  { Get other answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  skip to A314M

PROC A312
  majorgrp( $ );
  if $ in 16,26,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A313_BLOCK
onfocus
  alphmeth = GetLabel( A307N, A307N );

PROC A313Y
  if afterint( A313M, $, AINTM, AINTY ) then
    errmsg( 89998 ) select( tr("Date of sterilization"), A313_BLOCK );
  endif;
  if validyr($) then
    lds = setlb( A313M, $, 0 );
    uds = setub( A313M, $, 9999 );
  else
    lds = ldb+minab;
    uds = di;
  endif;
  col1currm( lds );
  skip to AWSEC3C_FORM;

PROC A314_BLOCK
onfocus
  alphmeth = GetLabel( A307N, A307N );
  
PROC A314Y
  if afterint( A314M, $, AINTM, AINTY ) then
    errmsg( 89998 ) select( tr("Date started using method"), A314_BLOCK );
  endif;
  if validyr($) then
    lds = setlb( A314M, $, 0 );
    uds = setub( A314M, $, 9999 );
  else
    lds = ldb+minab;
    uds = di;
  endif;
  col1currm( lds );

PROC AWSEC3C_FORM
preproc
  if !eventsid then
    eventsid = userbar( add button, tr("Events"), showroster(3) );
  endif;

postproc
  { Check rows after date of interview are not used }
  do i = 1  while i <= calint-1
    if ACAL1[i:1] <> " " then
      MnthYear( i );
      errmsg( 9800, mnthstr1, year ) 
	    select( tr("Go back to pregnancy history to reset calendar"), A209 );
    endif;
  enddo;

  { Check column 1, births/pregnancies/terminations and use of methods }
  { ------------------------------------------------------------------ }
  t = 0;
  b = A212W;
  do i = calint while i <= callen

    { Check entries in column 1 }
    textstr1 = pregstr + "0" + methstr;
    if !pos( ACAL1[i:1], textstr1 ) then
      MnthYear( i );
      errmsg( 9801, ACAL1[i:1], 1, mnthstr1, year )
        select( tr("Introduction to calendar"), AINTROUSE );
    endif;

    { Check birth in calendar matches births in birth history }
    if ACAL1[i:1] in codeb,codet then
      calcmc = rowcmc(i);
      if b & calcmc in ldc(b):udc(b) then
        calrow(b) = i;
      else
        if b then
          xl = ldc(b);
          xu = udc(b);
        else
          xl = 0;
          xu = 0;
        endif;
        MnthYear( i );
        errmsg( 9802, mnthstr1, year, calcmc, b, xl, xu ) 
		  select( tr("Go back to pregnancy history to reset calendar"), A209 );
      endif;
      while twincode(b) > 1 do
        b = b - 1;
        calrow(b) = i;
      enddo;

      { Check gestation length of pregnancies agrees with gestation in pregnancy history }
      do j = i + 1 while j <= callen & ACAL1[j:1] = codep
      enddo;
      if j < callen & j - i <> A221DUR(b) then
        MnthYear( i );
        errmsg( 9803, mnthstr1, year, j-i, A221U(b), A221N(b) )
		  select( tr("Duration of pregnancy"), A221_BLOCK(b) );
      endif;
      b = b - 1;
      i = j - 1;

    { Check termination pregnancies length agree with duration in termination history }
    elseif ACAL1[i:1] = codet then
      t = t + 1;
      do j = i + 1 while j <= callen & ACAL1[j:1] = codep
      enddo;
{     if j < callen & ( t = 1 & j - i <> A221DUR(1) | t <> 1 & j - i <> A221DUR(t-1) ) then }
      if j < callen &  j - i <> A221DUR(t) then
        MnthYear( i );
        errmsg( 9819, mnthstr1, year, j-i, A221U(t), A221N(t) )
		  select( tr("Duration of pregnancy"), A221_BLOCK(t) );
{
        if t = 1 then
          errmsg( 9819, strip(mnthstr1), year, j-i, "A233", A221DUR(1) );
          reenter zzA230;
        else
          errmsg( 9819, strip(mnthstr1), year, j-i, "termination history", A221DUR(t-1) );
          reenter A221DUR(t-1);
        endif;
}
      endif;
      i = j - 1;

    { Check pregnancy codes are either for current pregnancy, }
    { or for pregnancies that are terminated }
    elseif ACAL1[i:1] = codep then
      if i > 1 & !pos( ACAL1[i-1:1], " "+pregstr ) then
        MnthYear( i );
        errmsg( 9818, mnthstr1, year )
          select( tr("Introduction to calendar"), AINTROUSE,
 		          tr("Go back to current pregnancy"), A232 );
      endif;

    endif;
  enddo;

  { Check all births since January 201? are represented in calendar }
  do b = A212W while b by (-1)
    if ldc(b) >= calbeg & !calrow(b) then
      errmsg( 9804, b )
        select( tr("Go back to pregnancy history to reset calendar"), A209 );
    endif;
  enddo;
  { Check for current pregnancy in the calendar }
  if A232 = 1 & ACAL1[calint:1] <> codep then
    errmsg( 89823 )
	  select( tr("Go back to current pregnancy"), A232 );
  endif;

  { Check contraception use in calendar }
  { Check current use of sterilization if it didn't occur in the month of }
  { interview and at the same time a birth or termination occurred        }
{
  if ACAL1[calint:1] <> codeb & ACAL1[calint:1] <> codet &
     A301(1) = 1 & ACAL1[calint:1] <> edit("9",stermeth) then
    errmsg( 3031 );
    reenter A301(1);
  endif;
}
  { Check current method with method given in calendar }
  if pos( ACAL1[calint:1], methstr ) then
    t = pos(ACAL1[calint:1],methstr);
    m = pos(A307[1:1],A307STR);
    if t <> m then
      errmsg( 3131, A307, ACAL1[calint:1] ) select( tr("Current method"), A307 );
    endif;
  elseif A307N <> notappl then
    meth    = MethInStr( A307N, methoth );
    onemeth = methstr[meth:1];
    if ACAL1[calint:1] <> codeb & ACAL1[calint:1] <> codet & ACAL1[calint:1] <> onemeth then
      errmsg( 3131, A307, ACAL1[calint:1] ) select( tr("Current method"), A307 );
    endif;
  endif;

  { Find first date used method in calendar }
  if A307N <> notappl then
    meth    = MethInStr( A307N, methoth );
    onemeth = methstr[meth:1];            { to check date started using any method }
    b = pos( codeb, ACAL1 );
    t = pos( codet, ACAL1 );
    if t & ( t < b | !b ) then
      b = t
    endif;
    do i = calint while i <= callen & ACAL1[i:1] = onemeth
    enddo;
    { Found method }
    if i <= callen then
      i = i - 1;
      x = rowcmc(i)
    { No method, but birth in month of interview }
    elseif b = calint then
      x = rowcmc(b)
    else
      x = 0
    endif;
    { Birth in month of interview or in month prior to method use in calendar }
    if b = calint | b = i + 1 then
      y = rowcmc(b)
    else
      y = x
    endif;
    { Check method start date from calendar agrees }
    if (i <= callen & (lds > x | uds < y)) |
       (i >  callen & lds >= calbeg) then
	  if A313Y <> notappl then
        warning( 3211, lds, uds, x, i ) 
	      select( tr("Date of sterilization"), A313_BLOCK, tr("Continue"), continue );
	  else
        warning( 3211, lds, uds, x, i ) 
	      select( tr("Date of start of current method"), A314_BLOCK, tr("Continue"), continue );
      endif;				  
    endif;
    if i <= callen then
      if lds < y then
        lds = y
      endif;
      if uds > x then
        uds = x
      endif;
    endif;
  endif;

  { Look for prior use of sterilization method,
    or of female sterilization if currently using male sterilization }
  if A307N in stermeth,stermetm then
    do i = i + 1 while i <= callen & !pos( ACAL1[i:1], onemeth+"A" )
    enddo;
    if i <= callen then
      warning( 3212, i ) 
	    select( tr("Current method"), A307, tr("Continue"), continue );
    endif;
  endif;

  { Check column 2, discontinuation reasons }
  { --------------------------------------- }
  discont = 0;
  caluse = 0;
  xusing = default;              { Whether using in month i-1 }
  do i = calint while i <= callen

    { Checks entries in column 2 }
    if !pos( ACAL2[i:1], " 012345678NFADXZ" ) then
      MnthYear( i );
      errmsg( 9801, ACAL2[i:1], 2, mnthstr1, year )
        select( tr("Introduction to calendar"), AINTROUSE );
    endif;

    { Checks for discontinuation of use, but col 2 blank }
    used = pos( ACAL1[i:1], methstr );       { Whether using in month i }
    if used & xusing <> used & xusing <> default then
      discont = discont + 1;
      if ACAL2[i:1] = " " then
        errmsg( 9805, i ) select( tr("Introduction to calendar"), AINTROUSE );
      elseif i < callen & ACAL2[i+1:1] <> " " then
        errmsg( 9806, i, i+1 );
      endif;
    endif;
    if used & !caluse then
      caluse = i
    endif;

    { Checks for col 2 not blank, but no contraceptive method }
    if ACAL2[i:1] <> " " & (!used | used = xusing) then
      errmsg( 9807, i ) select( tr("Introduction to calendar"), AINTROUSE );
    endif;

    xusing = used;
  enddo;

PROC AINTROUSE
preproc
  if A307N <> notappl & lds <= calbeg then
    { blank out column 2 in case of modify mode }
    do i = 1 while i <= callen
      ACAL2[i:1] = " ";
    enddo;
    skip to A329;
  endif;

onfocus
  $ = "";
  { blank out column 1 for codes other than pregnancy related and column 2 }
  do i = 1 while i <= callen
    if !pos( ACAL1[i:1], pregstr ) then
      ACAL1[i:1] = " ";
    endif;
    ACAL2[i:1] = " ";
  enddo;

postproc
  { prepare event table to help drawing the calendar }
  i = 1;
  if A232 = 1 then
    womevents(i,1) = tr("Current-Pregnancy");
    womevents(i,2) = edit("99",AINTM) + "/" + edit("9999",AINTY);
    womevents(i,3) = edit("99",A233DUR);
  elseif A307N <> notappl then
    womevents(i,1) = GetValueLabel( A307N );
    womevents(i,2) = edit("99",A314M) + "/" + edit("9999",A314Y);
    womevents(i,3) = edit("99", di - cmcode( A314M, A314Y ) + 1);
  endif;
  do j = 1 while j <= totocc( AWSEC2B_ROSTER2 )
    if ALAST5(j) = 1 then
      i = i + 1;
      womevents(i,1) = A218(j);
      womevents(i,2) = edit("99",A220M(j)) + "/" + edit("9999",A220Y(j));
      womevents(i,3) = edit("99",A221DUR(j));
    endif;
  enddo;
  while i < 20 do
    i = i + 1;
    womevents(i,1)  = " ";
    womevents(i,2)  = " ";
    womevents(i,3)  = " ";
  enddo;
  if demode() = add then
    showroster( 3 );
  endif;

PROC A317N
preproc
  $ = curocc();
  ACDURIN = 0;

postproc
  if $ = 1 then
    if A307N <> notappl then                        { current users }
      col1currm( lds );
      beguse   = cmcrow( lds ) + 1;
      do i = beguse while i <= callen & pos( ACAL1[i:1], pregstr )
      enddo;
      begcheck = i;
    elseif pos( ACAL1[calint:1], pregstr ) then     { pregnancy, terminations, births }
      do i = calint while pos( ACAL1[i:1], pregstr )
      enddo;
      begcheck = i;
    else                                            { not using a method }
      ACAL1[calint:1] = "0";
      do i = calint+1 while i <= callen & pos( ACAL1[i:1], pregstr )
      enddo;
      begcheck = i;
    endif;
  elseif ACDIRNEXT($-1) = 2 then
    do i = ACBEVENT($-1)+1 while pos(ACAL1[i:1], pregstr) & i <= callen
    enddo;
    begcheck = i;
  else
    begcheck = ACROWNEXT($-1);
  endif;
  if begcheck > callen then
    endgroup
  endif;
  if $ = 1 | ACDIRNEXT($-1) = 2 then
    goingdown( begcheck, $ );
    { variable ACFEVENT stores the row where an event finishes         }
    { the variable has the same value for all episodes within the event }
    { variable ACBEVENT stores the row where an event begins           }
    { the variable has the same value for all episodes within the event }
    ACFEVENT = endrowint;
    ACBEVENT = begrowint;
  else
    goingup( begcheck, $ );
    ACFEVENT = ACFEVENT($-1);
    ACBEVENT = ACBEVENT($-1);
  endif;

PROC A317AM
preproc
  $ = ACAUXM1;

PROC A317AY
preproc
  $ = ACAUXY1;

postproc
  if A307N <> notappl & cmcode( A317AM, A317AY ) >= lds then
    warning( 82285, A314M, A314Y );
  endif;

PROC A317B
onfocus
  year1  = A317AY;
  month1 = A317AM;
  if !( A317AY = AINTY & A317AM = AINTM | A317AY = calbegy & A317AM = 1 ) then
    month1 = A317AM - 1;
    if month1 = 0 then
      month1 = 12;
      year1  = year1 -1;
    endif;
  endif;
  mnthstr1 = GetLabel( A317AM, month1 );
  year2  = ACAUXY2;
  month2 = ACAUXM2;
  if !( ACAUXY2 = calbegy & ACAUXM2 = 1 ) then
    month2 = ACAUXM2 + 1;
    if month2 = 13 then
      month2 = 1;
      year2  = year2 + 1;
    endif;
  endif;
  mnthstr2 = GetLabel( A317AM, month2 );
  textbegin( curocc() );
  textend( curocc() );

  // set episode start and end indicators
  disp1 = cmcrow(cmcode(month1, year1));
  disp2 = cmcrow(cmcode(month2, year2));

  if demode() = add & special(visualvalue($)) then
    showcal();
  endif;

postproc
  if $ <> 1 then
    A317C = " ";
    skip to A317F
  endif;

PROC A317C
postproc
  xrow = cmcrow( cmcode(A317AM,A317AY) );
  CleanCal( xrow, A317N );
  if !length( strip($) ) then
    errmsg( 89999 ) select( tr("Method used"), $ );
  { Get "Other" answers for methods in column 1 }
  elseif pos( $, "XY" ) then
    getother( "ACAL1", xrow );
    enter FL_OTHERS
  endif;
  method = pos( $, methstr );
  if method = 1 then
    errmsg( 83136 ) select( tr("Method used"), $); 
  elseif method & A301(method) <> 1 then
    errmsg( 83135 )
      select( tr("Knowledge of method"), A301(method), 
	          tr("Method used"), $ );
  endif;

PROC A317D
onfocus
  alphmeth = GetValueLabel(A317C);
  begevent = cmcode(A317AM,A317AY);

postproc
  begrow = cmcrow( cmcode(A317AM,A317AY) );
  if $ = 0 then
    if begrow <= callen & A317C = ACAL1[begrow+1:1] then
      errmsg( 83137 ) select( tr("Method used"), A317C );
    endif;
  endif;
  if $ <> 95 then
    if $ > begrow-ACFEVENT(A317N) then
      errmsg( 83138, begrow-ACFEVENT(A317N) ) select( tr("Months not using"), $ );
    else
      do i = begrow while i > begrow-$ by (-1)
        ACAL1[i:1] = "0";
        ACAL2[i:1] = " ";
      enddo;
      ACDURIN = $;
      skip to A317F;
    endif;
  endif;

PROC A317E_BLOCK
onfocus
  alphmeth = GetLabel( A317C, A317C );

PROC A317EM
preproc
  if visualvalue( A317EM(A317N) ) = notappl then
    begrow = cmcode(A317AM,A317AY);
    $ = ( begrow-1) % 12 + 1;
  endif;

PROC A317EY
preproc
  if visualvalue( A317EY(A317N) ) = notappl then
    begrow = cmcode(A317AM,A317AY);
    $ = int( (begrow-1)/12 + 1900 );
  endif;

postproc
  begrow = cmcrow( cmcode(A317AM,A317AY) );
  endrow = cmcrow( cmcode(A317EM,$) );
  if endrow = begrow & A317C = ACAL1[begrow+1:1] then
    errmsg( 83137 ) select( tr("Method used"), A317C );
  endif;
  ACDURIN = begrow - endrow;
  if ACDURIN > begrow-ACFEVENT(A317N) then
    errmsg( 83138, begrow-ACFEVENT(A317N)+1 ) select( tr("Date began using"), $ );
  elseif ACDURIN < 0 then
    errmsg( 83142 ) select( tr("Date began using"), $ );
  else
    do i = begrow while i > endrow by (-1)
      ACAL1[i:1] = "0";
      ACAL2[i:1] = " ";
    enddo;
  endif;

PROC A317F
preproc
  if A317B = 2 then
    begrow = cmcrow( cmcode(A317AM,A317AY) );
    endrow = cmcrow( cmcode(ACAUXM2,ACAUXY2) );
    $ = begrow - endrow + 1;
    noinput;
  endif;

onfocus
  alphmeth = GetValueLabel(A317C);
  if A317B = 1 then
    protect( $, false );
  else
    protect( $, true );
  endif;

postproc
  if $ <> 95 then
    begrow = cmcrow( cmcode(A317AM,A317AY) ) - ACDURIN;
    if $ > begrow-ACFEVENT(A317N)+1 then
      errmsg( 83138, begrow-ACFEVENT(A317N)+1 ) select( tr("Months using"), $ );
    endif;
    endrow = begrow - $ + 1;
    cmcend = rowcmc( endrow );
    ACAUXM2 = ( cmcend-1 ) % 12 + 1;
    ACAUXY2 = int( (cmcend-1)/12 + 1900 );
    skip to A317H;
  endif;

PROC A317G_BLOCK
onfocus
  alphmeth = GetValueLabel(A317C);
  
PROC A317GM
preproc
  month = visualvalue( A317GM(A317N) );
  if month = notappl | month = ACAUXM2 then
    $ = ACAUXM2;
  endif;

PROC A317GY
preproc
  year  = visualvalue( A317GY(A317N) );
  if year = notappl | year = ACAUXY2 then
    $ = ACAUXY2;
  endif;

postproc
  ACAUXM2 = A317GM;
  ACAUXY2 = $;
  if afterint( ACAUXM2, ACAUXY2, AINTM, AINTY ) then
    errmsg( 89998 ) select( tr("Date end using"), A317G_BLOCK );
  endif;

PROC A317H
preproc
  { first analyze consistency of episodes }
  begrow = cmcrow( cmcode(A317AM,A317AY) ) - ACDURIN;
  endrow = cmcrow( cmcode(ACAUXM2,ACAUXY2) );
  if endrow > begrow then
    errmsg( 83134 ) select( tr("Months using"), A317F );
  { following instructions to customize error messages }
  { when the termination of the episode falls above    }
  { the upper limit between the events                 }
  elseif begrow-endrow+1 > begrow-ACFEVENT(A317N)+1 then
    { if date falls during a pregnancy episode }
    if pos( ACAL1[endrow:1], pregstr ) then
      do i = endrow while pos( ACAL1[i:1], pregstr )
      enddo;
      temp = i-endrow;
      do i = endrow while pos( ACAL1[i:1], pregstr ) by (-1)
      enddo;
      calcode  = ACAL1[i+1:1];
      cmcend   = rowcmc( i+1 );
      month1   = ( cmcend-1 ) % 12 + 1;
      year1    = int( (cmcend-1)/12 ) + 1900;
      mnthstr1 = GetLabel( A317AM, month1 );
      textstr1 = tr("The date of end of the episode exceeds by") + " " + edit("99",temp) + " " + tr("months") + " ";
      if calcode = codeb then
        textstr2 = tr("the pregnancy of") + " " + strip(A218(birthrow(i+1))) + " " + tr("in") + " " + mnthstr1 + ", " + edit("9999",year1);
      elseif calcode = codet then
        textstr2 = tr("the") + " " + strip(A218(birthrow(i+1))) + " " + tr("that occurred in") + " " + mnthstr1 + ", " + edit("9999",year1);
      elseif calcode = codep then
        textstr2 = tr("the current pregnancy");
      else
        textstr2 = tr("another (unexpected) event");
      endif;
    { if date falls after conclusion of a pregnancy episode }
    else
      do i = endrow while !pos( ACAL1[i:1], pregstr ) & i <= callen enddo;
      temp     = i-endrow;
      calcode  = ACAL1[i:1];
      textstr1 = tr("The date of end of the episode exceeds by") + " " + edit("99",temp) + " " + tr("months") + " ";
      if calcode = codeb then
        textstr1 = textstr1 + " " + tr("the birth of") + " " + strip(A218(birthrow(i))) + " " + tr("in") + " ";
      elseif calcode = codet then
        textstr1 = textstr1 + " " + tr("the") + " " + strip(A218(birthrow(i))) + " " + tr("that occurred in") + " ";
      else
        textstr1 = textstr1 + " " + tr("another (unexpected) event") + " ";
      endif;
      cmcend   = rowcmc( i );
      month1   = ( cmcend-1 ) % 12 + 1;
      year1    = int( (cmcend-1)/12 ) + 1900;
      mnthstr1 = GetLabel( A317AM, month1 );
      textstr2 = mnthstr1 + ", " + edit("9999",year1);
    endif;
    errmsg( "%s %s", textstr1, textstr2 ) select( tr("Months using"), A317F );
  endif;
  do i = endrow while i <= callen & i <= begrow
    if A317B = 2 then
      ACAL1[i:1] = "0";
      ACAL2[i:1] = " ";
    else
      ACAL1[i:1] = A317C;
    endif;
  enddo;
  { set up row and direction for next episode }
  if endrow <= ACFEVENT | endrow <= calint then
    ACDIRNEXT = 2;                { next event go down (interview towards begin of calendar) }
  else
    ACDIRNEXT = 1;                { next event go up (end of event towards month of interview) }
    ACROWNEXT = endrow;
    { clear the remaining of the interval upwards in case that dates change }
    do i = endrow-1 while i >= ACFEVENT by (-1)
      ACAL1[i:1] = " ";
      ACAL2[i:1] = " ";
    enddo;
  endif;
  { clear the remaining of the interval upwards in case that dates change }
  do i = ACBEVENT+1 while i <= callen
    if !pos( ACAL1[i:1], pregstr ) then
      ACAL1[i:1] = " ";
    endif;
    ACAL2[i:1] = " ";
  enddo;
  { current method should be different from previous episode of use }
  {  if endrow > calint & A317B = 2 & A317C = ACAL1[endrow-1:1] then changed on 09/08/2008 needs to be checked }
  if endrow > calint & A317B = 1 & A317C = ACAL1[endrow-1:1] then
    errmsg( 83140, GetValueLabel(A317C) ) select( tr("Method used"), A317C );
  endif;

  { finally clear row and skip if didn't use any method }
  ACAL2[begrow:1] = " ";  { blank out the row first }
  if A317B = 2 then
    skip to next A317N
  endif;

onfocus
  alphmeth = GetValueLabel(A317C);

postproc
  endrow = cmcrow( cmcode(ACAUXM2,ACAUXY2) );
  if !length( strip($) ) then
    errmsg( 89999 ) select( tr("Reason stop using"), $ );
  { Get "Other" answers reason for discontinuation in column 2 }
  elseif pos( "X", $ ) then
    getother( "ACAL2", endrow );
    enter FL_OTHERS
  endif;
  ACAL2[endrow:1] = $;

PROC ACAL2
  if demode() = add then
    showcal();
  endif;

PROC A318
  if $ = 1 & A301(9) <> 1 then
    warning( 3132 ) 
	  select( tr("Use of emergency contraception"), $, 
	          tr("Continue"), continue );
  endif;

PROC A320
preproc
  if caluse | A307N <> notappl then
    $ = 1;        { Force value of 1 if method used in calendar }
    noinput       { to allow easy checking of ever use later }
  endif;

postproc
  if ( caluse | A307N <> notappl ) & $ <> 1 then
    errmsg( 3051 ) select( tr("Ever use of contraception"), $);
  elseif $ = 2 then
    { for respondents that have never used a method assign zeros to months }
    { where no births, pregnancies or terminations are registered          }
    do i = calint while i <= callen
      if !pos( ACAL1[i:1], pregstr ) then
        ACAL1[i:1] = "0";
      endif;
      ACAL2[i:1] = " ";
    enddo;
    skip to A331;
  endif;

PROC A321
preproc
  if A307N = notappl then
    $ = 0
  else
    $ = A307N;
  endif;

postproc
  if noteq( $, A307N ) then
    errmsg( 3270, A307[1:1] ) select( tr("Current method"), A307 );
  endif;
  if $ = 0 then                       { no method }
    skip to A331
  elseif $ = stermeth then            { female sterilization }
    skip to A324
  elseif $ in stermetm,11:13,96 then  { male sterilization, LAM, rhythm, withdrawal, other }
    skip to A332
  endif;

PROC A322
onfocus
  alphmeth = GetLabel( A307N, A307N );
  mnthstr1 = GetLabel( A314M, A314M );

postproc
  majorgrp( $ );
  if $ in 16,27,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A323
  skip to A325

PROC A327
preproc
  $ = A307N;
  
postproc
  if $ = 1 then
    skip to A332
  endif;  

PROC A328
  skip to A330;

PROC A329
preproc
  $ = A307N;

postproc
  if noteq( $, A307N ) then
    errmsg( 3270, A307[1:1] ) select( tr("Current method"), A307 );
  elseif $ in stermeth,stermetm,11:13,96 then  { f/m ster, LAM, rhythm, withdrawal, other traditional }
    skip to A332
  endif;

PROC A330
onfocus
  alphmeth = GetLabel( A307N, A307N );

postproc
  majorgrp( $ );
  if $ in 16,27,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  skip to A332;

PROC A332
  if $ <> 1 then
    skip to A334
  endif;

PROC A334
preproc
  SaveData();

postproc
  if $ <> 1 then
    endgroup
  endif;

PROC AWSEC04_FORM
preproc
  { initialize variables used to count entries for different sections }
  AESEC4 = 0;
  AESEC5 = 0;
  AESEC6 = 0;
  numeric fullcdc, livcdc, livcmc, prevb, prevs;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  pregpcare = 0;
  fullcdc = count(AWSEC2B where A220CD <> 0);
  if A212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    pregpcare = count(AWSEC2B where int((dicdc - A220CD)/DaysMonth) < yrspcare*12);
  else
    { count pregnancies based on CDC codes } 
	livcdc = 0;
	do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if int((dicdc - A220CD(i))/DaysMonth) < yrspcare*12 then
	    livcdc = i;               // assume remaining pregnancies occurred after this one
		break;
	  endif; 
	enddo;
	if livcdc then livcdc = A212W - livcdc + 1 endif;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if di - udc(i) < yrspcare*12 then
	    livcmc = i;               // assume remaining pregnancies occurred after this one
		break;
	  endif; 
	enddo;
	if livcmc then livcmc = A212W - livcmc + 1 endif;
	pregpcare = livcdc;
	if livcmc > livcdc then pregpcare = livcmc endif;
  endif;  
  if !pregpcare then 
    endgroup
  endif;
  { initialize heading variables }
  AESEC4 = pregpcare;
  prevb = 0;
  prevs = 0;  
  do i = 1 while i <= max5
    if i <= pregpcare then
      ACOL41(i) = i;
	  idx     = A212W - i + 1;
	  A404(i) = idx;
	  pregtype = A223(idx);
	  recode pregtype :: prevb :: prevs -> temp;
                1     ::   0   ::       -> 1;	// last live birth
                1     ::       ::       -> 2;	// prior live birth
                2     ::       ::   0   -> 3;	// last stillbirth
                2     ::       ::       -> 4;	// prior stillbirth
               3:4    ::       ::       -> 5;	// miscarriage or abortion
      endrecode;
      A405(i) = temp;
      if temp = 1 then prevb = 1 endif;
      if temp = 3 then prevs = 1 endif;	  
    else
      ACOL41(i) = notappl;
	  A404(i)   = notappl;
	  A405(i)   = notappl;
    endif;
  enddo;

PROC A403
  $ = "";

  if pregpcare & special(visualvalue(A404(1))) then
    showpreg456("Pregnancies for pregnancy and postnatal care module",A212W - pregpcare + 1,0);
  endif;

PROC ACOL41
preproc
  if curocc() > 1 then
    SaveData();
  endif;

  if curocc() > pregpcare then
    endgroup
  endif;

PROC A405
{ leave out this skip, so that date and name are captured for all pregnancies (name may be the type of pregnancy for non-live births)
  if $ in 1,2 then
    skip to A407
  endif;	
}

PROC A406D 
preproc
  A406D = A220D(A404);
  A406M = A220M(A404);
  A406Y = A220Y(A404);
  
PROC A407  
preproc
  A407 = A218(A404);

  if android then 
    setocclabel(AWSEC04_ROSTER(curocc()),maketext("%s %d/%d/%d",A407,A406D,A406M,A406Y));
  endif;

PROC A408
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

onfocus
  pregtype = (A405 in 1,2 );
  mnthstr1 = GetLabel(A406M, A406M);

postproc
  if $ = 1 then
    skip to A411
  endif;

PROC A409
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  if $ <> 1 then
    skip to A411
  endif;

PROC A410N
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

onfocus
  protect( A410U, false );

PROC A410U
preproc
  if A410N in 90:98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), ACOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, A410N, getsymbol() );

PROC A411
preproc
  $ = A405;
  
postproc
  if $ in 2,4 then  
    skip to A434
  elseif $ = 5 then  
    skip to A476
  endif;

PROC A412
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  if $ = 2 then
    if A405 = 1 then
	  skip to A420
	elseif A405 = 3 then
	  skip to A426
	endif;
  endif;  

PROC A414
preproc
  if copytwin_a($, ACOL41) then noinput endif;

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A415
preproc
  if copytwin_a($, ACOL41) then noinput endif;

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "F", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;
  if pos( "I", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
  if pos( "L", $ ) then
    getother( GetSymbol(), 10*curocc()+3 );
    enter FL_OTHERS
  endif;
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+4 );
    enter FL_OTHERS
  endif;

PROC A416N
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

onfocus
  protect( A416U, false );

PROC A416U
preproc
  if A416N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), ACOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, A416N, getsymbol() );
  
  recode $ :: A416N -> err;
         1 :: 3:45  -> 0;     { weeks }
	     2 :: 1:9   -> 0;     { months }
         9 :: 98    -> 0;
           ::       -> 1;
  endrecode;
  if err then
    errmsg( 4160 ) select( tr("Timing of 1st antenatal visit"), A416_BLOCK );
  endif;

PROC A417
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A418A
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;
  
PROC A418B
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A418C
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A418D
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A418E
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A418F
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A418G
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A420
preproc
  if A405 <> 1 then
    skip to A426
  endif;

postproc
  if $ <> 1 then
    skip to A423
  endif;

PROC A421
  if $ in 2:7 then
    skip to A426
  endif;

PROC A423
  if $ <> 1 then
    skip to A426
  endif;

PROC A425
  if valid($) & $ > agew then
    warning( 4220, A111 );
  endif;

PROC A426
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  if $ <> 1 then
    skip to A429
  endif;

PROC A427
preproc
  if copytwin_a($, ACOL41) then noinput endif;

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "F", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;
  if pos( "M", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
  if pos( "P", $ ) then
    getother( GetSymbol(), 10*curocc()+3 );
    enter FL_OTHERS
  endif;
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+4 );
    enter FL_OTHERS
  endif;

PROC A428
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A429
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A431
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  if $ <> 1 then
    skip to A434
  endif;

PROC A432
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A433
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A434
onfocus
  mnthstr1 = GetLabel(A406M, A406M);

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Check "No one" is only response }
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  { Get other answer }
  elseif pos( "X", $ ) then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A435
postproc
  majorgrp( $ );
  if $ in 26,36,46,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS;
  endif;
  if $ in 11,12,96,missing then
    skip to A437
  endif;

PROC A437
preproc
  $ = A405;
  
postproc  
  if $ = 2 then
    skip to A441;
  elseif $ = 3 then
    skip to A447_BLOCK;
  elseif $ = 4 then
    skip to next ACOL41;
  endif;

PROC A438
  if $ <> 1 then
    skip to ANB1N        // if no Newborn module skip should be to A441
  endif;

PROC A439
  if $ <> 1 then
    skip to ANB1N        // if no Newborn module skip should be to A441
  endif;

{ !!!! remove fields ANB1 to ANB7 and ACH2 to ACH4 if Newborn module not used }
PROC ANB1N
onfocus
  protect( ANB1U, false );

PROC ANB1U
preproc
  if ANB1N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, ANB1N, getsymbol() );
  
  recode $ :: ANB1N -> err;
         0 ::   0   -> 0;     { immediaweeks }
         1 ::  1:24 -> 0;     { hours }
	     2 ::  1:30 -> 0;     { days }
         9 ::  98   -> 0;
           ::       -> 1;
  endrecode;
  if err then
    errmsg( 4165 ) select( tr("Timing for 1st bath"), ANB1_BLOCK );
  endif;

PROC ANB3
preproc
  if !A435 in 11,12,96 then
    skip to ANB6
  endif;	

postproc
  if $ = 8 then
    skip to ANB6
  endif;	

PROC ANB6
  if $ <> 1 then
    skip to A441
  endif;	

PROC ANB7
  $ = SortAlpha( $ );
  { Check "No one" is only response }
  if pos( "Z", $ ) & length(strip($)) > 1 then
    errmsg( 9996 ) select( tr("Fix answers marked"), $ );
  { Get other answer }
  elseif pos( "X", $ ) then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC ACH2
preproc
  if pos("A",ANB7) then
    skip to ACH3_BLOCK
  endif;	

postproc
  if $ <> 1 then
    skip to A441
  endif;	

PROC ACH3N
onfocus
  protect( ACH3U, false );

PROC ACH3U
preproc
  if ACH3N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, ACH3N, getsymbol() );
  
  recode $ :: ACH3N -> err;
         0 ::   0   -> 0;     { immediaweeks }
         1 ::  1:24 -> 0;     { hours }
	     2 ::  1:30 -> 0;     { days }
         9 ::  98   -> 0;
           ::       -> 1;
  endrecode;
  if err then
    errmsg( 4170 ) select( tr("Timing to apply chlorhexidine"), ACH3_BLOCK );
  endif;
  
PROC A442
  if $ <> 1 then
    skip to A447_BLOCK
  endif;

PROC A443N
onfocus
  protect( A443U, false );

PROC A443U
preproc
  if A443N in 9.998 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  numeric x443n = A443N * 1000;
  if (A443U <> 9 & x443n = 9998) |
     (A443U  = 9 & !x443n in missing,9998) then
    errmsg( 9994 ) select( tr("Unit"), $ );
  elseif x443n <> missing & x443n < 9998 & x443n%100 <> 0 & x443n%100 <> 50 then
    warning( 9993 ) 
	  select( tr("Weight"), A443N, tr("Continue"), continue );
  endif;

PROC A447_BLOCK
preproc
  if A405 = 2 then // can't use <> 1 due to skip from 437
    skip to A480
  elseif A435 in 11:12,96 then	
    skip to A464
  endif;

onfocus
  facility = GetValueLabel(A435);
  mnthstr1 = GetLabel(A406M, A406M);

PROC A447N
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

onfocus
  protect( A447U, false );

PROC A447U
preproc
  if A447N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), ACOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, A447N, getsymbol() );

PROC A448
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  if $ <> 1 then
    skip to A452
  endif;

PROC A449N
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

onfocus
  protect( A449U, false );

PROC A449U
preproc
  if A449N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), ACOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, A449N, getsymbol() );

PROC A450
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A452
preproc
  if A405 <> 1 then
    skip to A455
  endif;	

postproc
  if $ <> 1 then
    skip to A455
  endif;

PROC A453N
onfocus
  protect( A453U, false );

PROC A453U
preproc
  if A453N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, A453N, getsymbol() );

PROC A454
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A455
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  if $ <> 1 then
    skip to A460;
  endif;

PROC A456N
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

onfocus
  protect( A456U, false );

PROC A456U
preproc
  if A456N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), ACOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, A456N, getsymbol() );

PROC A457
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A458
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ in 26,36,46,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A460
preproc
  if A405 <> 1 then
    skip to A474A
  endif;
  
onfocus
  facility = GetValueLabel(A435);

postproc
  if $ <> 1 then
    skip to A473A;
  endif;

PROC A461N
onfocus
  protect( A461U, false );

PROC A461U
preproc
  if A461N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, A461N, getsymbol() );

PROC A462
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A463
  majorgrp( $ );
  if $ in 26,36,46,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;
  skip to A473A;

PROC A464
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

onfocus
  mnthstr1 = GetLabel(A406M, A406M);

postproc
  if $ <> 1 then
    skip to A469;
  endif;

PROC A465N
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

onfocus
  protect( A465U, false );

PROC A465U
preproc
  if A465N in 98 then
    protect( $, true );
    $ = 9;
  else
    if copytwin(visualvalue($), ACOL41) then noinput endif;
  endif;

postproc
  { Check special answers }
  badspecial( $, A465N, getsymbol() );

PROC A466
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A467
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

postproc
  majorgrp( $ );
  if $ in 26,36,46,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A469
preproc
  if A405 <> 1 then
    skip to A474A
  endif;	

postproc
  if $ <> 1 then
    skip to A473A
  endif;

PROC A470N
onfocus
  protect( A470U, false );

PROC A470U
preproc
  if A470N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, A470N, getsymbol() );

PROC A471
  majorgrp( $ );
  { Get other answer }
  if $ = 96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A472
  majorgrp( $ );
  { Get other answer }
  if $ in 26,36,46,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A474A
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A474B
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A474C
preproc
  if copytwin(visualvalue($), ACOL41) then noinput endif;

PROC A476
preproc
  if ACOL41 <> 1 then
    skip to A479
  endif;	
  
onfocus
  pregtype = (A405 in 1,2);  
  mnthstr1 = GetLabel(A406M, A406M);
  
PROC A478
preproc
  if A232 in 1,8 then
    skip to A479
  endif;
  
onfocus
  pregtype = (A405 in 1,2);  
  mnthstr1 = GetLabel(A406M, A406M);

PROC A479
preproc
  $ = A405;
  
postproc  
  if $ <> 1 then
    skip to next ACOL41
  endif;

PROC A480
  if $ = 1 then
    skip to A482_BLOCK
  elseif A224(A404) = 1 then
    skip to A486
  else
    skip to next ACOL41  
  endif;

PROC A482_BLOCK
preproc
  { filter for A481 }
  if A480 = 2 & A224(A404) = 1 then
    skip to A486
  elseif A480 = 2 then
    skip to next ACOL41
  endif;	
	
PROC A482U
  { check special answers }
  badspecial( $, A482N, getsymbol() );

PROC A485
preproc
  if A224(A404) <> 1 then                 { Child is dead }
    skip to next ACOL41
  endif;

postproc
  { Still breastfeeding child that is not last or twin of last }
  if (A404 <= A208 - twincode(A208) - (twincode(A208) = 0)) & $ = 1 then
    warning( 4280 )
  endif;

PROC AWSEC05_FORM
preproc
  numeric fullcdc, livcdc, livcmc;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  pregvacc = 0;
  fullcdc = count(AWSEC2B where A220CD <> 0);
  if A212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if A224(i) = 1 & int((dicdc - A220CD(i))/DaysMonth) < yrsvacc*12 then
	    pregvacc = pregvacc + 1;
        do j  = i+1 while j <= totocc(AWSEC2B_ROSTER2)
          if A224(j) = 1 then
	        pregvacc = pregvacc + 1;
		  endif;
		enddo;
		break;
	  endif;
	enddo;
	indexpreg = i;
  else
    { count pregnancies based on CDC codes } 
	livcdc = 0;
	do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if A224(i) = 1 & int((dicdc - A220CD(i))/DaysMonth) < yrsvacc*12 then
	    livcdc = livcdc + 1;               // assume remaining pregnancies occurred after this one
        do j  = i+1 while j <= totocc(AWSEC2B_ROSTER2)
          if A224(j) = 1 then
	        livcdc = livcdc + 1;
		  endif;
		enddo;
		break;
	  endif; 
	enddo;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if A224(i) = 1 & di - udc(i) < yrsvacc*12 then
	    livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
        do j = i+1 while j <= totocc(AWSEC2B_ROSTER2)
          if A224(j) = 1 then
            livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
          endif; 
        enddo;
		break;
	  endif; 
	enddo;
	indexpreg2 = i;
	pregvacc = livcdc;
	if livcmc > livcdc then pregvacc = livcmc; indexpreg = indexpreg2 endif;
  endif;  
  if !pregvacc then 
    endgroup
  endif;
  AESEC5 = pregvacc;
  do i = 1 while i <= max5
    if i <= pregvacc then
      ACOL51(i) = i;
    else
      ACOL51(i) = notappl;
    endif;
  enddo;

PROC A502
  $ = ""; 
 
  if pregvacc & special(visualvalue(A503(1))) then
    showpreg456("Children for vaccination module",indexpreg,1);
  endif;

PROC AWSEC05_ROSTER
preproc
  showcard = 0;

postproc
  userbar( remove, ShowID );
  showcard = 0;
  
PROC ACOL51
preproc
  if curocc() > pregvacc then
    endgroup
  endif;

PROC A503
preproc
  numeric nextbirth = 0;
  do i = A212W while i > 0 by (-1)
    if A224(i) = 1 then
	  nextbirth = nextbirth + 1;
	  if nextbirth = ACOL51 then
	    $ = i;
		break;
	  endif;
    endif;	  
  enddo;

postproc
  A503N = A218($);
  if xmodcent & !showcard then
	ShowID = userbar( add button, tr("VaccCard"), ShowVaccCard() );
    showcard = 1;
  endif;
  
  if android then 
    setocclabel(AWSEC05_ROSTER(curocc()),maketext("%s %d/%d/%d",A218($),A220D($),A220M($),A220Y($)));
  endif;

PROC A504
  if $ in 1,3 then
    skip to A507
  endif;

PROC A505
  if A504 <> 2 then
    skip to A513;
  endif;

PROC A507
  recode A504 :: A507 -> err;
           1  ::  2,3 -> 1;
           2  ::  1,3 -> 1;
              ::      -> 0;
  endrecode;
  if err then
    errmsg( 4460, A504, A507 ) select( tr("Possession of card"), A504, tr("Observation of card"), $ );
  endif;
  if !$ in 1:3 then
    skip to A513
  endif;

PROC A508D
  if $ = 95 then
    A508M = 95;
    A508Y = 9995;
    advance to D509B
  endif;

PROC A508Y
  if A508D = 95 & A508M = 95 & A508Y = 9995 then
    // No date of birth given on card - continue
  else
    if !DateOK( A508D, A508M, A508Y, AINTD, AINTM, AINTY ) then
      errmsg( 2145 ) select( tr("Date of birth on card"), A508_BLOCK );
    endif;
	{  error message removed on purpose as per e-mail from Trevor on 9/22/2021
    if A220D(A503) <> A508D | A220M(A503) <> A508M | A220Y(A503) <> A508Y then
      warning( 4475, A508D, A508M, A508Y, A220D(A503), A220M(A503), A220Y(A503) )
	    select( tr("Date of birth on card"), A508_BLOCK,
                tr("Date of birth in pregnancy history"), A220_BLOCK(A503),
			    tr("Continue"), continue );
	endif;
	}
  endif;	
  
PROC D509B
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509B = $;
    Y509B = $*100+$;
    advance to D509H
  endif;

PROC Y509B
  vcheck  ( D509B, M509B, $ );
  vckbirth( D509B, M509B, $, A503 );

PROC D509H
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509H = $;
    Y509H = $*100+$;
    advance to D509P0
  endif;

PROC Y509H
  vcheck  ( D509H, M509H, $ );
  vckbirth( D509H, M509H, $, A503 );

PROC D509P0
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509P0 = $;
    Y509P0 = $*100+$;
    advance to D509P1
  endif;

PROC Y509P0
  vcheck  ( D509P0, M509P0, $ );
  vckbirth( D509P0, M509P0, $, A503 );

PROC D509P1
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509P1 = $;
    Y509P1 = $*100+$;
    advance to D509P2
  endif;

PROC Y509P1
  vcheck  ( D509P1, M509P1, $ );
  vckbirth( D509P1, M509P1, $, A503 );

PROC D509P2
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509P2 = $;
    Y509P2 = $*100+$;
    advance to D509P3
  endif;

PROC Y509P2
  vcheck  ( D509P2, M509P2, $ );
  vckbirth( D509P2, M509P2, $, A503 );

PROC D509P3
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509P3 = $;
    Y509P3 = $*100+$;
    advance to D509IPV
  endif;

PROC Y509P3
  vcheck  ( D509P3, M509P3, $ );
  vckbirth( D509P3, M509P3, $, A503 );

PROC D509IPV
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509IPV = $;
    Y509IPV = $*100+$;
    advance to D509D1
  endif;

PROC Y509IPV
  vcheck  ( D509IPV, M509IPV, $ );
  vckbirth( D509IPV, M509IPV, $, A503 );

PROC D509D1
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509D1 = $;
    Y509D1 = $*100+$;
    advance to D509D2
  endif;

PROC Y509D1
  vcheck  ( D509D1, M509D1, $ );
  vckbirth( D509D1, M509D1, $, A503 );

PROC D509D2
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509D2 = $;
    Y509D2 = $*100+$;
    advance to D509D3
  endif;

PROC Y509D2
  vcheck  ( D509D2, M509D2, $ );
  vckbirth( D509D2, M509D2, $, A503 );

PROC D509D3
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509D3 = $;
    Y509D3 = $*100+$;
    advance to D509D4
  endif;

PROC Y509D3
  vcheck  ( D509D3, M509D3, $ );
  vckbirth( D509D3, M509D3, $, A503 );

PROC D509D4
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509D4 = $;
    Y509D4 = $*100+$;
    advance to D509N1
  endif;

PROC Y509D4
  vcheck  ( D509D4, M509D4, $ );
  vckbirth( D509D4, M509D4, $, A503 );

PROC D509N1
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509N1 = $;
    Y509N1 = $*100+$;
    advance to D509N2
  endif;

PROC Y509N1
  vcheck  ( D509N1, M509N1, $ );
  vckbirth( D509N1, M509N1, $, A503 );

PROC D509N2
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509N2 = $;
    Y509N2 = $*100+$;
    advance to D509N3
  endif;

PROC Y509N2
  vcheck  ( D509N2, M509N2, $ );
  vckbirth( D509N2, M509N2, $, A503 );

PROC D509N3
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509N3 = $;
    Y509N3 = $*100+$;
    advance to D509R1
  endif;

PROC Y509N3
  vcheck  ( D509N3, M509N3, $ );
  vckbirth( D509N3, M509N3, $, A503 );

PROC D509R1
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509R1 = $;
    Y509R1 = $*100+$;
    advance to D509R2
  endif;

PROC Y509R1
  vcheck  ( D509R1, M509R1, $ );
  vckbirth( D509R1, M509R1, $, A503 );

PROC D509R2
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509R2 = $;
    Y509R2 = $*100+$;
    advance to D509R3
  endif;

PROC Y509R2
  vcheck  ( D509R2, M509R2, $ );
  vckbirth( D509R2, M509R2, $, A503 );

PROC D509R3
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509R3 = $;
    Y509R3 = $*100+$;
    advance to D509M1
  endif;

PROC Y509R3
  vcheck  ( D509R3, M509R3, $ );
  vckbirth( D509R3, M509R3, $, A503 );

PROC D509M1
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509M1 = $;
    Y509M1 = $*100+$;
    advance to D509M2
  endif;

PROC Y509M1
  vcheck  ( D509M1, M509M1, $ );
  vckbirth( D509M1, M509M1, $, A503 );

PROC D509M2
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509M2 = $;
    Y509M2 = $*100+$;
    advance to D509V
  endif;

PROC Y509M2
  vcheck  ( D509M2, M509M2, $ );
  vckbirth( D509M2, M509M2, $, A503 );

PROC D509V
onfocus
  if visualvalue(A512) = notappl then
    vs = D509B_VS1;
	vs.remove(66);
    setvalueset( $, vs );
  else  
    setvalueset( $, D509B_VS1 );
  endif;

postproc
  if $ in 0,44,66 then
    M509V = $;
    Y509V = $*100+$;
    advance to A510
  endif;

PROC Y509V
  vcheck  ( D509V, M509V, $ );
  vckbirth( D509V, M509V, $, A503 );

PROC A510
preproc
  if demode() = add then
    showvaccs(curocc());
  endif;

postproc
  if demode() = add & $ = 1 then
    if android then
      TakePictureA( A503 )
    else	  
      TakePictureW( A503 )
    endif;	  
  elseif $ = 6 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;  

PROC A512
preproc
  { if all vaccinations given skip A512 }
  { !! don't include Vitamin A but include other country specific }
  if vacgiven(D509B ) & vacgiven(D509H ) & vacgiven(D509P0) &
     vacgiven(D509P1) & vacgiven(D509P2) & vacgiven(D509P3) & vacgiven(D509IPV) &
     vacgiven(D509D1) & vacgiven(D509D2) & vacgiven(D509D3) & vacgiven(D509D4) &
     vacgiven(D509N1) & vacgiven(D509N2) & vacgiven(D509N3) &
     vacgiven(D509R1) & vacgiven(D509R2) & vacgiven(D509R3) &
     vacgiven(D509M1) & vacgiven(D509M2) then
    skip to A529;
  endif;

postproc
  { if any vaccinations given, including Vitamin A skip A529, otherwise A530 }
  if $ <> 1 then
    if vacgiven(D509B ) | vacgiven(D509H ) | vacgiven(D509P0) |
       vacgiven(D509P1) | vacgiven(D509P2) | vacgiven(D509P3) | vacgiven(D509IPV) |
       vacgiven(D509D1) | vacgiven(D509D2) | vacgiven(D509D3) | vacgiven(D509D4) |
       vacgiven(D509N1) | vacgiven(D509N2) | vacgiven(D509N3) |
       vacgiven(D509R1) | vacgiven(D509R2) | vacgiven(D509R3) |
       vacgiven(D509M1) | vacgiven(D509M2) | vacgiven(D509V) then
      skip to A529;
    else
      skip to next ACOL51;
    endif;
  endif;

PROC A512W
onfocus
  vaccinations.clear();
  if D509B in 0,66 then
    vaccinations.add(GetLabel(A509B), "A" );     // BCG
  endif;
  if D509H in 0,66 then
    vaccinations.add(GetLabel(A509H), "B" );     // Hepatitis B
  endif;
  if D509P0 in 0,66 then
    vaccinations.add(GetLabel(A509P0), "C" );    // Polio 0
  endif;
  if D509P1 in 0,66 then
    vaccinations.add(GetLabel(A509P1), "D" );    // Polio 1
  endif;
  if D509P2 in 0,66 then
    vaccinations.add(GetLabel(A509P2), "E" );    // Polio 2
  endif;
  if D509P3 in 0,66 then
    vaccinations.add(GetLabel(A509P3), "F" );    // Polio 3
  endif;
  if D509IPV in 0,66 then
    vaccinations.add(GetLabel(A509IPV), "G" );    // Polio IPV
  endif;
  if D509D1 in 0,66 then
    vaccinations.add(GetLabel(A509D1), "H" );    // DPT 1
  endif;
  if D509D2 in 0,66 then
    vaccinations.add(GetLabel(A509D2), "I" );    // DPT 2
  endif;
  if D509D3 in 0,66 then
    vaccinations.add(GetLabel(A509D3), "J" );    // DPT 3
  endif;
  if D509D4 in 0,66 then
    vaccinations.add(GetLabel(A509D4), "K" );    // DPT 4
  endif;
  if D509N1 in 0,66 then
    vaccinations.add(GetLabel(A509N1), "L" );    // Pneumococcal 1
  endif;
  if D509N2 in 0,66 then
    vaccinations.add(GetLabel(A509N2), "M" );    // Pneumococcal 2    
  endif;
  if D509N3 in 0,66 then
    vaccinations.add(GetLabel(A509N3), "N" );    // Pneumococcal 3
  endif;
  if D509R1 in 0,66 then
    vaccinations.add(GetLabel(A509R1), "O" );    // Rotavirus 1
  endif;
  if D509R2 in 0,66 then
    vaccinations.add(GetLabel(A509R2), "P" );    // Rotavirus 2
  endif;
  if D509R3 in 0,66 then
    vaccinations.add(GetLabel(A509R3), "Q" );    // Rotavirus 3
  endif;
  if D509M1 in 0,66 then
    vaccinations.add(GetLabel(A509M1), "R" );    // Measles 1
  endif;
  if D509M2 in 0,66 then
    vaccinations.add(GetLabel(A509M2), "S" );    // Measles 2
  endif;
  SetValueSet( $, VACCINATIONS );
  
postproc
  if !length(strip($)) then
    reenter 
  endif;	
  { set vaccination date to 66 if not given, but mother delcared that was given }
  if pos("A",$) then D509B   = 66; M509B   = D509B ;  Y509B   = D509B *101  endif;       // BCG
  if pos("B",$) then D509H   = 66; M509H   = D509H ;  Y509H   = D509H *101  endif;       // Hepatitis B
  if pos("C",$) then D509P0  = 66; M509P0  = D509P0;  Y509P0  = D509P0*101  endif;       // Polio 0
  if pos("D",$) then D509P1  = 66; M509P1  = D509P1;  Y509P1  = D509P1*101  endif;       // Polio 1
  if pos("E",$) then D509P2  = 66; M509P2  = D509P2;  Y509P2  = D509P2*101  endif;       // Polio 2
  if pos("F",$) then D509P3  = 66; M509P3  = D509P3;  Y509P3  = D509P3*101  endif;       // Polio 3
  if pos("G",$) then D509IPV = 66; M509IPV = D509IPV; Y509IPV = D509IPV*101 endif;       // Polio IPV
  if pos("H",$) then D509D1  = 66; M509D1  = D509D1;  Y509D1  = D509D1*101  endif;       // DPT 1
  if pos("I",$) then D509D2  = 66; M509D2  = D509D2;  Y509D2  = D509D2*101  endif;       // DPT 2
  if pos("J",$) then D509D3  = 66; M509D3  = D509D3;  Y509D3  = D509D3*101  endif;       // DPT 3
  if pos("K",$) then D509D4  = 66; M509D4  = D509D4;  Y509D4  = D509D4*101  endif;       // DPT 4
  if pos("L",$) then D509N1  = 66; M509N1  = D509N1;  Y509N1  = D509N1*101  endif;       // Pneumococcal 1
  if pos("M",$) then D509N2  = 66; M509N2  = D509N2;  Y509N2  = D509N2*101  endif;       // Pneumococcal 2 
  if pos("N",$) then D509N3  = 66; M509N3  = D509N3;  Y509N3  = D509N3*101  endif;       // Pneumococcal 3
  if pos("O",$) then D509R1  = 66; M509R1  = D509R1;  Y509R1  = D509R1*101  endif;       // Rotavirus 1
  if pos("P",$) then D509R2  = 66; M509R2  = D509R2;  Y509R2  = D509R2*101  endif;       // Rotavirus 2
  if pos("Q",$) then D509R3  = 66; M509R3  = D509R3;  Y509R3  = D509R3*101  endif;       // Rotavirus 3
  if pos("R",$) then D509M1  = 66; M509M1  = D509M1;  Y509M1  = D509M1*101  endif;       // Measles 1
  if pos("S",$) then D509M2  = 66; M509M2  = D509M2;  Y509M2  = D509M2*101  endif;       // Measles 2
  skip A529;

PROC A513
  if $ <> 1 then
    skip to next ACOL51
  endif;

PROC A515
  if $ <> 1 then
    skip to A517
  endif;

PROC A517
  if $ <> 1 then
    skip to A521
  endif;

PROC A521
  if $ <> 1 then
    skip to A523
  endif;

PROC A523
  if $ <> 1 then
    skip to A525
  endif;

PROC A525
  if $ <> 1 then
    skip to A527
  endif;

PROC A527
  if $ <> 1 then
    skip to A529
  endif;

PROC A529
  majorgrp( $ );
  { Get other answer }
  if $ in 16,27,36,96 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC AWSEC6A_FORM
preproc
  SaveData();
  numeric fullcdc, livcdc, livcmc;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  preghlth = 0;
  fullcdc = count(AWSEC2B where A220CD <> 0);
  if A212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if A224(i) = 1 & int((dicdc - A220CD(i))/DaysMonth) < yrshlth*12 then
	    preghlth = preghlth + 1;
        do j = i+1 while j <= totocc(AWSEC2B_ROSTER2)
          if A224(j) = 1 then
	        preghlth = preghlth + 1;
		  endif;
		enddo;
		break;
	  endif;
	enddo;
	indexpreg = i;
  else
    { count pregnancies based on CDC codes } 
	livcdc = 0;
	do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if A224(i) = 1 & int((dicdc - A220CD(i))/DaysMonth) < yrshlth*12 then
	    livcdc = livcdc + 1;               // assume remaining pregnancies occurred after this one
        do j  = i+1 while j <= totocc(AWSEC2B_ROSTER2)
          if A224(j) = 1 then
	        livcdc = livcdc + 1;
		  endif;
		enddo;
		break;
	  endif; 
	enddo;
	indexpreg = i;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if A224(i) = 1 & di - udc(i) < yrshlth*12 then
	    livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
        do j = i+1 while j <= totocc(AWSEC2B_ROSTER2)
          if A224(j) = 1 then
            livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
          endif; 
        enddo;
		break;
	  endif; 
	enddo;
	indexpreg2 = i;
	preghlth = livcdc;
	if livcmc > livcdc then preghlth = livcmc; indexpreg = indexpreg2 endif;
  endif;  
  if !preghlth then 
    endgroup
  endif;
  AESEC6 = preghlth;
  do i = 1 while i <= max5
    if i <= preghlth then
      ACOL61(i) = i;
    else
      ACOL61(i) = notappl;
    endif;
  enddo;

PROC A602
  $ = "";

  if preghlth & special(visualvalue(A603(1))) then
    showpreg456(tr("Children for child health module"),indexpreg,1);
  endif;

PROC ACOL61
preproc
  SaveData();
  if curocc() > preghlth then        { to run in-Batch }
    endgroup
  endif;

PROC A603
preproc
  numeric nextbirth = 0;
  do i = A212W while i > 0 by (-1)
    if A224(i) = 1 then
	  nextbirth = nextbirth + 1;
	  if nextbirth = ACOL61 then
	    $ = i;
		break;
	  endif;
    endif;	  
  enddo;

postproc
  A603N  = A218($);

  if android then 
    setocclabel(AWSEC6A_ROSTER(curocc()),maketext("%s %d/%d/%d",A218($),A220D($),A220M($),A220Y($)));
  endif;

PROC A608
  if $ <> 1 then
    skip to A618
  endif;	

PROC A609
onfocus
  breastfed = 0;
//  do i = 1 while i <= totocc(AWSEC04_ROSTER)
//    if A404(i) = A603 then
//      breastfed = ( A485(i) = 1 );
//	endif;
//  enddo;	
  i = seek(A404 = A603);
  if i then
    breastfed = ( A485(i) = 1 );
  endif;

PROC A611
  if $ <> 1 then
    skip to A615A;
  endif;

PROC A612
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answers }
  if pos( "F", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;
  if pos( "M", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
  if pos( "P", $ ) then
    getother( GetSymbol(), 10*curocc()+3 );
    enter FL_OTHERS
  endif;
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+4 );
    enter FL_OTHERS
  endif;

PROC A614
preproc
  { skip question if only one response in previous question }
  if length( strip(A612) ) = 1 then
    skip to A615A;
  endif;

onfocus
  sources.clear();
  do i = 1 while i <= length( strip(A612) )
    sources.add( getlabel(A612, A612[i:1]), A612[i:1] );
  enddo;
  SetValueSet( $, sources );

postproc
  if !pos( $, strip(A612) ) then
    errmsg( 4485 ) select( tr("Any treatment"), A612, tr("First treatment"), $ );
  endif;

PROC A616
onfocus
  treatment = ( A615A = 1 | A615B = 1 | A615C = 1 | A615D = 1 );

postproc
  if $ <> 1 then
    skip to A618
  endif;

PROC A617
onfocus
  treatment = ( A615A = 1 | A615B = 1 | A615C = 1 | A615D = 1 );

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A618
  if $ <> 1 then
    skip to A621;
  endif;

PROC A622
  if $ <> 1 then
    skip to A625
  endif;

PROC A623
  { Get other answer }
  if $ = 6 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;

PROC A625
preproc
  if A618 <> 1 & A622 <> 1 then
    skip to next ACOL61
  endif;

postproc
  if $ <> 1 then
    skip to A630
  endif;

PROC A626
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Get other answers }
  if pos( "F", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;
  if pos( "M", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
  if pos( "P", $ ) then
    getother( GetSymbol(), 10*curocc()+3 );
    enter FL_OTHERS
  endif;
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+4 );
    enter FL_OTHERS
  endif;

PROC A628
preproc
  { skip question if only one response in previous question }
  if length( strip(A626) ) = 1 then
    skip to A629;
  endif;

onfocus
  sources.clear();
  do i = 1 while i <= length( strip(A626) )
    sources.add( getlabel(A626, A626[i:1]), A626[i:1] );
  enddo;
  SetValueSet( $, sources );

postproc
  if !pos( $, A626 ) then
    errmsg( 4485 ) select( tr("Any treatment"), A626, tr("First treatment"), $ );
  endif;

PROC A630
  if $ <> 1 then
    skip to next ACOL61
  endif;

PROC A631
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Check "DK" is only response }
  if pos( "Z", $ ) & length(strip($)) > 1 then
    errmsg( 9996 ) select( tr("Fix answers marked"), $ );
  endif;
  { Get other answers }
  if pos( "I", $ ) then
    getother( GetSymbol(), 10*curocc()+1 );
    enter FL_OTHERS
  endif;
  if pos( "X", $ ) then
    getother( GetSymbol(), 10*curocc()+2 );
    enter FL_OTHERS
  endif;
  { if no antimalarial drug given skip to next child }
  if !pos("A", $) then
    skip to next ACOL61
  endif;
  
PROC AWSEC6B_FORM
preproc
  SaveData();
  numeric fullcdc, livcdc, livcmc;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  pregfeed = 0;
  fullcdc = count(AWSEC2B where A220CD <> 0);
  if A212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    do i = A212W while i > 0 by (-1)
      if A224(i) = 1 & A226(i) = 1 & int((dicdc - A220CD(i))/DaysMonth) < yrsfeed*12 then
	    pregfeed = i;
		break;
	  endif;
	enddo;
  else
    { count pregnancies based on CDC codes } 
	livcdc = 0;
	do i = A212W while i > 0 by (-1)
      if A224(i) = 1 & A226(i) = 1 & int((dicdc - A220CD(i))/DaysMonth) < yrsfeed*12 then
	    livcdc = i;               // assume remaining pregnancies occurred after this one
		break;
	  endif; 
	enddo;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = A212W while i > 0 by (-1)
      if A224(i) = 1 & A226(i) = 1 & di - udc(i) < yrsfeed*12 then
	    livcmc = i;               // assume remaining pregnancies occurred after this one
        break;
	  endif; 
	enddo;
	pregfeed = livcdc;
	if livcmc > livcdc then pregfeed = livcmc endif;
  endif;  
  if !pregfeed then 
    skip to A643_FIX
  endif;
  A635  = pregfeed;
  A635N = A218(pregfeed);
  
onfocus
  if !foodsid then
    foodsid = userbar(add button, tr("Foods and drinks"), FoodDrinks());
  endif;
  
killfocus
  if foodsid then
    userbar(remove,foodsid);
	foodsid = 0;
  endif;

PROC A636_INTRO
onfocus
  if drinks_popup then	// move forward to the last field if had come back due to pop-up for drinks
    drinks_popup = 0;
	advance to foodfield;
  endif;

postproc
  $ = "";

PROC A636BN
preproc
  ask if A636B = 1;

PROC A636CN
preproc
  ask if A636C = 1;

PROC A636CA
preproc
  ask if A636C = 1;

PROC A636EA
preproc
  ask if A636E = 1;

PROC A636IA
preproc
  ask if A636I = 1;

PROC A636K
preproc
  if other_drinks then
    noinput;	// value already entered, just need to advance
  endif;

postproc
  if $ = 1 & !xmodify then
    if other_drinks then
	  other_drinks = 0;
	else
	  other_drinks = 1;
      drinkgroups();
	endif;
  endif;

PROC A636KA
preproc
  ask if A636K = 1 & pos("Z",A636Z);

PROC A636Z
onfocus
  protect($, true);
  foods.clear(); $ = "";
  foods.add(replace( GetLabel(A636A), tr("Child drank: "), "" ), "A" ); if visualvalue(A636A) = 1 then $ = strip($)+"A" endif;
  foods.add(replace( GetLabel(A636B), tr("Child drank: "), "" ), "B" ); if visualvalue(A636B) = 1 then $ = strip($)+"B" endif;
  foods.add(replace( GetLabel(A636C), tr("Child drank: "), "" ), "C" ); if visualvalue(A636C) = 1 then $ = strip($)+"C" endif;
  foods.add(replace( GetLabel(A636E), tr("Child drank: "), "" ), "E" ); if visualvalue(A636E) = 1 then $ = strip($)+"E" endif;
  foods.add(replace( GetLabel(A636F), tr("Child drank: "), "" ), "F" ); if visualvalue(A636F) = 1 then $ = strip($)+"F" endif;
  foods.add(replace( GetLabel(A636G), tr("Child drank: "), "" ), "G" ); if visualvalue(A636G) = 1 then $ = strip($)+"G" endif;
  foods.add(replace( GetLabel(A636H), tr("Child drank: "), "" ), "H" ); if visualvalue(A636H) = 1 then $ = strip($)+"H" endif;
  foods.add(replace( GetLabel(A636I), tr("Child drank: "), "" ), "I" ); if visualvalue(A636I) = 1 then $ = strip($)+"I" endif;
  foods.add(replace( GetLabel(A636J), tr("Child drank: "), "" ), "J" ); if visualvalue(A636J) = 1 then $ = strip($)+"J" endif;
//foods.add(replace( GetLabel(A636K), tr("Child drank: "), "" ), "K" );  if visualvalue(A636K) = 1 then $ = strip($)+"K" endif; // don't include Other drinks
  foods.add(tr("Drinks not included in the options above"), "Z" );      if visualvalue(A636KZ) = 1 then $ = strip($)+"Z" endif;
  if drinks_popup then
    SetValueSet( $, foods );
    protect($, false);
  endif;

postproc
  A636KZ = 0;
  if pos("Z", $) then
    A636KZ = 1;
	if drinks_popup then
      getother( GetSymbol(), 0 );
      enter FL_OTHERS
    endif;	  
  endif;
  
  if pos("A", $) then A636A = 1 endif;
  if pos("B", $) then A636B = 1 endif;
  if pos("C", $) then A636C = 1 endif;
  if pos("E", $) then A636E = 1 endif;
  if pos("F", $) then A636F = 1 endif;
  if pos("G", $) then A636G = 1 endif;
  if pos("H", $) then A636H = 1 endif;
  if pos("I", $) then A636I = 1 endif;
  if pos("J", $) then A636J = 1 endif;
//if pos("K", $) then A636K = 1 endif;
  
  if drinks_popup then		// go back to intro and then move forward to the last field 
	move to A636_INTRO;
  endif;

PROC A637_INTRO
preproc
  SaveData();

onfocus
  if foods_popup then	// move forward to the last field if had come back due to pop-up for foods
    foods_popup = 0;
	advance to foodfield;
  endif;

postproc
  $ = "";

PROC A637AN
preproc
  ask if A637A = 1;

PROC A637AY
preproc
  ask if A637A = 1;

PROC A637AYA
preproc
  ask if A637AY = 1;

PROC A637V
preproc
  if other_foods then
    noinput;	// value already entered, just need to advance - see toggle below
  endif;

postproc
  if $ = 1 & !xmodify then
    if other_foods then		// toggle off or on the capture of the food groups in A637Z
	  other_foods = 0;
	else
	  other_foods = 1;
      foodgroups();
	endif;  
  endif;
  
PROC A637Z
onfocus
  protect($, true);
  foods.clear(); $ = "";
  foods.add(replace( GetLabel(A637A), "Child ate ", "" ), "A" ); if visualvalue(A637A) = 1 then $ = strip($)+"A" endif;
  foods.add(replace( GetLabel(A637B), "Child ate ", "" ), "B" ); if visualvalue(A637B) = 1 then $ = strip($)+"B" endif;
  foods.add(replace( GetLabel(A637C), "Child ate ", "" ), "C" ); if visualvalue(A637C) = 1 then $ = strip($)+"C" endif;
  foods.add(replace( GetLabel(A637D), "Child ate ", "" ), "D" ); if visualvalue(A637D) = 1 then $ = strip($)+"D" endif;
  foods.add(replace( GetLabel(A637E), "Child ate ", "" ), "E" ); if visualvalue(A637E) = 1 then $ = strip($)+"E" endif;
  foods.add(replace( GetLabel(A637F), "Child ate ", "" ), "F" ); if visualvalue(A637F) = 1 then $ = strip($)+"F" endif;
  foods.add(replace( GetLabel(A637G), "Child ate ", "" ), "G" ); if visualvalue(A637G) = 1 then $ = strip($)+"G" endif;
  foods.add(replace( GetLabel(A637H), "Child ate ", "" ), "H" ); if visualvalue(A637H) = 1 then $ = strip($)+"H" endif;
  foods.add(replace( GetLabel(A637I), "Child ate ", "" ), "I" ); if visualvalue(A637I) = 1 then $ = strip($)+"I" endif;
  foods.add(replace( GetLabel(A637J), "Child ate ", "" ), "J" ); if visualvalue(A637J) = 1 then $ = strip($)+"J" endif;
  foods.add(replace( GetLabel(A637K), "Child ate ", "" ), "K" ); if visualvalue(A637K) = 1 then $ = strip($)+"K" endif;
  foods.add(replace( GetLabel(A637L), "Child ate ", "" ), "L" ); if visualvalue(A637L) = 1 then $ = strip($)+"L" endif;
  foods.add(replace( GetLabel(A637M), "Child ate ", "" ), "M" ); if visualvalue(A637M) = 1 then $ = strip($)+"M" endif;
  foods.add(replace( GetLabel(A637N), "Child ate ", "" ), "N" ); if visualvalue(A637N) = 1 then $ = strip($)+"N" endif;
  foods.add(replace( GetLabel(A637O), "Child ate ", "" ), "O" ); if visualvalue(A637O) = 1 then $ = strip($)+"O" endif;
  foods.add(replace( GetLabel(A637P), "Child ate ", "" ), "P" ); if visualvalue(A637P) = 1 then $ = strip($)+"P" endif;
  foods.add(replace( GetLabel(A637Q), "Child ate ", "" ), "Q" ); if visualvalue(A637Q) = 1 then $ = strip($)+"Q" endif;
  foods.add(replace( GetLabel(A637R), "Child ate ", "" ), "R" ); if visualvalue(A637R) = 1 then $ = strip($)+"R" endif;
  foods.add(replace( GetLabel(A637S), "Child ate ", "" ), "S" ); if visualvalue(A637S) = 1 then $ = strip($)+"S" endif;
  foods.add(replace( GetLabel(A637T), "Child ate ", "" ), "T" ); if visualvalue(A637T) = 1 then $ = strip($)+"T" endif;
  foods.add(replace( GetLabel(A637U), "Child ate ", "" ), "U" ); if visualvalue(A637U) = 1 then $ = strip($)+"U" endif; // don't include Other foods
  foods.add(tr("Foods not included in the options above"), "Z" );
  if foods_popup then
    SetValueSet( $, foods );
    protect($, false);
  endif;

postproc
  if pos("Z", $) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
  if pos("A", $) then A637A = 1 endif;
  if pos("B", $) then A637B = 1 endif;
  if pos("C", $) then A637C = 1 endif;
  if pos("D", $) then A637D = 1 endif;
  if pos("E", $) then A637E = 1 endif;
  if pos("F", $) then A637F = 1 endif;
  if pos("G", $) then A637G = 1 endif;
  if pos("H", $) then A637H = 1 endif;
  if pos("I", $) then A637I = 1 endif;
  if pos("J", $) then A637J = 1 endif;
  if pos("K", $) then A637K = 1 endif;
  if pos("L", $) then A637L = 1 endif;
  if pos("M", $) then A637M = 1 endif;
  if pos("N", $) then A637N = 1 endif;
  if pos("O", $) then A637O = 1 endif;
  if pos("P", $) then A637P = 1 endif;
  if pos("Q", $) then A637Q = 1 endif;
  if pos("R", $) then A637R = 1 endif;
  if pos("S", $) then A637S = 1 endif;
  if pos("T", $) then A637T = 1 endif;
  if pos("U", $) then A637U = 1 endif;
  
  if foods_popup then	// go back to intro and then move forward to the last field 
	if foodfield <> "A639" then
	  move to A637_INTRO;
	else				// or if from A639, just go forward to A639
      advance to A639;
	endif;
  endif;

PROC A639
preproc
  SaveData();
  { skip if any food given }
  if (A637A = 1 | A637B = 1 | A637C = 1 | A637D = 1 | A637E = 1 | A637F = 1 |
      A637G = 1 | A637H = 1 | A637I = 1 | A637J = 1 | A637K = 1 | A637L = 1 | 
	  A637M = 1 | A637N = 1 | A637O = 1 | A637P = 1 | A637Q = 1 | A637R = 1 |
	  A637S = 1 | A637T = 1 | A637U = 1 | A637V = 1 ) then
    // we don't want to skip this if it was asked once - we want to keep the original response here.
	if special(visualvalue($)) then
      skip to A640
	endif;
  endif;

  if other_foods then
    noinput		// value already entered, just need to advance - see toggle below
  endif;

postproc
  if $ = 1 & !xmodify then
    if other_foods then		// toggle off or on the capture of the food groups in A637Z
	  other_foods = 0
	else
	  other_foods = 1;
      foodgroups();
	endif;
  endif;
  
PROC A640
preproc
  ask if ( A637A = 1 | A637B = 1 | A637C = 1 | A637D = 1 | A637E = 1 | A637F = 1 |
           A637G = 1 | A637H = 1 | A637I = 1 | A637J = 1 | A637K = 1 | A637L = 1 | 
	       A637M = 1 | A637N = 1 | A637O = 1 | A637P = 1 | A637Q = 1 | A637R = 1 | 
	       A637S = 1 | A637T = 1 | A637U = 1 | A639 = 1 );

PROC A642
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A643_FIX
preproc
// this field is included to avoid a bug related to the pop-up
  $ = 0;

postproc
  if foods_popupW then  // move forward to the last field if had come back due to pop-up for foods
    foods_popupW = 0;
    advance to foodfield;
  endif;
  
PROC A643_INTRO
preproc
  SaveData();

postproc
  $ = "";

PROC A643X
  if $ = 1 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A643XA
preproc
  ask if A643X = 1;

PROC A643Y
preproc
  if other_foodsW then
    noinput;	// value already entered, just need to advance - see toggle below
  endif;

postproc
  if $ = 1 & !xmodify then
    if other_foodsW then	// toggle off or on the capture of the food groups in A643Z
	  other_foodsW = 0
	else
	  other_foodsW = 1;
      foodgroupsW();
	endif;
  endif;	

PROC A643Z
onfocus
  protect($, true);
  foods.clear(); $ = "";
  foods.add(replace( GetLabel(A643A), "Respondent ate: ", ""), "A" ); if visualvalue(A643A) = 1 then $ = strip($)+"A" endif;
  foods.add(replace( GetLabel(A643B), "Respondent ate: ", ""), "B" ); if visualvalue(A643B) = 1 then $ = strip($)+"B" endif;
  foods.add(replace( GetLabel(A643C), "Respondent ate: ", ""), "C" ); if visualvalue(A643C) = 1 then $ = strip($)+"C" endif;
  foods.add(replace( GetLabel(A643D), "Respondent ate: ", ""), "D" ); if visualvalue(A643D) = 1 then $ = strip($)+"D" endif;
  foods.add(replace( GetLabel(A643E), "Respondent ate: ", ""), "E" ); if visualvalue(A643E) = 1 then $ = strip($)+"E" endif;
  foods.add(replace( GetLabel(A643F), "Respondent ate: ", ""), "F" ); if visualvalue(A643F) = 1 then $ = strip($)+"F" endif;
  foods.add(replace( GetLabel(A643G), "Respondent ate: ", ""), "G" ); if visualvalue(A643G) = 1 then $ = strip($)+"G" endif;
  foods.add(replace( GetLabel(A643H), "Respondent ate: ", ""), "H" ); if visualvalue(A643H) = 1 then $ = strip($)+"H" endif;
  foods.add(replace( GetLabel(A643I), "Respondent ate: ", ""), "I" ); if visualvalue(A643I) = 1 then $ = strip($)+"I" endif;
  foods.add(replace( GetLabel(A643J), "Respondent ate: ", ""), "J" ); if visualvalue(A643J) = 1 then $ = strip($)+"J" endif;
  foods.add(replace( GetLabel(A643K), "Respondent ate: ", ""), "K" ); if visualvalue(A643K) = 1 then $ = strip($)+"K" endif;
  foods.add(replace( GetLabel(A643L), "Respondent ate: ", ""), "L" ); if visualvalue(A643L) = 1 then $ = strip($)+"L" endif;
  foods.add(replace( GetLabel(A643M), "Respondent ate: ", ""), "M" ); if visualvalue(A643M) = 1 then $ = strip($)+"M" endif;
  foods.add(replace( GetLabel(A643N), "Respondent ate: ", ""), "N" ); if visualvalue(A643N) = 1 then $ = strip($)+"N" endif;
  foods.add(replace( GetLabel(A643O), "Respondent ate: ", ""), "O" ); if visualvalue(A643O) = 1 then $ = strip($)+"O" endif;
  foods.add(replace( GetLabel(A643P), "Respondent ate: ", ""), "P" ); if visualvalue(A643P) = 1 then $ = strip($)+"P" endif;
  foods.add(replace( GetLabel(A643Q), "Respondent ate: ", ""), "Q" ); if visualvalue(A643Q) = 1 then $ = strip($)+"Q" endif;
  foods.add(replace( GetLabel(A643R), "Respondent ate: ", ""), "R" ); if visualvalue(A643R) = 1 then $ = strip($)+"R" endif;
  foods.add(replace( GetLabel(A643S), "Respondent ate: ", ""), "S" ); if visualvalue(A643S) = 1 then $ = strip($)+"S" endif;
  foods.add(replace( GetLabel(A643T), "Respondent ate: ", ""), "T" ); if visualvalue(A643T) = 1 then $ = strip($)+"T" endif;
  foods.add(replace( GetLabel(A643U), "Respondent ate: ", ""), "U" ); if visualvalue(A643U) = 1 then $ = strip($)+"U" endif;
  foods.add(replace( GetLabel(A643V), "Respondent ate: ", ""), "V" ); if visualvalue(A643V) = 1 then $ = strip($)+"V" endif;
  foods.add(replace( GetLabel(A643W), "Respondent ate: ", ""), "W" ); if visualvalue(A643W) = 1 then $ = strip($)+"W" endif;
  foods.add(replace( GetLabel(A643X), "Respondent ate: ", ""), "X" ); if visualvalue(A643X) = 1 then $ = strip($)+"X" endif; // don't include Other foods
  foods.add(tr("Foods not included in the options above"), "Z" );
  if foods_popupW then
    SetValueSet( $, foods );
    protect($, false);
  endif;

postproc
  if pos("Z", $) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
  if pos("A", $) then A643A = 1 endif;
  if pos("B", $) then A643B = 1 endif;
  if pos("C", $) then A643C = 1 endif;
  if pos("D", $) then A643D = 1 endif;
  if pos("E", $) then A643E = 1 endif;
  if pos("F", $) then A643F = 1 endif;
  if pos("G", $) then A643G = 1 endif;
  if pos("H", $) then A643H = 1 endif;
  if pos("I", $) then A643I = 1 endif;
  if pos("J", $) then A643J = 1 endif;
  if pos("K", $) then A643K = 1 endif;
  if pos("L", $) then A643L = 1 endif;
  if pos("M", $) then A643M = 1 endif;
  if pos("N", $) then A643N = 1 endif;
  if pos("O", $) then A643O = 1 endif;
  if pos("P", $) then A643P = 1 endif;
  if pos("Q", $) then A643Q = 1 endif;
  if pos("R", $) then A643R = 1 endif;
  if pos("S", $) then A643S = 1 endif;
  if pos("T", $) then A643T = 1 endif;
  if pos("U", $) then A643U = 1 endif;
  if pos("V", $) then A643V = 1 endif;
  if pos("W", $) then A643W = 1 endif;
  if pos("X", $) then A643X = 1 endif;
  
  if foods_popupW then		// go back to intro and then move forward to the last field
	move to A643_FIX;
  endif;
  
PROC A701
preproc
  SaveData();

postproc
  relterms();  
  
  inunion = ( $ in 1,2 );
  if inunion then
    skip to A706A
  endif;

PROC A702
  if $ = 3 then
    skip to A721
  endif;

PROC A703
  skip to A714

PROC A706A
  if $ <> 1 then
    skip to A707
  endif;	

PROC A706B
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  
PROC A710
onfocus
  individuals.clear();
  do i = 1 while i <= AHMEMBER
    if AH04(i) = 1 & AH07(i) in 10:98,missing then
      individuals.add(AH02(i), i);
    endif;
  enddo;
  individuals.add( tr("Not a household member"), 0 );
  SetValueSet( $, individuals );
  relterms();  

postproc
  { Check if line number is out of range }
  if $ > AHMEMBER | $ = ALINE then
    errmsg( 5060 ) select( tr("Line number of husband/partner"), $ );
  elseif $ <> 0 then
    { Check partner is male }
    if AH04($) <> 1 then
      errmsg( 5061, AH04($) ) select( tr("Line number of husband/partner"), $ );
    { Check partner is at least age 15 }
    elseif AH07($) in 0:14 then
      warning( 5062, AH07($), $, 15 ) 
	    select( tr("Line number of husband/partner"), $, tr("Continue"), continue );
    endif;
    { Check relationship of respondent to partner }
    x = AH03(ALINE);
    y = AH03($);
    recode x :: y                 -> err;    { WIFE                  - HUSBAND             }
           1 :: 2                 -> 0;      { Head                  - Spouse              }
           2 :: 1                 -> 0;      { Spouse                - Head                }
           3 :: 4                 -> 0;      { Son/Daughter          - Son/Daughter in-law }
           4 :: 3                 -> 0;      { Son/Daughter in-law   - Son/Daughter        }
           5 :: 9                 -> 0;      { grandchild            - Other relative      }
           6 :: 6                 -> 0;      { Parent                - Parent              }
           7 :: 7                 -> 0;      { Parent in-law         - Parent in-law       }
           8 :: 9                 -> 0;      { Brother/Sister        - Other relative      }
           9 :: 5,8:11,98         -> 0;      { Other relative        - check codes         }
       10:11 :: 10:11             -> 0;      { Adopted/not related   - Adopted/not related }
  98,missing :: 10,11,98,missing  -> 0;      { Unknown               - check codes         }
             ::                   -> 1;      { Invalid relationships                       }
    endrecode;
    if err then
      warning( 5064, $, x, y ) 
	    select( tr("Line number of husband/partner"), $, tr("Continue"), continue );
    endif;
  endif;

PROC A711
onfocus
  relterms();  

postproc
  if $ <> 1 then
    skip to A714
  endif;

PROC A713
  if valid($) & $ > A712 then
    errmsg( 5100, $, A712 ) 
	  select( tr("Number of wives"), A712, tr("Wife rank"), $ );
  endif;

PROC A715_BLOCK
onfocus
  relterms();  

PROC A715Y
  numeric ageatm;
  { Check date of marriage before interview }
  if afterint( A715M, $, AINTM, AINTY ) then
    errmsg(  89998 ) select( tr("Date of 1st union"), A715_BLOCK );
  { Compute CMC date of marriage }
  elseif validyr($) then
    ldm = setlb( A715M, $, 0 );
    udm = setub( A715M, $, 9999 );
	ageatm = int((ldm-udb)/12);
	if ageatm < 10 then
	  warning( 5140, ageatm ) 
	    select( tr("Date of 1st union"), A715_BLOCK, 
		        tr("Continue"), continue );
	elseif ageatm > agew then
	  errmsg( 5141, ageatm, agew ) 
	    select( tr("Date of 1st union"), A715_BLOCK );
	endif;
    skip to A719M
  endif;

PROC A716
  if valid($) & $ > agew then
    errmsg( 5131, agew ) select( tr("Age at 1st union"), $ );
  endif;
  if valid($) then
    ldm = ldb+$*12;
    udm = udb+$*12+11;
    if ldm > di then
      if demode() = add then
        warning( 5130, AINTM, AINTY, A110M, A110Y, agew, A715M, A715Y, $ ) 
		  select( tr("Date of 1st union"), A715_BLOCK, 
		          tr("Age at 1st union"), $, 
				  tr("Continue"), continue );
      endif
    elseif udm > di then
      udm = di;
    endif;
  else
    { No age and year at marriage given }
    warning( 5135, $, A715M, A715Y )
	  select( tr("Date of 1st union"), A715_BLOCK, 
	          tr("Age at 1st union"), $, 
			  tr("Continue"), continue );
    { Set outer ranges for date of marriage }
    ldm = ldb+minam;
    udm = di;
  endif;

PROC A719_BLOCK
onfocus
  relterms();  

PROC A719M
preproc
  if A714 = 1 | !inunion then
    skip to A721
  endif;	

PROC A719Y
  numeric ageatm;
  { Check date of marriage before interview }
  if afterint( A719M, $, AINTM, AINTY ) then
    errmsg( 89998 ) select( tr("Date of current union"), A719_BLOCK );
  { Check current date of marriage after date of first marriage }
  elseif afterint( A715M, A715Y, A719M, $ ) then
    errmsg( 89997, A715M, A715Y ) 
	  select( tr("Date of 1st union"), A715_BLOCK, 
	          tr("Date of current union"), A719_BLOCK );
  { Compute CMC date of marriage }
  elseif validyr($) then
    ldm = setlb( A719M, $, 0 );
    udm = setub( A719M, $, 9999 );
	ageatm = int((ldm-udb)/12);
	if ageatm < 10 then
	  warning( 5140, ageatm ) 
	    select( tr("Date of current union"), A719_BLOCK, 
		        tr("Continue"), continue )
	elseif ageatm > agew then
	  errmsg( 5141, ageatm, agew ) 
	    select( tr("Date of current union"), A719_BLOCK );
	endif;
    skip to A721
  endif;

PROC A720
onfocus
  relterms();  

postproc
  if valid($) & $ > agew then
    errmsg( 5131, agew ) 
	  select( tr("Age at current union"), $ );
  elseif valid($) & valid(A716) & $ < A716 then
    errmsg( 5132, A716 )  
	  select( tr("Age at current union"), $, 
	          tr("Age at 1st union"), A716 );
  endif;
  if valid($) then
    ldm = ldb+$*12;
    udm = udb+$*12+11;
    if ldm > di then
      if demode() = add then
        warning( 5130, AINTM, AINTY, A110M, A110Y, agew, A719M, A719Y, $ )
		  select( tr("Date of current union"), A719_BLOCK, 
		          tr("Age at current union"), A720,
			      tr("Continue"), continue );
      endif
    elseif udm > di then
      udm = di;
    endif;
  else
    { No age and year at marriage given }
    warning( 5135, $, A719M, A719Y )
	  select( tr("Date of current union"), A719_BLOCK, 
	          tr("Age at current union"), A720,
			  tr("Continue"), continue );
  endif;

PROC A721
  $ = "";

PROC A722
  { Set up ever married status for later use }
  evermarr = ( A701 in 1,2 | A702 in 1,2 );

  if $ = 0 then
    if A212W > 0 | A232 <> 2 then
      errmsg( 5150 ) select( tr("Age at first intercourse"), $ );
    elseif evermarr then
      if demode() = add then
        warning( 5151 ) 
		  select( tr("Age at first intercourse"), $, 
		          tr("Marital status"), A701,
		          tr("Continue"), continue );
      endif
    endif;
  elseif $ = 95 & A702 = 3 then
    errmsg( 5192 ) select( tr("Age at first intercourse"), $ );
  elseif valid($) & $ < 95 & demode() = add then
    if $ > agew then
      warning( 5190, AINTM, AINTY, A110M, A110Y, agew, $ )
	    select( tr("Age at first intercourse"), $, 
 		        tr("Current age"), A111, 
		        tr("Continue"), continue );
    elseif A212W & $*12 > udc(1)-ldb-7 then
      warning( 5191, A220M(1), A220Y(1), A110M, A110Y, $ )
	    select( tr("Age at first intercourse"), $, 
		        tr("Date of first pregnancy"), A220_BLOCK(1), 
				tr("Continue"), continue );
    endif
  endif;
  { skips if never had sex }
  if $ = 0 then
    skip to A738A;
  endif;

PROC A723N
onfocus
  protect( A723U, false );

PROC A723U
preproc
  if A723N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { check special answers }
  badspecial( $, A723N, getsymbol() );

  recode A723U :: A723N  -> err;
           3   :: >=12   -> 1;
           2   :: >=52   -> 1;
         <>1   ::  0     -> 1;
               ::        -> 0;
  endrecode;
  if err then
    errmsg( 9994 ) select( tr("Number"), A723N, tr("Unit"), A723U );
  elseif A723U = 4 & A723N > agew then
    errmsg( 5193, A723U, A723N, agew )
	  select( tr("Time since last sex"), A723_BLOCK, 
 	          tr("Current age"), A111, 
		      tr("Continue"), continue );
  endif;
  { skips if sex more than a year ago }
  if A723U in 4,9 then
    skip to A737
  endif;

PROC A725
preproc
  if A232 = 1 then
    skip to A727
  endif;

postproc
  if $ <> 1 & A307N <> notappl then
    warning( 3160, GetValuelabel(A307N) )
      select( tr("Method used during last sex"), $,
		      tr("Method used"), A307,
		      tr("Continue"), continue );
  endif;
  if $ <> 1 then
    skip to A727
  endif;	

PROC A726
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

  { Check all methods are known  }
  {!!! assumes a one to one correspondence between current method and contraceptive table }
  y = length( strip(A726) );
  do x = 1 while x <= y 
    meth = pos( $[x:1], a307str );
    if A301(meth) <> 1 then
      warning( 3143, GetLabel(A726, $[x:1]) )
	    select( tr("Method used during last sex"), $,
		        tr("Knowledge of method"), A301(meth),
		        tr("Continue"), continue );
    endif;
  enddo;
  
  if poschar("GH",$) then
    skip to A728
  endif;

PROC A727
  if $ <> 1 then
    skip to A730
  endif;

PROC A728
  { Get other answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A729
  majorgrp( $ );
  { Get other answer }
  if $ in 16,27,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A730
  if $ in 1 & !evermarr then
    warning( 5240, A701, A702 )
      select( tr("Relationship with last sex partner"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  elseif $ = 2 & A702 = 3 then
    warning( 5241, A701, A702 )
      select( tr("Relationship with last sex partner"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A731
  if $ <> 1 then
    skip to A737
  endif;

PROC A733
  if $ in 1 & !evermarr then
    warning( 5240, A701, A702 )
      select( tr("Relationship with prior sex partner"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  elseif $ = 2 & A702 = 3 then
    warning( 5241, A701, A702 )
      select( tr("Relationship with prior sex partner"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "A730", 1 );
    enter FL_OTHERS
  endif;

PROC A734
  if $ <> 1 then
    skip to A737
  endif;

PROC A736
  if $ in 1 & !evermarr then
    warning( 5240, A701, A702 )
      select( tr("Relationship with third prior sex partner"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  elseif $ = 2 & A702 = 3 then
    warning( 5241, A701, A702 )
      select( tr("Relationship with third prior sex partner"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "A730", 2 );
    enter FL_OTHERS
  endif;

PROC A737
  { minimum should be at 1 + (1 if A731=1) + (1 if A734=1) }
  sexp = 1 + (A731 = 1) + (A734 = 1);
  if valid($) & $ < sexp then
    warning( 5245, sexp )
      select( tr("Lifetime number of sex partners"), $, tr("Continue"), continue );
  endif;

PROC A738C
  SaveData();

PROC A803
preproc
  { skip if respondent or partner sterilized }
  if A307N in stermeth,stermetm then
    skip to A813
  { skip if pregnant }
  elseif A232 <> 1 then
    skip to A804
  endif;

postproc
  if $ = 1 then
    skip to A805N
  else
    skip to A812
  endif;

PROC A804
  if $ = 2 then
    skip to A810
  elseif $ = 3 then
    skip to A813
  elseif $ <> 1 then
    skip to A812
  endif;

PROC A805N
onfocus
  protect( A805U, false );

postproc
  { check consistency with current marital status }
  if $ = 95 & inunion then
    warning( 6032, A701 )
      select( tr("Timing for future birth"), A805_BLOCK,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  elseif $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A805U
preproc
  if A805N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, A805N, getsymbol() );

  { Check for response of < 9 months }
  if A805U = 1 & A805N < 9 & demode() = add then
    warning( 6031 )
	  select( tr("Time to wait for future birth"), A805N, tr("Continue"), continue );
  endif;

  if A805U = 9 then
    if A805N = 94 then
      skip to A813
    else
      skip to A812
    endif
  endif;

PROC A810
preproc
  { if pregnant }
  if A232 = 1 then
    skip to A812
  { if currently using }
  elseif A307N <> notappl then
    skip to A813
  { A808 filter }
  elseif A805U = 1 & A805N in 0:23 |
         A805U = 2 & A805N in 0:1  then
    skip to A812
  elseif !A723U in 1:3 then
    skip to A812
  endif;

postproc
  majorgrp_a( $ );
  $ = SortAlpha( $ );
  { Check "DK" is only response }
  if pos("Z",$) & length(strip($)) > 1 then
    errmsg( 9996 ) select( tr("Fix answers marked"), $ );
  endif;
  { "Not married", but in union }
  if pos( "A", $ ) & inunion then
    warning( 6100, A701 )
      select( tr("Reason not using"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  endif;
  { "Knows no method", but knows methods }
  if pos( "M", $ ) & count( AWSEC3A_GRP where A301 = 1 ) then
    warning( 6101 )
      select( tr("Reason not using"), $,
	          tr("Knowledge of methods"), A301(1),
		      tr("Continue"), continue );
  endif;
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A812
preproc
  { currently using a method }
  if A307N <> notappl then
    skip to A813
  endif;

PROC A813
onfocus
  lchild = count( AWSEC2B_ROSTER2 where A224 = 1 );

postproc
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS;
  endif;

  if $ in 0,96,missing then
    skip to A815A
  endif;

PROC A814B
preproc
  if A814A = 96 then
    $ = 96;
    noinput
  endif;

postproc
  if ($ = 96 <=> A814A <> 96) | ($ = missing <=> A814A <> missing) then
    errmsg( 9994 ) select( tr("Boys"), A814A, tr("Girls"), A814B, 
	                       tr("Either"), A814C, tr("Total"), A813 );
  endif;

PROC A814C
preproc
  if A814A = 96 then
    $ = 96;
    noinput
  endif;

postproc
  if ($ = 96 <=> A814A <> 96) | ($ = missing <=> A814A <> missing) then
    errmsg( 9994 )
      select( tr("Ideal number of children by sex"), A814_BLOCK,
	          tr("Ideal number of children" ), A813 );
  elseif valid(A814A) & valid(A814B) & valid($) & $ < 96 & A814A+A814B+$ <> A813 then
    errmsg( 6131 )
      select( tr("Ideal number of children by sex"), A814_BLOCK,
	          tr("Ideal number of children"), A813 );
  endif;

  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A818
preproc
  { skip if not in union }
  if !inunion then
    endgroup
  endif;
  
onfocus
  relterms();  

postproc
  if $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  if $ <> 3 then
    skip to A820
  endif;	

PROC A819
onfocus
  relterms();  
  
PROC A820
onfocus
  relterms();  
  
PROC A822
preproc
  SaveData();
  { skip if m/f sterilization }
  if A307N in stermeth,stermetm then
    endgroup
  endif;
  
onfocus
  relterms();  

PROC A902
preproc
  if !inunion then
    skip to A909
  endif;
  
onfocus
  relterms();  

PROC A903
onfocus
  relterms();  

postproc
  if $ = 2 then
    skip to A906
  endif;

PROC A904
  if $ = 8 then
    skip to A906
  endif;

PROC A905
onfocus
  textstr1 = GetValueLabel(A904);

  grades.clear();
  grades.add(tr("Less than one year"), 0);
  n = maxgrade(A904);
  do i = 1 while i <= n
    grades.add(maketext("Year %d", i), i);
    // change the above to match the terms used in the country
    // e.g. it might be "Year" that is used in most levels, but "Form" is used in secondary schooling
    // if A114 = 2 then
    //   grades.add(maketext("Form %d", i), i);
    // else
    //   grades.add(maketext("Year %d", i), i);
    // endif;
  enddo;
  SetValueSet( $, grades );

postproc
  { Verify the maximum grade for the level }
  if !LevelYears( A904, $ ) then
    errmsg( 7051 ) 
	  select( tr("Partner's level of education"), A904, 
	          tr("Partner's grade/year/form"), $ );
  endif;

PROC A906
onfocus
  relterms();  
  
postproc
  if $ = 1 then
    skip to A908
  endif;

PROC A907
onfocus
  relterms();  
  
postproc  
  if $ <> 1 then
    skip to A909
  endif;

PROC A908
onfocus
  relterms();  

postproc
  { !!! it is possible that all textual occupation needs to recorded }
  if $ = 96 then           { !!!! Other occupation should be coded as 96 }
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A909
  if $ = 1 then
    skip to A913
  endif;

PROC A910
  if $ = 1 then
    skip to A913
  endif;

PROC A911
  if $ = 1 then
    skip to A913
  endif;

PROC A912
  if $ <> 1 then
    skip to A919
  endif;

PROC A913
  { !!! it is possible that all textual occupation needs to recorded }
  if $ = 96 then             { !!!! Other occupation should be coded as 96 }
    getother( "A908", 1 );   { !!! record others occupation in the question same }
    enter FL_OTHERS
  endif;

PROC A919
preproc
  if !inunion then
    skip to A925
  elseif !A916 in 1,2 then
    skip to A921
  endif;
  
onfocus
  relterms();  

postproc
  if $ in 2,3 & !inunion then
    warning( 7250, $, A701 )
      select( tr("Person deciding how earnings are used"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A920
onfocus
  relterms();  

postproc
  if $ = 4 then
    skip to A922
  endif;

PROC A921
onfocus
  relterms();  

postproc
  if $ in 2,3 & !inunion then
    warning( 7250, $, A701 )
      select( tr("Person deciding how husband's earnings are used"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A922
onfocus
  relterms();  

postproc
  if $ in 2,3 & !inunion then
    warning( 7250, $, A701 )
      select( tr("Final say on health care"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  endif;

PROC A923
  if $ in 2,3 & !inunion then
    warning( 7250, $, A701 )
      select( tr("Final say on large purchases"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  endif;

PROC A924
  if $ in 2,3 & !inunion then
    warning( 7250, $, A701 )
      select( tr("Final say on visits to family"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  endif;

PROC A925
onfocus
  if evermarr then
    setvalueset( $, A925_VS1 );
  else // exclude the husband/partner options for never married
    vs = A925_VS1;
    vs.remove(2);
    vs.remove(4);
    setvalueset( $, vs );
  endif;
  
 
postproc 
  if $ = 6 then
    skip to A928
  endif;

PROC A926
  if $ <> 1 then
    skip to A928
  endif;

PROC A928
onfocus
  if evermarr then
    setvalueset( $, A928_VS1 );
  else // exclude the husband/partner options for never married
    vs = A928_VS1;
    vs.remove(2);
    vs.remove(4);
    setvalueset( $, vs );
  endif;

postproc
  if $ = 6 then
    skip to A930A
  endif;

PROC A929
  if $ <> 1 then
    skip to A930A
  endif;

PROC A930A
  if $ <> 1 then
    skip to A930C
  endif;

PROC A931B
  if $ in 1,2 & !inunion then
    warning( 7250, $, A701 )
      select( tr("Presence of husband/partner"), $,
	          tr("Marital status"), A701,
		      tr("Continue"), continue );
  endif;

PROC A932E
  SaveData();

PROC A1000
  $ = "";

PROC A1001
  if $ <> 1 then
    skip to A1040
  endif;
  
PROC A1003
preproc
  if agew >= 25 then
    skip to A1008
  endif;

PROC A1010
  if $ <> 1 then
    skip to A1014
  endif;	

PROC A1014
preproc
  { skip if no children born after feeding year }
  births2 = 0;
  do i = 1 while i <= totocc(AWSEC04_ROSTER)
    idx = A404(i);
    if A405(i) = 1 & ( int((dicdc - A220CD(idx))/DaysMonth) < yrsfeed*12 | di - udc(idx) < yrsfeed*12 ) then
      births2 = i;
	  break;
    endif;
  enddo;
  if !births2 then
    skip to A1024
  elseif A412(births2) <> 1 then
    skip to A1019
  endif;

postproc
  $ = "";

PROC A1015
  if $ <> 1 then
    skip to A1019
  endif;	

PROC A1016
  majorgrp( $ );
  if $ in 16,27,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A1019
preproc
  if !A435(births2) in 21:46 then
    skip to A1022
  endif;

postproc
  if $ <> 1 then
    skip to A1022
  endif;

PROC A1022
preproc
  if A1015 <> 1 & A1019 <> 1 then
    skip to A1024
  endif;

postproc
  if $ = 1 then
    skip to A1025M
  endif;

PROC A1023Y
  if afterint(A1023M,$,AINTM,AINTY) then
	errmsg( 89998 ) select( tr("Date most recent HIV test"), A1023_BLOCK );
  endif;
  ldth = setlb( A1023M, A1023Y, 0 );
  if ldth < ldb then
    errmsg( 11012, A110M, A110Y ) select( tr("Date most recent HIV test"), A1023_BLOCK );
  endif;
  skip to A1028;

PROC A1024
  if $ <> 1 then
    skip to A1032
  endif;

PROC A1025Y
  if afterint(A1025M,$,AINTM,AINTY) then
	errmsg( 89998 ) select( tr("Date most recent HIV test"), A1025_BLOCK );
  endif;
  ldth = setlb( A1025M, A1025Y, 0 );
  if ldth < ldb then
    errmsg( 11012, A110M, A110Y ) select( tr("Date most recent HIV test"), A1023_BLOCK );
  endif;

PROC A1026
  majorgrp( $ );
  if $ in 16,27,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A1027
  if $ <> 1 then
    skip to A1031
  endif;

PROC A1028
// Add in a test for code 5 versus A1027 = 1, or restrict valueset if coming from A1027 (code is needed if coming from A1023)
  if $ <> 1 then
    skip to A1031
  endif;	

PROC A1029M
  if $ = 95 then
    skip to A1030
  endif;

PROC A1029Y
  if afterint(A1029M,$,AINTM,AINTY) then
	errmsg( 89998 ) select( tr("Date tested positive"), A1029_BLOCK );
  endif;
  udth = setlb( A1029M, A1029Y, 9999 );
  if udth > ldth+1 then   // give one month to allow time to get results from last test
    if A1023M <> notappl then
      errmsg( 11010 ) select( tr("Date tested positive"), A1029_BLOCK,
                              tr("Date most recent HIV test"), A1023_BLOCK );
    else
      errmsg( 11010 ) select( tr("Date tested positive"), A1029_BLOCK,
                              tr("Date most recent HIV test"), A1025_BLOCK );
    endif;							  
  endif;
  if udth < ldb then
    errmsg( 11011, A110M, A110Y ) select( tr("Date tested positive"), A1029_BLOCK );
  endif;

PROC A1032
  if $ <> 1 then
    skip to A1034
  endif;
  
PROC A1037
preproc  
  if A1028 <> 1 then
    skip to A1040
  endif;	

PROC A1043
preproc
  if A722 = 0 then
    skip to A1046;
  elseif A1040 <> 1 then
    skip to A1044
  endif;

PROC A1049
preproc
  SaveData();
  if !inunion then
    endgroup;
  endif;

onfocus
  relterms();  

PROC A1102
  majorgrp( $ );
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A1104
  $ = "";

PROC A1106
  if $ <> 1 then
    skip to A1108
  endif;

PROC A1108
  if !$ in 1,2 then
    skip to A1110
  endif;

PROC A1109
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC A1110
  if $ <> 1 then
    skip to A1113A
  endif;	

PROC A1111
  if $ = 0 then
    skip to A1113A
  endif;

PROC A1114
  if $ <> 1 then
    endgroup
  endif;

PROC A1115
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

{ @@@ Begin Chronic Disease Module for Women }
PROC ACHD02
  if $ <> 1 then
    skip to ACHD06
  endif;

PROC ACHD07
  if $ <> 1 then
    skip to ACHD11
  endif;

PROC ACHD11
  if $ <> 1 then
    skip to ACHD13
  endif;

PROC ACHD13
  if $ <> 1 then
    skip to ACHD15
  endif;

PROC ACHD15
  if $ <> 1 then
    skip to ACHD17A
  endif;  

PROC ACHD19
preproc
  if ACHD17A <> 1 & ACHD17B <> 1 then
    skip to ACHD20
  endif;

PROC ACHD20
  if $ <> 1 then
    skip to ACHD22
  endif;

PROC ACHD22
  { Get other answer }
  if $ = 1 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  else
    skip to ACHD24
  endif;

PROC ACHD24
  if $ <> 1 then
    skip to ACHD27
  endif;

PROC ACHD27
  if $ <> 1 then
    endgroup
  endif;

PROC ACHD28
  { age with years since last cervical cancer }
  if valid($) & $ > agew - 10 then
    warning( 9010, agew ) 
	  select( tr("Last cervical cancer test"), $, tr("Continue"), continue);
  endif;

PROC ACHD29
  if $ in 1,5,8 then
    endgroup
  elseif $ = 4 then
    skip to ACHD33  
  endif;
  
PROC ACHD30
  if $ <> 1 then
    skip to ACHD33
  endif;

PROC ACHD32
  endgroup;
  
{ @@@ Begin Mental Health Module for Women }
PROC AMTH2
preproc
  numeric symptoms;
  symptoms = (AMTHGAD1 in 1:3) + (AMTHGAD2 in 1:3) + (AMTHGAD3 in 1:3) + (AMTHGAD4 in 1:3) + 
             (AMTHGAD5 in 1:3) + (AMTHGAD6 in 1:3) + (AMTHGAD7 in 1:3) + 
			 (AMTHPHQ1 in 1:3) + (AMTHPHQ2 in 1:3) + (AMTHPHQ3 in 1:3) + (AMTHPHQ4 in 1:3) + 
			 (AMTHPHQ5 in 1:3) + (AMTHPHQ6 in 1:3) + (AMTHPHQ7 in 1:3) + (AMTHPHQ8 in 1:3) + 
			 (AMTHPHQ9 in 1:3); 
  if !symptoms then			 
    skip to AMTH4A
  endif;	
  
postproc  
  if $ <> 1 then			 
    skip to AMTH4A
  endif;	

PROC AMTH3
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AMTH6
preproc
  $ = ScorePHQ(AMTHPHQ1) + ScorePHQ(AMTHPHQ2) + ScorePHQ(AMTHPHQ3) + ScorePHQ(AMTHPHQ4) + 
	  ScorePHQ(AMTHPHQ5) + ScorePHQ(AMTHPHQ6) + ScorePHQ(AMTHPHQ7) + ScorePHQ(AMTHPHQ8) + 
	  ScorePHQ(AMTHPHQ9); 
	  
PROC AMTH8
preproc
  if !(AMTH6 >= 10 | AMTHPHQ9 in 1:3) then
    endgroup
  endif;	
	  
PROC AMM00
preproc
  $ = 1;

{ @@@ Begin Maternal Mortality Module for Women }
PROC AMM01N
preproc
  if $ <> "" then
	advance to AMM01
  endif;

postproc
  if $(1) = "" then
    warning( 9110 ) 
	  select( tr("Modify"), $, tr("Continue"), continue);
	skip to AMM03
  endif;

PROC AMM01
preproc
  if visualvalue(AMM10) = notappl then	{leave order number blank for now and return to fill order number after AMM10}
	skip to AMMMORE
  endif;

postproc
  do i = curocc()-1 while i by (-1)
    if AMM01 = AMM01(i) then
      errmsg( 9120, AMM01, AMM01(i) ) select( tr("Order numbers"), AMM01 );
  	endif;
  enddo;

PROC AMMMORE
preproc
  if AMM01 <> notappl then  { Don't ask about more if already got full list and now getting order }
    noinput
  endif;

postproc
  if $ <> 1 then		{ this is the last sibling }
    endgroup
  endif;

PROC AMM03
preproc
  NSibs = count( AWSIBL_ROSTER where AMM01N <> "" );
  xMM03 = visualvalue(AMM03);
  xMM04 = visualvalue(AMM04);
  xMM05 = visualvalue(AMM05);
  xMM06 = visualvalue(AMM06);
  xMM08 = visualvalue(AMM08);
  xMM10 = visualvalue(AMM10);
  if NSibs = 0 then 
    skip to AMM04;
  endif;
  if     xMM08 <> notappl then advance to AMM08
  elseif xMM06 <> notappl then advance to AMM06
  elseif xMM05 <> notappl then advance to AMM05
  elseif xMM04 <> notappl then advance to AMM04
  endif;

postproc
  if $ = 1 & xMM03 <> 1 then
    if AMM01N(1) = "" then
      reenter AMM00
    else
      {AMMMORE(NSibs)=1;}
      reenter AMMMORE(NSibs);
	endif;
  endif;

PROC AMM04
preproc
  if     xMM08 <> notappl then advance to AMM08
  elseif xMM06 <> notappl then advance to AMM06
  elseif xMM05 <> notappl then advance to AMM05
  endif;

postproc
  if $ = 1 & xMM04 <> 1 then
    if AMM01N(1) = "" then
      reenter AMM00
    else
      {AMMMORE(NSibs)=1;}
      reenter AMMMORE(NSibs);
    endif;
  endif;

PROC AMM05
preproc
  if     xMM08 <> notappl then advance to AMM08
  elseif xMM06 <> notappl then advance to AMM06
  endif;

postproc
  if $ = 1 & xMM05 <> 1 then
    if AMM01N(1) = "" then
      reenter AMM00
    else
      {AMMMORE(NSibs)=1;}
      reenter AMMMORE(NSibs);
    endif;
  endif;

PROC AMM06
  if $ = 1 & xMM06 <> 1 then
    if AMM01N(1) = "" then
      reenter AMM00
    else
      {AMMMORE(NSibs)=1;}
      reenter AMMMORE(NSibs);
    endif;
  endif;

PROC AMM07
preproc
  $ = NSibs;

postproc
  if $ <> NSibs then
    errmsg( 9121, $, NSibs ) select( tr("Number of siblings"), AMMMORE(NSibs) );
  endif;

PROC AMM08
  if $ = 2 then
    if AMM01N(1) = "" then
      reenter AMM00
    else
      reenter AMMMORE(NSibs);
    endif;
  elseif AMM07 = 0 then	{no brother or sister and is correct}
    endgroup
  endif;

PROC AMM10
  { since total number of sibling is correct, now go back and enter order number of all the siblings }
  if $ = 1 then { go back and enter order number }
    if AMM01N(1) = "" then
      reenter AMM00
    else
      reenter AMM01N(1)
    endif;
  else
    if AMM01N(1) <> "" & AMM01(1) = notappl then
      errmsg( 9113 ) select( tr("Introduction Maternal Mortality"), AMM00 );
    endif;
  endif;

  if count(AMM01 where AMM01N <> "" & AMM01 in 1:NSibs) <> NSibs then
    errmsg( 9114, NSibs ) select( tr("Order numbers"), AMM01(1) );
  endif;

  { Check order number min=1, max=NSibs, no duplicate... }
  do i = 1 while i <= NSibs
    { check duplicate order number }
    do j = 1 while j <= NSibs
      if AMM01(i) = AMM01(j) & i <> j then
        errmsg( 9115, AMM01(i), i, j ) 
		  select( maketext( tr("Order number for") + " %s", AMM01N(i)), AMM01(i),
		          maketext( tr("Order number for") + " %s", AMM01N(j)), AMM01(j) );
      endif;
    enddo;
  enddo;

PROC AMM11
  if $ > AMM07 then
    errmsg( 9002 ) select( tr("Siblings born before respondent"), $ );
  endif;

  SaveData();

{ Maternal Mortality post-processing }
	
PROC AWSECM2_FORM
preproc
  { skip maternal mortality if there are no siblings }
  if AMM07 = 0 then
    endgroup
  endif;

  if !matmortid then
    matmortid = userbar( add button, tr("Siblings"), showroster(2) );
  endif;

PROC AWSECMM_ROSTER
  err  = 0;
  aold = 100;
  iold = 0;
  if AMM11 = 0 then
    aold = A111;
  endif;
  aoldest = aold;

  for i in $ do
    anew = aold;

    if AMM15 = 1 then           { sibling is still alive }
      if valid(AMM16) then      { sibling's age is valid }
        anew = AMM16;
      endif
    elseif AMM15 = 2 then       { sibling has died }
      if valid(AMM18) then      { age when they died }
        anew = AMM18;
        if valid(AMM17) then    { how many yrs ago did they die }
          anew = anew + AMM17
        endif;
      elseif valid(AMM17) then  { # yrs ago when they died }
        anew = AMM17            { Age would be at least this, probably more }
      endif;
    endif;

    if anew > aold then
      warning( 9000, i, anew, iold, aold )
	    select( maketext( tr("Status for") + " %s", AMM13N(i) ), AMM15(i),
	            maketext( tr("Status for") + " %s", AMM13N(iold) ), AMM15(iold),
				tr("Continue"), continue );
      err  = 1;
    elseif valid(AMM16) | valid(AMM17) & valid(AMM18) then
      aold = anew;
      iold = i;
    endif;

    if AMM11 = i then            { Check respondent against siblings }
      if A111 > aold then
        warning( 9000, 0, A111, iold, aold )
	      select( tr("Siblings born before respondent"), AMM11,
	              maketext( tr("Status for") + " %s", AMM13N(iold) ), AMM15(iold),
				  tr("Continue"), continue );
        err  = 1;
      else
        aold = A111;
        anew = A111;
        iold = 0;
      endif;
    endif;

    if aoldest = 100 then
      aoldest = aold;
    endif;

  enddo;

  if AMM07 > 1 & (aoldest - aold) > 30 then
    warning( 9001, aoldest, aold )
	  select( tr("Status for first sibling"), AMM15(1), tr("Continue"), continue );
  endif;
  if err then
    showroster( 2 );
  endif;

PROC AMM13
preproc
  do i = 1 while i <= maxsib
    if i <= AMM07 then
      AMM13(i)  = i;
{     AMM13N(i) = AMM01N(i);  }
 	    do j = 1 while j <= maxsib { & i <> AMM01(j) }
        if i = AMM01(j) then
          AMM13N(i) = AMM01N(j);
          break;
        endif;
      enddo;
    else
      AMM13(i) = notappl
    endif;
  enddo;
  SaveData();

  if curocc() > AMM07 then  { to run in-Batch }
    endgroup
  endif;

PROC AMM15
  if $ = 2 then
    skip to AMM17
  elseif $ <> 1 then
    skip to next AMM13
  endif;

PROC AMM16
  skip to next AMM13;

PROC AMM18
  if !valid($) | $ < 12 | AMM14 <> 2 then
    skip to AMM23
  endif;

PROC AMM19
  if $ = 1 then
    skip to AMM23
  endif;

PROC AMM20
  if $ = 1 then
    skip to next AMM13
  endif;

PROC AMM21
  if $ <> 1 then
    skip to AMM23
  endif;

PROC AMM23
  if $ = 1 then
    skip to next AMM13
  endif;
{ @@@ End Maternal Mortality for Women }

{ @@@ Begin Domestic Violence }
PROC DV01
preproc
  { check if woman is selected for domestic violence }
  if AVIOLEN <> 1 then
    endgroup
  endif;

postproc
  if $ <> 1 then
    // skip to capture reason for not completing DV module in a note?
    skip to DV37
  endif;

PROC DV02
  $ = "";

PROC DV04
preproc
  anyviol = 0;

  if evermarr then
    skip to DV06A1
  endif;

postproc
  relterms2();
  if $ = 1 then
    skip to DV06A1
  endif;

PROC DV05
  if $ <> 1 then
    skip to DV20
  endif;

PROC DV06A1
onfocus
  relterms2();

PROC DV06A2
preproc
  ask if DV06A1 = 1;
  
PROC DV06B2
preproc
  ask if DV06B1 = 1;
  
PROC DV06C2
preproc
  ask if DV06C1 = 1;
  
PROC DV06D2
preproc
  ask if DV06D1 = 1;
  
PROC DV06E2
preproc
  ask if DV06E1 = 1;
  
PROC DV07A1
onfocus
  relterms2();
PROC DV07A2
preproc
  ask if DV07A1 = 1;

PROC DV07B2
preproc
  ask if DV07B1 = 1;

PROC DV07C2
preproc
  ask if DV07C1 = 1;

PROC DV08A1
onfocus
  relterms2();
PROC DV08A2
preproc
  ask if DV08A1 = 1;

PROC DV08B2
preproc
  ask if DV08B1 = 1;

PROC DV08C2
preproc
  ask if DV08C1 = 1;

PROC DV08D2
preproc
  ask if DV08D1 = 1;

PROC DV08E2
preproc
  ask if DV08E1 = 1;

PROC DV08F2
preproc
  ask if DV08F1 = 1;

PROC DV08G2
preproc
  ask if DV08G1 = 1;

PROC DV08H2
preproc
  ask if DV08H1 = 1;

PROC DV08I2
preproc
  ask if DV08I1 = 1;

PROC DV08J2
preproc
  ask if DV08J1 = 1;

PROC DV10_BLOCK
preproc
  anyviol = ( DV08A1 = 1 | DV08B1 = 1 | DV08C1 = 1 | DV08D1 = 1 | DV08E1 = 1 |
              DV08F1 = 1 | DV08G1 = 1 | DV08H1 = 1 | DV08I1 = 1 | DV08J1 = 1 );
  if !anyviol then		
    skip to DV11
  endif;

onfocus
  relterms2();
PROC DV11
onfocus
  relterms2();

postproc
  if $ <> 1 then
    skip to DV13
  endif;

PROC DV12
onfocus
  relterms2();
PROC DV13
onfocus
  relterms2();

postproc
  if $ <> 1 then
    skip to DV15
  endif;

PROC DV15
onfocus
  relterms2();
PROC DV16A1
onfocus
  relterms2();

postproc
  if $ = 6 then
    skip to DV18
  endif;

PROC DV16A2
preproc
  ask if DV16A1 = 1;

PROC DV16B2
preproc
  ask if DV16B1 = 1;

PROC DV16C2
preproc
  ask if DV16C1 = 1;

PROC DV18
preproc
  numeric phyviol = ( DV08H1 = 1 | DV08I1 = 1 | DV08J1 = 1 | DV16B1 = 1 );
  if !phyviol then	
    skip to DV20
  endif;	

postproc
  { check years in abusive relationship with current age }
  if valid($) & $ < 95 & $ > agew then
    warning( 11001, agew )
	  select( tr("Age at first time forced to have sex"), $, tr("Continue"), continue );
  endif;

PROC DV20
preproc
  if A212W = 0 & A232 <> 1 then    { No pregnancies and not pregnant }
    skip to DV22
  endif;

postproc
  if $ <> 1 then
     skip to DV22
  endif;

PROC DV21
  $ = SortAlpha( $ );
  { Get other answer }
  if pos("X",$) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC DV22
  if $ <> 1 then
    skip to DV26
  endif;

PROC DV23
  $ = SortAlpha( $ );
  { Get other answer }
  if pos("X",$) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC DV26
preproc
  if DV06A1 = notappl then
    skip to DV27
  endif;

postproc
  if $ = 1 then
    skip to DV28
  else
    skip to DV32
  endif;

PROC DV27
  if $ <> 1 then
    skip to DV32
  endif;

PROC DV28
  { check age at first abusive sexual intercourse with current age }
  if valid($) & $ < 95 & $ > agew then
    warning( 11001, agew )
	  select( tr("Age at first time forced to have sex"), $, tr("Continue"), continue );
  endif;

PROC DV29
  $ = SortAlpha( $ );
  { Get other answer }
  if pos("X",$) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC DV32
preproc
  if !anyviol & !(DV16A1 = 1 | DV16B1 = 1 | DV20 = 1 | DV22 = 1 | DV26 = 1 | DV27 = 1) then
    skip to DV35
  endif;

postproc
  if $ <> 1 then
    skip to DV34
  endif;

PROC DV33
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

  skip to DV35;

PROC DVFIN
  $ = "";

PROC DV36C
preproc
  SaveData();
{ @@@ End Domestic Violence }

{ @@@ Begin Female Genital Cutting Module for Women }
PROC DV37
onfocus
  $ = "";

postproc
  if demode() = add then
    strnotes = editnote();
  endif;

PROC GC01
  if $ = 1 then
    skip to GC03
  endif;

PROC GC02
  if $ <> 1 then
    endgroup
  endif;

PROC GC03
  if $ <> 1 then
    endgroup
  endif;

PROC GC04
  if $ = 1 then
    skip to GC06
  endif;

PROC GC07
  if valid($) & $ < 95 & $ > agew then    { compare with current age }
    errmsg( 11050, agew ) select( tr("Age at circumcision"), $);
  endif;

PROC GC08
  majorgrp( $ );
  { Get other answer }
  if $ in 16,26 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC GC10
onfocus
  daughter = count( AWSEC2B where A219 = 2 & A224(A215L) = 1 & udc(A215L) >= cmcode(1,daughty) );
  if daughter = 0 then
    skip to GC17
  endif;

postproc
  $ = "";

PROC AWSECG2_ROSTER
preproc
  if GC01 <> 1 & GC02 <> 1 then
    endgroup;
  endif;

  { !!! count daughters currently alive and born in daughty or later, adjust year accordingly }
  daughter = 0;
  for i in AWSEC2B do
    if A219(i) = 2 & A224(i) = 1 & udc(i) >= cmcode(1,daughty) then
      daughter = daughter + 1;
    endif;
  enddo;
  GCDAUGHT = daughter;
  { if no living daughters }
  if !GCDAUGHT then
    endgroup;
  endif;
  do i = 1 while i <= 20
    if i <= daughter then
      LINEGC(i) = i;
    else
      LINEGC(i) = notappl;
    endif;
  enddo;
  { populate names coming from birth history }
  j = 1;
  for i in AWSEC2B do
    if A219(i) = 2 & A224(i) = 1 & udc(i) >= cmcode(1,daughty) then
      GC11(j)   = A215L(i);
      GC11N(j)  = A218(i);
      if android then 
        setocclabel(AWSECG2_ROSTER(j),strip(A218(i)));
      endif;
      j = j + 1;
    endif;
  enddo;

PROC LINEGC
preproc
  if curocc() > daughter then
    endgroup;
  endif;

PROC GC12
  if $ <> 1 then
    skip to next LINEGC;
  endif;

PROC GC13
  agedau = int( (di-ldc(GC11))/12 );        { daughter current age }
  if valid($) & $ < 95 & $ > agedau then    { compare with daughter's current age }
    errmsg( 11054, GC11, agedau )
	  select( tr("Daughter's age at circumcision"), $,
	          tr("Daughter's current age"), A225(GC11) );
  endif;

PROC GC15
  majorgrp( $ );
  { Get other answer }
  if $ in 16,26 then
    getother( GetSymbol(), curocc() );
    enter FL_OTHERS
  endif;
  skip to next LINEGC;

PROC GC17
preproc
  if GC01 <> 1 & GC02 <> 1 then
    endgroup;
  endif;
{ @@@ End Female Genital Cutting Module for Women }

{ @@@ Begin early childhood development }
PROC AWSECECD_FORM
preproc
  { initialize variables used to count entries for different sections }
  AESECECD = 0;
  numeric fullcdc, livcdc, livcmc;
  { pregnancy outcomes applicable to the pregnancy and postnatal care section } 
  childecd = 0;
  fullcdc = count(AWSEC2B where A220CD <> 0);
  if A212W = fullcdc then    // full date of pregnancy outcome for all pregnancies
    do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if A224(i) = 1 & A226(i) = 1 & int((dicdc - A220CD(i))/DaysMonth) in 24:59 then
	    childecd = childecd + 1;
        do j  = i+1 while j <= totocc(AWSEC2B_ROSTER2)
          if A224(j) = 1 & A226(i) = 1then
	        childecd = childecd + 1;
		  endif;
		enddo;
		break;
	  endif;
	enddo;
	indexpreg = i;
  else
    { count pregnancies based on CDC codes } 
	do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if A224(i) = 1 & A226(i) = 1 & int((dicdc - A220CD(i))/DaysMonth) in 24:59 then
	    livcdc = livcdc + 1;               // assume remaining pregnancies occurred after this one
        do j  = i+1 while j <= totocc(AWSEC2B_ROSTER2)
          if A224(j) = 1 & A226(i) = 1 then
	        livcdc = livcdc + 1;
		  endif;
		enddo;
		break;
	  endif; 
	enddo;
    { count pregnancies based on CMC codes (use udc to be on the conservative side) } 
	livcmc = 0;
	do i = 1 while i <= totocc(AWSEC2B_ROSTER2)
      if A224(i) = 1 & A226(i) = 1 & (di-udc(i) in 24:59 | di-udc(i) in 24:59) then
	    livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
        do j = i+1 while j <= totocc(AWSEC2B_ROSTER2)
          if A224(j) = 1 & A226(i) = 1 then
            livcmc = livcmc + 1;               // assume remaining pregnancies occurred after this one
          endif; 
        enddo;
		break;
	  endif; 
	enddo;
	indexpreg2 = i;
	childecd = livcdc;
	if livcmc > livcdc then childecd = livcmc; indexpreg = indexpreg2 endif;
  endif;  
  if !childecd then 
    endgroup
  endif;
  AESECECD = childecd;
  do i = 1 while i <= 4
    if i <= childecd then
      ACOLECD(i) = i;
    else
      ACOLECD(i) = notappl;
    endif;
  enddo;
  
PROC ACOLECD
preproc
  if curocc() > childecd then
    endgroup
  endif;

PROC AECDCA
preproc
  numeric nextbirth = 0;
  do i = A212W while i > 0 by (-1)
    if A224(i) = 1 & A226(i) = 1 then
	  nextbirth = nextbirth + 1;
	  if nextbirth = ACOLECD then
	    $ = i;
		break;
	  endif;
    endif;	  
  enddo;

postproc
  AECDCN = A218($);
  
PROC AECD6
  if $ <> 1 then
    skip to AECD8
  endif;	
{ @@@ End early childhood development }

{ @@@ Begin malaria knowledge and beliefs }
PROC AML501
  if $ <> 1 then
    skip to AML503
  endif;	
  
PROC AML502 
  $ = SortAlpha( $ );
  { Check "Don't remember" is only response }
  if pos( "Z", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  endif;
  
PROC AML503
  if $ <> 1 then
    skip to AML505
  endif;	
  
PROC AML504 
  $ = SortAlpha( $ );
  { Check "Don't know" is only response }
  if pos( "Z", $ ) & length(strip($)) > 1 then
    errmsg( 9995 ) select( tr("Fix answers marked"), $ );
  endif;
{ @@@ End malaria knowledge and beliefs }

{ @@@ Begin fistula module }
PROC AFI1
  if $ = 1 then
    skip to AFI4
  endif;	

PROC AFI2
  if $ = 1 then
    skip to AFI4
  endif;	
  
PROC AFI3
  endgroup;

PROC AFI4
  x = count(AWSEC2B_ROSTER2 where A223 = 1);  // counting live births
  y = count(AWSEC2B_ROSTER2 where A223 = 2);  // counting stillbirths
  if $ = 1 & !x then
    warning( 9200 )
	  select( tr("Change this response"), $, tr("Begin reproduction"), A201, tr("Continue"), continue );
  elseif $ = 2 & !y then
    warning( 9201 )
	  select( tr("Change this response"), $, tr("Begin reproduction"), A201, tr("Continue"), continue );
  elseif $ = 6 then
    skip to AFI6
  endif;	
  
PROC AFI5
onfocus
  if AFI4 in 1,2 then
    textstr1 = GetValueLabel( AFI4 );
  else
    textstr1 = GetValueLabel( AFI6 );
  endif;
  
postproc
  skip to AFI7;
  
PROC AFI6
  if $ = 8 then
    skip to AFI8
  endif;	
  { Get other answer }
  if $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;  

PROC AFI8
  if $ = 1 then
    skip to AFI10
  endif;	
  
PROC AFI9
  $ = SortAlpha( $ );
  endgroup;

PROC AFI10
  if $ in 0,5 then
    errmsg( 9980 );
    reenter
  endif;	
{ @@@ End fistula module }

PROC AWSEC2C_FORM
preproc
  savedata();
{ displays last form for women's questionnaire }
{ copy temporary to final calendar }
  do i = 1 while i <= callen
    ACAL(1)[i:1] = ACAL1[i:1];
    ACAL(2)[i:1] = ACAL2[i:1];
  enddo;
  
PROC A1116H
preproc
  if visualvalue( $ ) = notappl then
    time = systime();
    $ = int( time/10000 );
  endif;

PROC A1116M
preproc
  if visualvalue( $ ) = notappl then
    time = systime();
    $ = int( time/100 ) % 100;
  endif;
  
postproc  
  skip to ALANGQ
  
{ @@@ Ends the entire women's questionnaire }

{ @@@ Begin Men's Questionnaire }

PROC AM101H
preproc
  savedata();

  if InEntry then
    n = totocc( AVISITS_ROSTER );
    $ = AVHOUR( n );
  endif;

PROC AM101M
preproc
  if InEntry then
    n = totocc( AVISITS_ROSTER );
    $ = AVMINUTE( n );
  endif;

PROC AM102
  if $ <> 96 then
    skip to AM104
  endif;

PROC AM103
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM104
  if $ = 96 & AH05(ALINE) = 1 then
    warning( 21031, AH05(ALINE) ) 
	  select( tr("Time living in place of interview"), $, tr("Continue"), continue );
  endif;
  if $ in 95,96 then
    skip to AM110M
  elseif !$ in 0:4 then
    skip to AM107
  endif;
  
PROC AM106Y
  di = cmcode(AINTM, AINTY);
  if afterint(AM106M,$,AINTM,AINTY) then
	errmsg( 89998 ) select( tr("Date move here"), AM106_BLOCK );
  endif;
  if validyr(AM106Y) then
    temp = setub(AM106M, AM106Y, 9999);
	if int((di-temp)/12) <> AM104 then
	  warning( 1035, AM104 ) 
	    select( tr("Date moved here"), AM106_BLOCK, 
	            tr("Years living in place of residence"), AM104,
				tr("Continue"), continue );
	endif;
  endif;

PROC AM109
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM111
  { Set up CMC for date of interview }
  di = cmcode( AINTM, AINTY );
  { Initial ranges for CMC date of birth }
  if validyr(AM110Y) then
    ldb = setlb( AM110M, AM110Y, 0 );
    udb = setub( AM110M, AM110Y, 9999 );
  else
    ldb = di - 779;             { !!! modify based on upper age of eligible men }
    udb = di - 180;
  endif;

  { Check either year of birth or age given for all men }
  if !validyr(AM110Y) & !valid($) then
    errmsg( 21060, AM110M, AM110Y, $ ) 
	  select( tr("Date of birth"), AM110_BLOCK, tr("Age"), $ );
  { Compare age of man with age in household to look for typos }
  elseif $ <> AH07(ALINE) & demode() = add then
    warning( 21061, $, AH07(ALINE) ) 
	  select( tr("Age"), $, tr("Continue"), continue );
  endif;

  { Adjust ranges for CMC date of birth based on age }
  if valid($) then
    { Lower bound of CMC }
    t = ndjlba( ldb, udb, di, di, $ );
    if t < 0 then
      errmsg( 21062, AM110M, AM110Y, $, AINTM, AINTY ) 
	    select( tr("Date of birth"), AM110_BLOCK, tr("Age"), $ );
    else
      ldb = t
    endif;
    { Upper bound of CMC }
    t = adjuba( ldb, udb, di, di, $ );
    if t < 0 then
      errmsg( 21062, AM110M, AM110Y, $, AINTM, AINTY ) 
	    select( tr("Date of birth"), AM110_BLOCK, tr("Age"), $ );
    else
      udb = t
    endif;
  endif;

  { calculate man's age }
  agem = int( (di - ldb) / 12 );

  { checks duration of current residence against age }
  if AM104 in 0:64 & AM104 > agem then
    warning( 21030, AM104 ) 
	  select( tr("Years living in place of residence"), AM104, 
	          tr("Age"), $,
              tr("Continue"), continue );
  endif;

PROC AM113
  if $ <> 1 then
    skip to AM117
  endif;

PROC AM114
  { Check education in individual questionnaire agrees with education in hh }
  if $ <> AH17A(ALINE) & demode() = add then
    warning( 21080, $, AH17A(ALINE) ) 
	  select( tr("Level of education"), $, tr("Continue"), continue );
  endif;

PROC AM115
onfocus
  grades.clear();
  grades.add(tr("Less than one year"), 0);
  n = maxgrade(AM114);
  do i = 1 while i <= n
    grades.add(maketext("Year %d", i), i);
    // change the above to match the terms used in the country
    // e.g. it might be "Year" that is used in most levels, but "Form" is used in secondary schooling
    // if AM114 = 2 then
    //   grades.add(maketext("Form %d", i), i);
    // else
    //   grades.add(maketext("Year %d", i), i);
    // endif;
  enddo;
  SetValueSet( $, grades );

postproc
  if !LevelYears( AM114, $ ) then
    errmsg( 21091 ) 
	  select( tr("Level of education"), AM114, tr("Grade/year/form"), $ );
  endif;

  { Check education in individual questionnaire agrees with education in hh }
  if $ <> AH17B(ALINE) & demode() = add then
    warning( 21090, $, AH17B(ALINE) ) 
	  select( tr("Grade/year/form"), $, tr("Continue"), continue );
  endif;

PROC AM117
preproc
  if AM114 = 3 then
    skip to AM119
  endif;

postproc
  if $ in 1,5 then
     skip to AM120
  { Get Other Answer }
  elseif $ = 4 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM122
  if $ <> 1 then
    skip to AM127
  endif;

PROC AM127
  if $ <> 1 then
    skip to AM130
  endif;

PROC AM128
  if $ <> 1 then
    skip to AM130
  endif;

PROC AM130
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM131
  { Get Other Answer }
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM201
  if $ <> 1 then
    skip to AM206
  endif;

PROC AM202
  if $ <> 1 then
    skip to AM204
  endif;

PROC AM203B
  { Check for at least one child living at home - otherwise 202 must be 2 }
  if !AM203A & !$ then
    errmsg( 22030 ) select( tr("Any children living at home"), AM202, 
	                        tr("Number of children living at home"), AM203_BLOCK );
  endif;

PROC AM204
  if $ <> 1 then
    skip to AM206
  endif;

PROC AM205B
  { Check for at least one child living away from home - otherwise 204 must be 2 }
  if !AM205A & !$ then
    errmsg( 22030 ) select( tr("Any children living away"), AM204, 
	                        tr("Number of children living away"), AM205_BLOCK );
  endif;

PROC AM206
  if $ <> 1 then
    skip to AM208
  endif;

PROC AM207B
  { Check for at least one child to have died - otherwise 206 must be 2 }
  if !AM207A & !$ then
    errmsg( 22030 ) select( tr("Any boys or girls who died"), AM206, 
	                        tr("Number of boys or girls who died"), AM207_BLOCK );
  endif;

PROC AM208
preproc
  { Count up total children ever born }
  $ = NAtoZero(AM203A) + NAtoZero(AM203B) +
      NAtoZero(AM205A) + NAtoZero(AM205B) +
      NAtoZero(AM207A) + NAtoZero(AM207B);

postproc
  if AM208 = 0 & AM201 = 1 then
    errmsg( 22080 ) select( tr("Any children ever born"), AM201 );
  endif;

  if AM208 = 0 then
    endgroup
  elseif AM208 = 1 then
    skip to AM211
  endif;

PROC AM211
  if valid($) & $ > agem then
    errmsg( 22130, $, agem ) 
      select( tr("Age at birth of first child"), $, tr("Current age" ), AM111 );
  endif;
  SaveData();

PROC AM213
preproc
  { Count up living children }
  lchild = NAtoZero(AM203A) + NAtoZero(AM203B) +
           NAtoZero(AM205A) + NAtoZero(AM205B);
  if !lchild then
    endgroup
  endif;

postproc
  if valid($) & $+int(minabm/12) > agem then
    warning( 22140, $, agem, int(minabm/12) )
	  select( tr("Age of youngest child"), $,
	          tr("Current age"), AM111,
			  tr("Continue"), continue );
  endif;
  if !$ in 0:2 then
    endgroup
  endif;

PROC AM215
  if !pos( $[1:1], alphalst ) then
    errmsg( 89991 ) select( tr("Name"), $ );
  endif;

PROC AM216
  if $ <> 1 then
    skip to AM218
  endif;

PROC AM218
  if $ <> 1 then
    endgroup
  endif;

PROC AMSEC3A_FORM
preproc
  do i = 1 while i <= maxocc( AMSEC3A_GRP )
    AM3N(i) = i
  enddo;

{ The logic used in AALLMETH should be replicated here if the spontaneous knowledge of method is used }
{ If that is the case AMALLMETH is the variable to be used for men                                    }

PROC AM301_INTRO
  $ = "";

PROC AM301
preproc
  numeric oldvalm = visualvalue( $(AM3N) );
  if AM3N >= methoth then
    if visualvalue($(AM3N)) in 1,2 then
      $ = oldvalm;
    else
      $ = 2
    endif;
    noinput;
  endif;

onfocus
  methname = GetLabel( AM301, AM3N );

PROC AM301OT
  $ = SortAlpha( $ );
  { Get names of other methods }
  if pos( "Y", $ ) & length(strip($)) > 1 then
    errmsg( 3141 ) select( tr("Fix answers marked"), $ );
  endif;
  if pos( "A", $ ) then
    AM301(methoth) = 1
  else
    AM301(methoth) = 2
  endif;
  if pos( "B", $ ) then
    AM301(methoth+1) = 1
  else
    AM301(methoth+1) = 2
  endif;
  if pos( "A", $ ) then
    if demode() = add then
      display( tr("Record other modern method") );
	endif;
    getother( "A301OT", methoth+10 );
    enter FL_OTHERS
  endif;
  if pos( "B", $ ) then
    if demode() = add then
      display( tr("Record other traditional method") );
	endif;
    getother( "A301OT", methoth+11 );
    enter FL_OTHERS
  endif;

PROC AM304
  if $ <> 1 then
    skip to AM306;
  endif;

PROC AM305
  { Get Other Answer }
  if $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM307B
  SaveData();

PROC AM401
  wives = 0;                  { Initialized for later use }
  inunion = ( $ in 1,2 );

  if inunion then
    skip to AM404
  endif;

PROC AM402
  if $ = 3 then
    skip to AM413
  endif;

PROC AM403
  skip to AM410;

PROC AM405
  if $ <> 1 then
    wives = 1;
    skip to AM407
  endif;

PROC AM406
  wives = $;
  { if missing assume one wife }
  if !valid($) then wives = 1 endif;

PROC AM407
preproc
  { skip out of loop after last wife/partner entered }
  if curocc() > wives then
    endgroup;
  endif;

onfocus
  individuals.clear();
  do i = 1 while i <= AHMEMBER
    if AH04(i) = 2 & AH07(i) in 10:98,missing then
      individuals.add(AH02(i), i);
    endif;
  enddo;
  individuals.add( tr("Not a household member"), 0 );
  SetValueSet( $, individuals );
  relterms();

postproc
  { Check if line number is out of range }
  if $ > AHMEMBER | $ = ALINE then
    errmsg( 25060 ) select( tr("Line number of wife/partner"), $ );
  elseif $ <> 0 then
    { Check partner is female }
    if AH04($) <> 2 then
      errmsg( 25061, AH04($), $ ) select( tr("Line number of wife/partner"), $ );
    { Check partner is at least age 12 }
    elseif valid( AH07($) ) & AH07($) < 12 then
      warning( 25062, AH07($), $, 12 )
	    select( tr("Line number of wife/partner"), $, tr("Continue"), continue );    
	endif;
    { Check relationship of respondent to partner }
    x = AH03(ALINE);
    y = AH03($);
    recode x :: y                 -> err;
           1 :: 2                 -> 0;
           2 :: 1                 -> 0;
           3 :: 4                 -> 0;
           4 :: 3                 -> 0;
           5 :: 9                 -> 0;
           6 :: 6                 -> 0;
           7 :: 7                 -> 0;
           8 :: 9                 -> 0;
           9 :: 5,8:11,98         -> 0;
       10:11 :: 10:11             -> 0;
  98,missing :: 10,11,98,missing  -> 0;
             ::                   -> 1;
    endrecode;
    if err then
      warning( 25064, $, x, y )
	    select( tr("Line number of wife/partner"), $, tr("Continue" ), continue );
    endif;
    { line number cannot be equal to any preceding line number }
    do n = curocc()-1 while n by (-1)
      if AM407(n) = AM407 then
        errmsg( 25065, AM407 )select( tr("Line number of wife/partner"), $ );
      endif;
    enddo;
  endif;

PROC AM408
onfocus
  if AM407 in 1:AHMEMBER then
    partner = strip(AH02(AM407))
  else
    partner = tr("this wife or partner");
  endif;

postproc
  { Check wife's age with age declared in the household }
  if demode() = add & AM407 & valid(AH07(AM407)) & $ <> AH07(AM407) then
    warning( 25068, AH07(AM407) )
	  select( tr("Age of wife/partner"), $, tr("Continue"), continue );
  endif;

PROC AM410
preproc
  if wives > 1 then
    skip to AM411_BLOCK
  endif;

PROC AM411_BLOCK
onfocus
  marriages = ( wives > 1 | AM410 = 1 );
  
PROC AM411Y
  numeric ageatm;
  { Check date of marriage before interview }
  if afterint( AM411M, $, AINTM, AINTY ) then
    errmsg( 9992 ) select( tr("Date of 1st union"), AM411_BLOCK );
  { Compute CMC date of marriage }
  elseif validyr($) then
    ldm = setlb( AM411M, $, 0 );
    udm = setub( AM411M, $, 9999 );
	ageatm = int((ldm-udb)/12);
	if ageatm < 10 then
	  warning( 5140, ageatm )
	    select( tr("Date of 1st union"), AM411_BLOCK, tr("Continue" ), continue );
	elseif ageatm > agem then
	  errmsg( 5141, ageatm, agem )
	    select( tr("Date of 1st union"), AM411_BLOCK );
	endif;
    skip to AM413
  endif;

PROC AM412
  if valid($) then
    ldm = ldb+$*12;
    udm = udb+$*12+11;
    if ldm > di then
      if demode() = add then
        warning( 25130, AINTM, AINTY, AM110M, AM110Y, agem, AM411M, AM411Y, AM412 )
		  select( tr("Date of 1st union"), AM411_BLOCK, 
		          tr("Age at 1st union"), $, 
				  tr("Continue"), continue );
      endif
    elseif udm > di then
      udm = di;
    endif;
  else
    { No age and year at marriage given }
    if demode() = add then
      warning( 25135, AM412, AM411M, AM411Y )
	    select( tr("Date of 1st union"), A715_BLOCK, 
	            tr("Age at 1st union"), $, 
			    tr("Continue"), continue );
    endif;
    { Set outer ranges for date of marriage }
    ldm = ldb+minamm;
    udm = di;
  endif;

PROC AM413
preproc
  { consistency of date of marriage is done here because age at marriage
    is not asked to all the respondents }
  if demode() = add & AM411M <> notappl then  { if ever married }
    if ldm > udm then
      warning( 25121, int(minamm/12), AM110M, AM110Y, agem, AM411M, AM411Y, AM412 )
  		select( tr("Date of 1st union"), AM411_BLOCK, 
		        tr("Age at 1st union"), AM412,
				tr("Current age"), AM111,
			    tr("Continue"), continue );

    elseif ldm > di then
      warning( 25120, AM411M, AM411Y, AM412, AINTM, AINTY, AM110M, AM110Y, agem )
  		select( tr("Date of 1st union"), AM411_BLOCK, 
		        tr("Age at 1st union"), AM412,
				tr("Current age"), AM111,
			    tr("Continue"), continue );
    endif;
  endif;

postproc
  $ = "";

PROC AM414
  if $ = 0 then
    if AM208 > 0 then           {have kids}
      errmsg( 25150 ) select( tr("Age at first intercourse"), $ );
    elseif wives > 0 then
      if demode() = add then
        warning( 25151, wives, AM401, AM402 )
		  select( tr("Age at first intercourse"), $, 
		          tr("Marital status"), AM401,
		          tr("Continue"), continue );
      endif;
    endif;
  elseif $ = 95 & AM402 = 3 then
    errmsg( 25192 ) select( tr("Age at first intercourse"), $ );
  elseif valid($) & $ < 95 then
    if $ > agem then
      warning( 25190, AINTM, AINTY, AM110M, AM110Y, AM111, $ )
	    select( tr("Age at first intercourse"), $, 
 		        tr("Current age"), AM111, 
		        tr("Continue"), continue );
    endif
  endif;

  { Set up ever married status for later use }
  evermarr = ( AM401 in 1,2 | AM402 in 1,2 );
  if $ = 0 then
    endgroup;
  endif;

PROC AM415N
onfocus
  protect( AM415U, false );

PROC AM415U
preproc
  if AM415N in 98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  badspecial( $, AM415N, getsymbol() );

  recode AM415U :: AM415N -> err;
            3   :: >=12   -> 1;
            2   :: >=52   -> 1;
          <>1   :: 0      -> 1;
                ::        -> 0;
  endrecode;
  if err then
    errmsg( 9994 ) select( tr("Number"), AM415N, tr("Unit"), AM415U );
  elseif AM415U = 4 & AM415N > agem then
    errmsg( 25193, AM415U, AM415N, agem )
	  select( tr("Time since last sex"), AM415_BLOCK, 
 	          tr("Current age"), AM111, 
		      tr("Continue"), continue );
  endif;
  if AM415U in 4,9 then
    skip to AM429
  endif;

PROC AM416
  if $ = 1 then
    skip to AM418
  endif;

PROC AM417
  skip to AM419;

PROC AM418
  $ = SortAlpha( $ );
  { !!! if ever use in contraceptive table make sure to check against that rather than knowledge
        In DHS-8 a one to one relationship between current use and contraceptive table          }
  y = length( strip($) );
  do x = 1 while x <= y
    meth = pos( $[x:1], am439str );
    if AM301(meth) <> 1 then               { other methods should be known }
      errmsg( 23142, GetLabel(AM418, $[x:1]) ) select( tr("Method used"), $ );
    endif;
  enddo;
  if poschar( "GH",$ ) then
    skip to AM420;
  endif;	

PROC AM419
  if $ = 1 & AM301(7) <> 1 then
    warning( 26280 ) 
	  select( tr("Used condom during last intercourse"), $,
	          tr("Knowledge of condom"), AM301(7),
			  tr("Continue"), continue );
  endif;
  if $ <> 1 then
    skip to AM422
  endif;

PROC AM420
  if $ = 96 then
    getother(GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM421
  majorgrp( $ );
  { Get other answer }
  if $ in 16,27,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM422
  if $ = 1 & !evermarr then
    warning( 25240, AM401, AM402 )
      select( tr("Relationship with last sex partner"), $,
	          tr("Marital status"), AM401,
		      tr("Continue"), continue );
  elseif $ = 2 & AM402 = 3 then
    warning( 25241, AM401, AM402 )
      select( tr("Relationship with last sex partner"), $,
	          tr("Marital status"), AM401,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "A730", 10 );      // use same question as for women
    enter FL_OTHERS
  endif;

PROC AM423
  if $ <> 1 then
    skip to AM429
  endif;

PROC AM425
  if $ = 1 & !evermarr then
    warning( 25240, AM401, AM402 )
      select( tr("Relationship with prior sex partner"), $,
	          tr("Marital status"), AM401,
		      tr("Continue"), continue );
  elseif $ = 2 & AM402 = 3 then
    warning( 25241, AM401, AM402 )
      select( tr("Relationship with prior sex partner"), $,
	          tr("Marital status"), AM401,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "A730", 11 );      // use same question as for women
    enter FL_OTHERS
  endif;

PROC AM426
  if $ <> 1 then
    skip to AM429
  endif;

PROC AM428
  if $ = 1 & !evermarr then
    warning( 25240, AM401, AM402 )
      select( tr("Relationship with third prior sex partner"), $,
	          tr("Marital status"), AM401,
		      tr("Continue"), continue );
  elseif $ = 2 & AM402 = 3 then
    warning( 25241, AM401, AM402 )
      select( tr("Relationship with third prior sex partner"), $,
	          tr("Marital status"), AM401,
		      tr("Continue"), continue );
  elseif $ = 6 then
    getother( "A730", 12 );      // use same question as for women
    enter FL_OTHERS
  endif;

PROC AM429
  sexp = 1 + (AM423 = 1) + (AM426 = 1);
  if valid($) & $ < sexp then
    warning( 25245, sexp )
      select( tr("Lifetime number of sex partners"), $, tr("Continue"), continue );
  endif;
  SaveData();

PROC AM504
preproc
  { not in union or man sterilized }
  { Note that alpha variables stay in memory when backtracking, thus AM416 needs to be included! }
  if !inunion | pos("B", AM418) then
    skip to AM514
  elseif wives > 1 then
    skip to AM509
  endif;

postproc
  if $ <> 1 then
    skip to AM507;
  endif;

PROC AM505
  if $ <> 1 then
    skip to AM514
  endif;

PROC AM506N
onfocus
  protect( AM506U, false );

postproc
  { Check special answers }
  if $ = 96 then
    getother( "A805N", 10 );
    enter FL_OTHERS
  endif;

PROC AM506U
preproc
  if AM506N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, AM506N, getsymbol() );

  skip to AM514;

PROC AM507
  if $ <> 1 then
    skip to AM514
  endif;

PROC AM508N
onfocus
  protect( AM508U, false );

postproc
  if $ = 96 then
    getother( "A805N", 11 );   { !!! record others for time to next child in the same question }
    enter FL_OTHERS
  endif;

PROC AM508U
preproc
  if AM508N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, AM508N, getsymbol() );

  skip to AM514;

PROC AM509
  if $ <> 1 then
    skip to AM512
  endif;

PROC AM510
  if $ <> 1 then
    skip to AM514
  endif;

PROC AM511N
onfocus
  protect( AM511U, false );

postproc
  if $ = 96 then
    getother( "A805N", 12 );   { !!! record others for time to next child in the same question }
    enter FL_OTHERS
  endif;

PROC AM511U
preproc
  if AM511N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, AM511N, getsymbol() );

  skip to AM514;

PROC AM512
  if $ <> 1 then
    skip to AM514
  endif;

PROC AM513N
onfocus
  protect( AM513U, false );

postproc
  if $ = 96 then
    getother( "A805N", 13 );   { !!! record others for time to next child in the same question }
    enter FL_OTHERS
  endif;

PROC AM513U
preproc
  if AM513N in 93:98 then
    protect( $, true );
    $ = 9;
  endif;

postproc
  { Check special answers }
  badspecial( $, AM513N, getsymbol() );

PROC AM514
onfocus
  lchild = NAtoZero(AM203A) + NAtoZero(AM203B) +
           NAtoZero(AM205A) + NAtoZero(AM205B);

postproc
  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  if $ in 0,96 then
    endgroup
  endif;

PROC AM515B
preproc
  if AM515A = 96 then
    $ = 96;
    noinput
  endif;

postproc
  if ($ = 96 <=> AM515A <> 96) | ($ = missing <=> AM515A <> missing) then
    errmsg( 9994 ) select( tr("Boys"), AM515A, tr("Girls"), $ );
  endif;

PROC AM515C
preproc
  if AM515A = 96 then
    $ = 96;
    noinput
  endif;

postproc
  if ($ = 96 <=> AM515A <> 96) | ($ = missing <=> AM515A <> missing) then
    errmsg( 9994 ) select( tr("Boys"), AM515A, tr("Girls"), AM515B, 
	                       tr("Either"), $, tr("Total"), AM514 );
  elseif valid(AM515A) & valid(AM515B) & valid($) & $ < 96 &
         AM515A+AM515B+$ <> AM514 then
    errmsg( 26131 )
      select( tr("Ideal number of children by sex"), AM515_BLOCK,
	          tr("Ideal number of children"), AM514 );
  endif;

  if $ = 96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  SaveData();

PROC AM601
  if $ = 1 then
    skip to AM604
  endif;

PROC AM602
  if $ = 1 then
    skip to AM604
  endif;

PROC AM603
  if $ <> 1 then
    skip to AM609;
  endif;

PROC AM604
  { !!! it is possible that all textual occupation needs to recorded }
  if $ = 96 then
    getother( "A908", 2 );   { !!! record others for occupation in the same question }
    enter FL_OTHERS
  endif;

PROC AM609
preproc
  { no wives or not earnings in cash }
  if !inunion then
    skip to AM612;
  elseif !AM606 in 1,2 then
    skip to AM610
  endif;

postproc
  if $ in 2,3 & !inunion then
    warning( 27250, $, AM401 )
      select( tr("Person deciding how earnings are used"), $,
	          tr("Marital status"), AM401,
		      tr("Continue"), continue );
  { Get Other answer }
  elseif $ = 6 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM610
  if $ in 2,3 & !inunion then
    warning( 27250, $, AM401 )
      select( tr("Final say on health care"), $,
 	          tr("Marital status"), AM401,
		      tr("Continue"), continue );
  endif;

PROC AM611
  if $ in 2,3 & !inunion then
    warning( 27250, $, AM401 )
      select( tr("Final say on large purchases"), $,
	          tr("Marital status"), AM401,
		      tr("Continue"), continue );
  endif;

PROC AM612
onfocus
  if evermarr then
    setvalueset( $, AM612_VS1 );
  else // exclude the husband/partner options for never married
    vs = AM612_VS1;
    vs.remove(2);
    vs.remove(4);
    setvalueset( $, vs );
  endif;

postproc
  if $ = 6 then
    skip to AM615
  endif;

PROC AM613
  if $ <> 1 then
    skip to AM615
  endif;

PROC AM615
onfocus
  if evermarr then
    setvalueset( $, AM615_VS1 );
  else // exclude the husband/partner options for never married
    vs = AM615_VS1;
    vs.remove(2);
    vs.remove(4);
    setvalueset( $, vs );
  endif;

postproc
  if $ = 6 then
    skip to AM617A
  endif;

PROC AM616
  if $ <> 1 then
    skip to AM617A
  endif;

PROC AM617A
  if $ <> 1 then
    skip to AM617C
  endif;

PROC AM619
  SaveData();

PROC AM700
  $ = "";

PROC AM701
  if $ <> 1 then
    skip to AM729
  endif;

PROC AM703
preproc
  if agem >= 25 then
    skip to AM708
  endif;

PROC AM710
  if $ <> 1 then
    skip to AM712;
  endif;

PROC AM712
  $ = "";

PROC AM713
  if $ <> 1 then
    skip to AM721
  endif;

PROC AM714Y
  if afterint(AM714M,$,AINTM,AINTY) then
	errmsg( 89998 ) select( tr("Date most recent HIV test"), AM714_BLOCK );
  endif;
  ldth = setlb( AM714M, AM714Y, 0 );
  if ldth < ldb then
    errmsg( 11012, AM110M, AM110Y ) select( tr("Date most recent HIV test"), AM714_BLOCK );
  endif;

PROC AM715
  majorgrp( $ );
  if $ in 16,27,36,96 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

PROC AM716
  if $ <> 1 then
    skip to AM720
  endif;

PROC AM717
  if $ <> 1 then
    skip to AM720
  endif;	

PROC AM718M
  if $ = 95 then
    skip to AM719
  endif;

PROC AM718Y
  if afterint(AM718M,$,AINTM,AINTY) then
	errmsg( 89998 ) select( tr("Date tested positive"), AM718_BLOCK );
  endif;
  udth = setlb( AM718M, AM718Y, 9999 );
  if udth > ldth+1 then   // give one month to allow time to get results from last test
    errmsg( 11010 ) 
	  select( tr("Date tested positive"), AM718_BLOCK,
              tr("Date most recent HIV test"), AM714_BLOCK );	  
  endif;
  if udth < ldb then
    errmsg( 11011, AM110M, AM110Y ) select( tr("Date tested positive"), AM718_BLOCK );
  endif;

PROC AM721
  if $ <> 1 then
    skip to AM723
  endif;

PROC AM726
preproc
  if AM717 <> 1 then
    skip to AM729
  endif;

PROC AM732
preproc
  if AM414 = 0 then
    skip to AM735
  elseif AM729 <> 1 then
    skip to AM733
  endif;

PROC AM801
  if $ <> 1 then
    skip to AM806
  endif;

PROC AM802
  if $ <> 1 then
    skip to AM804
  endif;

PROC AM803
  if valid($) & $ < 95 & $ > agem then
    errmsg(11050, agem) select( tr("Age at traditional circumcision"), $);
  endif;  

PROC AM804
  if AM802 = 2 & $ = 2 then
    errmsg(11055) select(tr("Circumcision"), AM801, tr("Traditional"), AM802, tr("Medical"), $ );
  endif;	
  if AM802 = 2 & $ = 8 | AM802 = 8 & $ = 2 then
    warning(11056) select(tr("Circumcision"), AM801, tr("Traditional"), AM802, 
	                      tr("Medical"), $, tr("Continue"), continue );
  endif;	
  if $ <> 1 then
    skip to AM806
  endif;
  
PROC AM805
  if valid($) & $ < 95 & $ > agem then
    errmsg(11050, agem) select( tr("Age at medical circumcision"), $);
  endif;  

PROC AM806
  if $ = 1 then
    skip to AM809_BLOCK
  elseif $ <> 2 then
    skip to AM808
  endif;

PROC AM807
  skip to AM810A;

PROC AM808
  skip to AM811;

PROC AM809G
  if $ in 1:300,888 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;
  skip to AM811;

PROC AM810G
  if $ in 1:300,888 then
    getother( "AM809G", 1 );
    enter FL_OTHERS
  endif;

PROC AM811
  if $ = 2 then
    skip to AM813_BLOCK
  elseif $ <> 1 then
    skip to AM814
  endif;

PROC AM812E
  if $ in 1:300,888 then
    getother( "AM809G", 2 );
    enter FL_OTHERS
  endif;
  skip to AM814;

PROC AM813E
  if $ in 1:300,888 then
    getother( "AM809G", 3 );
    enter FL_OTHERS
  endif;

PROC AM814
  if $ <> 1 then
    skip to AM817
  endif;

PROC AM815
  if $ = 0 then
    skip to AM817
  endif;

PROC AM817
  if $ <> 1 then
    endgroup
  endif;

PROC AM818
  $ = SortAlpha( $ );
  { get other answer }
  if pos( "X", $ ) then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  endif;

{ @@@ Begin Chronic Disease Module for Men }
PROC AMCHD02
  if $ <> 1 then
    skip to AMCHD06
  endif;

PROC AMCHD07
  if $ <> 1 then
    skip to AMCHD11
  endif;

PROC AMCHD11
  if $ <> 1 then
    skip to AMCHD13
  endif;

PROC AMCHD13
  if $ <> 1 then
    skip to AMCHD15
  endif;

PROC AMCHD15
  if $ <> 1 then
    skip to AMCHD17A
  endif;  

PROC AMCHD19
preproc
  if AMCHD17A <> 1 & AMCHD17B <> 1 then
    skip to AMCHD20
  endif;

PROC AMCHD20
  if $ <> 1 then
    skip to AMCHD22
  endif;

PROC AMCHD22
  { Get other answer }
  if $ = 1 then
    getother( GetSymbol(), 0 );
    enter FL_OTHERS
  else
    endgroup
  endif;

{ @@@ Begin Mental Health Module for Men }
PROC AMMTH2
preproc
  numeric symptoms;
  symptoms = (AMMTHGAD1 in 1:3) + (AMMTHGAD2 in 1:3) + (AMMTHGAD3 in 1:3) + (AMMTHGAD4 in 1:3) + 
             (AMMTHGAD5 in 1:3) + (AMMTHGAD6 in 1:3) + (AMMTHGAD7 in 1:3) + 
			 (AMMTHPHQ1 in 1:3) + (AMMTHPHQ2 in 1:3) + (AMMTHPHQ3 in 1:3) + (AMMTHPHQ4 in 1:3) + 
			 (AMMTHPHQ5 in 1:3) + (AMMTHPHQ6 in 1:3) + (AMMTHPHQ7 in 1:3) + (AMMTHPHQ8 in 1:3) + 
			 (AMMTHPHQ9 in 1:3); 
  if !symptoms then			 
    skip to AMMTH4A
  endif;	
  
postproc  
  if $ <> 1 then			 
    skip to AMMTH4A
  endif;	

PROC AMMTH3
  $ = SortAlpha( $ );
  { Get other answer }
  if pos( "X", $ ) then
    getother( "AMTH3", 1 );
    enter FL_OTHERS
  endif;

PROC AMMTH6
preproc
  $ = ScorePHQ(AMMTHPHQ1) + ScorePHQ(AMMTHPHQ2) + ScorePHQ(AMMTHPHQ3) + ScorePHQ(AMMTHPHQ4) + 
	  ScorePHQ(AMMTHPHQ5) + ScorePHQ(AMMTHPHQ6) + ScorePHQ(AMMTHPHQ7) + ScorePHQ(AMMTHPHQ8) + 
	  ScorePHQ(AMMTHPHQ9); 
	  
PROC AMMTH8
preproc
  if !(AMMTH6 >= 10 | AMMTHPHQ9 in 1:3) then
    endgroup
  endif;	
{ @@@ End Mental Health Module for Men }

{ @@@ Begin Female Genital Cutting Module for Men }
PROC GCM01
  if $ = 1 then
    skip to GCM03
  endif;

PROC GCM02
  if $ <> 1 then
    endgroup
  endif;
{ @@@ End Female Genital Cutting Module for Men }

PROC AM819H
preproc
  if visualvalue( $ ) = notappl then
    time = systime();
    $ = int( time/10000 );
  endif;

PROC AM819M
preproc
  if visualvalue( $ ) = notappl then
    time = systime();
    $ = int( time/100 ) % 100;
  endif;
  { @@@ End Men's Questionnaire }

PROC ALANGQ
preproc
  savedata();

  if special(visualvalue($)) then
    $ = 1;
    if getlanguage() = "ES" then
	  $ = 2;
	endif;
  endif;

{ @@@ taking GPS coordinates for individual }
PROC GIAUX
preproc
  capturecoor = ( visualvalue(GILATITUDE) = notappl );
  if capturecoor then
    skip to GIINTRO
  endif;  

onfocus
  $ = 2;
  capturecoor = ( visualvalue(GILATITUDE) = notappl );
  
postproc
  if $ <> 1 then
    advance to AFINAL
  endif;  
  
PROC GIINTRO
onfocus
  capturecoor = ( visualvalue(GILATITUDE) = notappl );

postproc
  { open the GPS dongle to capture GPS coordinates }
  { !!! verify using the device manager the port number used by the dongle       }
  {     in ICF laptops port 3 is reserved and erroneously taken as a dongle port }
  {     in ASUS tablets ports are assigned starting from port 3 and above        }
  capturecoor = ( visualvalue(GILATITUDE) = notappl );
  if $ = 1 & GIAUX <> 2 then 
    if GIAUX = 1 & accept( tr("Coordinates were already collected. Are you sure that you need to recollect them?"),
                           tr("No, do not recollect the coordinates"),
                           tr("Yes, recollect the coordinates") ) <> 2 then
      reenter GIAUX
    endif;	  
	if android then
      gpsopen = GPS( open );
    else // Windows
      do i = 3 while i <= 10
        if GPS( open, i, 4800 ) then
          break
        endif;
      enddo;
	  gpsopen = (i <= 10);
    endif;	  
    if !gpsopen then
      errmsg( 60045 );
      if capturecoor then
        skip to AFINAL
      else
        advance to AFINAL
      endif;
    endif;
  else
    if capturecoor then
      skip to AFINAL
    else
      advance to AFINAL
	endif;
  endif;

PROC GILATITUDE
preproc
  string gpstitle;
  capturecoor = ( visualvalue(GILATITUDE) = notappl );
  if GIINTRO = 1 & GIAUX <> 2 then 
    gpstitle = tr("GPS device acquiring GPS satellites. Please wait to complete its capture");
    if gps(read, 25, gpstitle ) then
      GILATITUDE  = gps(latitude);
      GILATPOLE   = "N";
      if gps(latitude) < 0 then	{ negative = south }
        GILATPOLE = "S";
      endif;
      GILONGITUDE = gps(longitude);
      GILNGPOLE  = "E";
      if gps(longitude) < 0 then	{ negative = west }
        GILNGPOLE = "W";
      endif;
      GIALTITUDE = gps(altitude);
      GISATELLIT = gps(satellites);	  { no. of satellites, at least 3-4 is recommended }
      GIACCURACY = gps(accuracy);	  { precision level, 1 is the best possible and 50 the least accurate }
    else
      errmsg( 60050 );
      if !capturecoor then 
        advance to AFINAL
      else
        skip to AFINAL
      endif;
    endif;
  else
    if !capturecoor then 
      advance to AFINAL
    else
      skip to AFINAL
    endif;
  endif;
  { @@@ end taking GPS coordinates for individual }

PROC AFINAL
preproc
  savedata();

onfocus
  $ = "";

postproc
  if demode() = add then
    strnotes = editnote();
    if endmess() then
      reenter $
    endif;
  endif;
  endlevel;
  
PROC OTHSEC
  { Check text of response has changed and if so write it out }
  if compare(OTHRESP,wothresp) <> 0 | OTHCODE <> wothcode then
    writecase( OTHERS );
  endif;

PROC OTHRESP
  $ = toupper($);
  { Check that response is alphabetic and starts in the first column }
  if !pos($[1:1],alphalst) then
    errmsg( 89991 ) select( tr("Enter text"), $ );
  endif;

PROC OTHCODE
preproc
  { Initialize code for other answer to zero and skip variable }
  noinput;

