{ Application 'SUPMENU' logic file generated by CSPro }
PROC GLOBAL

  FILE      piffile;                       { data entry PFF file for the application }
  FILE      fromckid;                      { to read file generated by CheckID       }
  FILE      justone;                       { file handler to make sure that there are no concurrent sessions }
  FILE      TrackUpg;                      { file handler to track upgrades coming from CSWeb server }
  FILE      SyncLog;                      { file to log connections to server and  }
  numeric debug =    0;// sets debugging on

  string TheCommand, fname, fname2, newupgrades;
  string FilesToZip;
  string CSPro;                            { CSPro executables directory }
  string AppName;                          { application name and dictionary name }
  string opid;                             { operator ID }
  string wrkprj, wrkpii, superv, receive, data;  { directories }
  string fpath, entry, temp, final, Biomarker, zipclust, images;
  string dicts, work, utility, upgrades, wrkref, SampApps, SampData, pictures, piisafe;
  string btwork, btupgr, btdata;             { bluetooth transmission: final portion of directory structure where files will be copied to receiving machine }
  string heading, SupName, IntName;
  string bkpsup;                           { SD card to backup data to supervisor and auxiliary file name }
  string chkfile;
  string xparaux;
  string xparamet;                        { parameter to be passed to the data collection applications }
  string logCode;                         { used by IFSS to retrieve the result of data transferred }
  string synclogfile;                     { used to store sync data for upload to server }
  string IFSSlogFile;
  string clustfname;                      { keeps clusters filename after dictionary closed }
  string btserver = "";
        
  alpha(3) xfile;                         { upgrade file number to be transferred to interviewers }
  alpha(4) xintnum;                       { Interviewer }
  alpha(4) xsuperv;                       { Supervisor }
  alpha(8) xfilenum;                      { Number corresponding to data file names }
  alpha(4) xcluster;                      { Cluster number }
  string   xcase;                         { Case: Cluster number, household number, woman line number }
  string   xupgrade;                      { variable to read/write file fupgrade that remembers the number of upgrades arrived to the supervisor machine }
  string   upgrname;                      { upgrade names 9prefix) for interviewers.  supervisors are upgraded automatically by IFSS }
  string   xlang;                         { to check if there is another session running }

  numeric  i, j, k, x, action, option, ifok, found, SupCode, steam, IntCode, IntRole;
  numeric  hhdups, indups, biodups, totintvw, hhind, codebiomarker, SameSession;
  numeric  CurrDate, TransDate;
  numeric hhtoget;
  config   CSWebURL, CSWebUser, CSWebPIN, CSWebSurvey;
  string SyncCloudID_CC81 = "e7b8a288802849cfb4c1b28d5428b641";
  string SyncCloudPIN_CC81 = "A2Q1erBXZuMS9_";
  list string ListUpgrades, IntUpgrades;
  list string dirstocheck;
                                          { 2nd dimension: 1-Code
                                                                                                   2-Names
                                                                                                       3-Role                   }
  numeric TeamMemb = 0;                   { number of members of the same team }                                                                                                                 
  numeric PrevUpgrade;
  numeric isAndroid;                        // !! boolean to store OS
  numeric useCSBT = 1;                          // !! flag to select use of CSPro built-in bluetooth 
  string versiontxt ; // text showing version information at top of menu
  string sysver;     // number of last upgrade
  string upgserver;  // string for location of upgrades on server
  
  array interview(20);                     { to store interviewers assigned to a supervisor }
  array interrole(20);                     { to store role of interviewers assigned to a supervisor }
  array string intername(20);              { interviewer's name assigned to supervisor }
  array string caselist (50,5);            { to show qre review selection fields }
  valueset fieldworkers;

  array intvwcode(400);                    { to store interviewers - code }
  array intvwrole(400);                    {                       - role }
  array intvwteam(400);                    {                       - team }
  array intvwsex(400);                     {                       - sex  }
  array string intvwname(400);             {                       - name }
  numeric IFSS = 0;                       { If IFSS is being used }
  numeric SyncCloud = 1;                  { If SyncCloud is being used }
  numeric doFCT     = 0;                  { run FCT in field !!! }

  numeric minhhR    = 5;                  { minimum completed households that must be in supervisor tablet to begin selection for reinterview !!! }
  numeric maxhhselR = 5;                  { maximum number of  households that can be selected for reinteview by supervisor !!! }

  numeric c_to_check = 8040;              { cluster number to check to know if contsup needs to be reloaded see commments below !!! }


  function ReadIfssLog( string logFileName )
    FILE logfile;
    //results:
    //0       - log file not present - no login attempt made
    //1001    - login successful, finished send/receive
    //2000    - client closed before finishing send/receive
    //2001    - login unsuccessful: No internet connection
    //2002    - login unsuccessful: No project ID file present
    //2003    - login unsuccessful: User data unavailable
    //2004    - login unsuccessful: User name/password incorrect
    //2005    - login unsuccessful: Project not present on the server
    //default - Error reading file (wrong file supplied or something)
    x = 0;
    if FileExist(logFileName) then
      setfile( logFile, logFileName );
      open( logFile );
      FileRead( logFile, logCode );
      close( logFile) ;
      if IFSS then
        x = ToNumber(logCode);
      elseif SyncCloud then
        if pos("Execution successful", logCode) then
          x = 1001
        else
          x = 0
        endif;
      endif;
    endif;
    ReadIfssLog = x;
  end;

  { set up basic user bar }
  function userbase();
    userbar(clear);
    userbar( add button, "<",    do("PreviousField") );
    userbar( add button, ">",    do("NextField") );
    userbar( add button, ">>|",  do("AdvanceToEnd") );
    userbar( add button, "Lang", do("ChangeLanguage") );
    userbar( add button, "Ver",  Getversion() );
  end;

  { set value sets based on language }
  function OnChangeLanguage()
    setvaluesets( "_" + getlanguage() );
    savesetting("Language", getlanguage());
  end;

  { check if a file exist and deletes it }
  function fdel( string thisfile )
    if FileExist( thisfile ) then
      FileDelete( thisfile )
    endif;
  end;

  { check if a directory is present in project, if not, create it }
  function ChkDir( string thisfile )
    if !DirExist( thisfile ) then
      // errmsg( 008, thisfile );
      // stop(1);
      DirCreate(thisfile);
    endif;
  end;

  { launches CSEntry stopping SupMenu }
  function runpffS();
    ExecPff( AppName + ".pff", maximized, stop );
  end;

  { launches CSEntry with SupMenu waiting in the background }
  function runpffW();
    ExecPff( AppName + ".pff", maximized, wait );
  end;

  { function used to launch CSPro Index utility }
  function RunIndex()
    { Using single quotes instead of double quotes as double quotes are needed in the string generated }
    TheCommand = '"' + cspro + '\CSIndex.exe" ' + superv + '\' + AppName + '.pff';
    ExecSystem( TheCommand, maximized, wait );
  end;

  { function used to launch CSPro sort utility }
  function RunSort();
    { Using single quotes instead of double quotes as double quotes are needed in the string generated }
    TheCommand = '"' + cspro + '\CSSort.exe" ' + superv + "\" + AppName + '.pff';
    ExecSystem( TheCommand, maximized, wait );
  end;

  { concatenates individual's files as interviewers are able to collect different }
  { individuals from the same household. It is better to concatenate from receive }
  { to guarantee that all individuals are always available.  The same is true for }
  { partial cases                                                                 }
  function concatind()
    fdel( work + "\ALLIND.DAT" );
    fdel( work + "\ALLIND.DAT.CSIDX" );
    FileConcat( TJIN80, work + "\ALLIND.DAT",                           { result file }
              receive + "\I" + xcluster + "????.DAT" );         { individuals from all interviewers }
  end;

  { concatenates partial cases for individuals from all interviewers }
  function concatpari()
    fdel( work + "\ALLIND.DAT.sts" );
    FileConcat( work + "\ALLIND.DAT.sts",                      { result file }
              receive + "\I" + xcluster + "????.DAT.sts" ,      { partial files for individuals from all interviewers }
              receive + "\I" + xcluster + "????.dat.sts" );     { partial files for individuals from all interviewers }
  end;

  { concatenates household files for all interviewers }
  function concathh()
    fdel( work + "\ALLHH.DAT" );
    FileConcat( TJHH80, work + "\ALLHH.DAT",                           { result file }
               receive + "\H" + xcluster + "????.DAT" );        { household files from all interviewers }
  end;

  { concatenate biomarker data in case more than one biomarker specialist per team (very unsual but possible) }
  function concatBio()
    fdel( work + "\ALLBIO.DAT" );
    FileConcat( work + "\ALLBIO.DAT",                          { result file }
               receive + "\B" + xcluster + "????.DAT" );        { biomarker data files from all biomarker specialists }
  end;

  { concatenates others files for all interviewers }
  function concatoth()
    fdel( work + "\ALLOTH.DAT" );
    FileConcat( work + "\ALLOTH.DAT",                           { result file }
               receive + "\O" + xcluster + "????.DAT" );         { other files from all interviewers }
  end;

  { concatenates others files for all interviewers }
  function concatnotes()
    fdel( work + "\ALLNOTES.DAT" );
    FileConcat( work + "\ALLNOTES.DAT",                        { result file }
               receive + "\H" + xcluster + "????.DAT.CSNOT",    { household notes from all interviewers }
               receive + "\I" + xcluster + "????.DAT.CSNOT" );  { individual notes from all interviewers }
  end;

  { concatenates files collected by interviewers for sampling selection }
  function concatsamp()
    fdel( SampData + "\L" + xcluster + ".DAT" );
    FileConcat( SampData + "\L" + xcluster + ".DAT",            { result file }
               SampData + "\L" + xcluster + "????.DAT" );      { files with households listed by interviewers }
  end;

  { since all applications are of data entry type the first lines are the same for all of them }
  function InitPFF()
    setfile( piffile, superv + "\" + AppName + ".pff", create );
    FileWrite( piffile, "[Run Information]" );
    FileWrite( piffile, "Version=CSPro 7.4" );
    FileWrite( piffile, "AppType=Entry" );
    FileWrite( piffile, "[DataEntryInit]" );
    FileWrite( piffile, "OperatorID=" + opid );
  end;
  function string getsampfile (wclust);
    // checks if cluster specific sample file available
    // these are used for clusters sampled after fieldwork began
    // function returns file name for that cluster if found otherwise
    // returns sampsel.dat
    fname = wrkref + "\SAMPSEL_" + edit("9999", wclust) + ".DAT";
    if FileExist(fname) then
      getsampfile = path.GetFileName(fname);
    else
      getsampfile = "SAMPSEL.DAT";
    endif;
  end;

  { construct the PFF file for check-id }
  function CheckID( whatdata, dosumrep = 0 )
    { whatdata 1-file received from interviewers - receive      }
    {          2-temporary collapsed files for cluster - temp   }
    {          3-final cluster file - final                     }
    {          4-file from interviewers with biomarker inserted }
    {    !!!   5-running to resample picture files              }
    InitPFF();
    numeric chktotals = ( whatdata in 2,3 );
    FileWrite( piffile, "StartMode=ADD" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + superv + "\" + AppName + ".ent" );
    FileWrite( piffile, "Listing="     + superv + "\" + AppName +  ".lst" );
    FileWrite( piffile, "WriteData="   + superv + "\" + AppName +  ".wrt" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "CONTSUP="  + wrkref + "\SUPERV" + edit("9999",SupCode) + ".DAT" );
    FileWrite( piffile, "SAMPSEL="  + wrkref + "\" + getsampfile(WCLUSTER));
    FileWrite( piffile, "TRANSMIT=" + wrkref + "\TRANSMITM" + xsuperv + ".DAT" );
    FileWrite( piffile, "RMEASURE=" + temp   + "\R" + xcluster + ".dat" );
    if whatdata = 1 then       { data by interviewers }
      FileWrite( piffile, "TJHH80=" + receive + "\H" + xfilenum + ".DAT" );
      FileWrite( piffile, "TJIN80=" + work    + "\ALLIND.DAT" );
    elseif whatdata = 2 then   { data in working directory }
      FileWrite( piffile, "TJHH80=" + temp + "\H" + xcluster + ".DAT" );
      FileWrite( piffile, "TJIN80=" + temp + "\I" + xcluster + ".DAT" );
    elseif whatdata = 3 then   { data before sending cluster to central office }
      FileWrite( piffile, "TJHH80=" + final + "\H" + xcluster + ".DAT" );
      FileWrite( piffile, "TJIN80=" + final + "\I" + xcluster + ".DAT" );
    endif;
    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + xcluster + edit("9",chktotals) + edit("9", dosumrep ));
    if whatdata in 2,3,5 then // !!! special purpose to resize pictures only
      FileWrite( piffile, "Pictures=" + pictures);
      FileWrite( piffile, "Final=" + final);
    endif;
    if whatdata in 2, 3 then // !!! flag to indicate closing cluster
      FileWrite( piffile, "Closing=" + "Y");
    endif;
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    close( piffile );
  end;

  { generates a list of nottes taken by interviewer in cluster }
  function ListNotes()
    InitPff();
    FileWrite( piffile, "StartMode=ADD" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    { Files section }
    FileWrite( piffile, " " );
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );

    { External Files section }
    FileWrite( piffile, " " );
    FileWrite( piffile, "[UserFiles]" );
    FileWrite( piffile, "FILENOTE=" + work + "\ALLNOTES.DAT" );

    FileWrite( piffile, "[Parameters]" );
    { parameters are: cluster and household number (may include others for sub-samples) }
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + xcluster + "1" );
    FileWrite( piffile, "ViewListing=Never" );
    FileWrite( piffile, "ViewResults=No" );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    close( piffile );
  end;

  { constructs PFF file to entry supervisor control file }
  function Sentry()
    InitPFF();
    FileWrite( piffile, "StartMode=MODIFY;" + edit("9999",WCLUSTER) );
    FileWrite( piffile, "Lock=CaseListing" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + superv + "\" + AppName + ".ent" );
    FileWrite( piffile, "InputData="   + wrkref + "\SUPERV" + edit("9999",SupCode) + ".DAT" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "SAMPSEL="  + wrkref + "\" + getsampfile(WCLUSTER));

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    close( piffile );
  end;

  { constructs PFF file to assign households to interviewers in the cluster }
  function AssignHH(split = 0)
    InitPFF();
    FileWrite( piffile, "StartMode=MODIFY;" + edit("9999",WCLUSTER) );
    FileWrite( piffile, "Lock=CaseListing" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + superv + "\" + AppName + ".ent" );
    FileWrite( piffile, "InputData="   + wrkref + "\" + getsampfile(WCLUSTER));

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "CONTSUP="  + wrkref + "\SUPERV" + edit("9999",SupCode) + ".DAT" );
    FileWrite( piffile, "INTERV="   + wrkref + "\INTERV.DAT" );
    FileWrite( piffile, "HHFORINT=" + work   + "\S" + xcluster + ".DAT" );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + edit("99",steam) + edit("9", split) );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    close( piffile );
  end;

  { constructs PIF file for household and women data entry }
  function genpff( addmode, questype, savpart, revisit, change, hghtwght )
    // questype : 1-hh 2-individual 3:reinterview
    InitPFF();
    if addmode then
      FileWrite( piffile, "StartMode=ADD" );
      FileWrite( piffile, "Lock=Modify, Verify" );
    else
      FileWrite( piffile, "Lock=Modify, Verify" );
      if savpart then
        FileWrite( piffile, "StartMode=ADD;" + xcase );
      else
        FileWrite( piffile, "StartMode=MODIFY;" + xcase );
      endif;
    endif;
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );
    if questype = 1 then
      FileWrite( piffile, "InputData=" + work + "\ALLHH.DAT" );
    elseif questype = 2 then
      FileWrite( piffile, "InputData=" + work + "\ALLIND.DAT" );
    else
      FileWrite( piffile, "InputData=" + final + "\V" + xfilenum + ".DAT");
    endif;
    FileWrite( piffile, "Listing=" + superv + "\ALLENTRY.lst" );

    FileWrite( piffile, "[ExternalFiles]" );
    if questype = 1 then
      FileWrite( piffile, "TJIN80="   + work   + "\ALLIND.DAT" );
      FileWrite( piffile, "INTERV=" + wrkref + "\INTERV.DAT" );
      FileWrite( piffile, "HHFORINT=" + work   + "\S" + xcluster + ".DAT" );
    elseif questype = 2 then
      FileWrite( piffile, "TJHH80=" + work + "\ALLHH.DAT" );
    elseif questype = 3 then
      FileWrite( piffile, "HHFORINT=" + work   + "\S" + xcluster + ".DAT" );
    endif;
    FileWrite( piffile, "CLUSTERS=" + wrkref + "\CLUSTERS.DAT" );
    FileWrite( piffile, "OTHERS="   + work  + "\ALLOTH.DAT" );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    xparamet[10:1] = edit( "9", revisit );   { if this is a revisit }
    xparamet[11:1] = edit( "9", change );    { to run modify mode }
    xparamet[12:1] = edit( "9", savpart );   { case saved partially }
    xparamet[13:1] = edit( "9", hghtwght );  { to enter height and weight }
    FileWrite( piffile, "Parameter=" + xparamet + xcluster + edit("99",steam) );
    if questype = 3 then
      FileWrite( piffile, "ReInterview=1");
    endif;
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    close( piffile );
  end;

  function VacEntry( addmode, savpart);
    InitPFF();
    if addmode then
      FileWrite( piffile, "StartMode=ADD" );
      FileWrite( piffile, "Lock=Modify, Verify" );
    else
      FileWrite( piffile, "Lock=Modify, Verify" );
      if savpart then
        FileWrite( piffile, "StartMode=ADD;" + xcase );
      else
        FileWrite( piffile, "StartMode=MODIFY;" + xcase );
      endif;
    endif;
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + "..\VaccEntry\" + AppName + ".ent" );
    FileWrite( piffile, "InputData=" + final + "\F" + xcluster + ".dat");
    FileWrite( piffile, "Listing=" + superv + "\" + appname + ".lst" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "CLUSTERS=" + wrkref + "\CLUSTERS.DAT" );
    FileWrite( piffile, "TJHH80=" + work + "\ALLHH.DAT" );
    FileWrite( piffile, "TJIN80=" + work + "\ALLIND.DAT" );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + xparamet );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    close( piffile );
  end;
  { construct PFF file to run application to select children for remeasurement }
  function RemeasSel( )
    InitPFF();
    FileWrite( piffile, "StartMode=ADD" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + superv + "\" + AppName + ".ent" );
    FileWrite( piffile, "Listing="    + superv + "\" + AppName + ".lst" );
    FileWrite( piffile, "WriteData="  + superv + "\" + AppName + ".wrt" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "CONTSUP="  + wrkref + "\Superv" + edit("9999",SupCode) + ".dat" );
    FileWrite( piffile, "SAMPSEL="  + wrkref + "\" + getsampfile(WCLUSTER));
    FileWrite( piffile, "TJHH80="   + temp   + "\H" + xcluster + ".dat" );
    FileWrite( piffile, "TJIN80="   + temp   + "\I" + xcluster + ".dat" );
    FileWrite( piffile, "RMEASURE=" + temp   + "\R" + xcluster + ".dat" );
    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + xcluster );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { send remeasurement data to health specialists when biomarkers collected on tablets }
  function SendRemeas()
    fpath = utility + "\btclientPC";
    setfile( piffile, fpath + "\transfer.xml", create );
    { XML construction for transferring upgrades }
    FileWrite( piffile, '<?xml version="1.0" encoding="utf-8" ?>' );
    FileWrite( piffile, "<transfer>" );
    FileWrite( piffile, "<caption>" + tr("Sending Children for Remeasurement") + "</caption>" );
    { restrict sending HH assignemnets to individuals in the same team excluding supervisor & biomarkers }
    do i = 1 while i <= TeamMemb
      if SupCode <> tonumber(TeamShare(i,1)) & TeamShare(i,3) = "3" then
        FileWrite( piffile, '<to name="' + TeamShare(i,2) + '" id="' + TeamShare(i,1) + '" />' );
      endif;
    enddo;
    { encryption key, auto send parameter and timeout in seconds after which polling for devices is terminated }
    FileWrite( piffile, "<key>1111111111111111</key>" );
    FileWrite( piffile, "<autosend>false</autosend>" );
    FileWrite( piffile, "<timeout>120</timeout>" );
    { file to be sent }
    fname = temp + "\R" + xcluster + ".dat";
    FileWrite( piffile, '<file source="' + fname + '" destdir="' + btdata + '" />');        { actual file name }
    FileWrite( piffile, "</transfer>" );
    close( piffile );
    TheCommand = fpath + "\btclientPC.exe ";
    ExecSystem( TheCommand, normal, wait );
  end;

  { supervisor receives remeasurement from health specialists when remeasurement collected on tablets }
  function ReceiveRemeas()
    fpath = utility + "\btserverPC";
    TheCommand = fpath + "\btserverPC.exe " + '"id=' + edit("9999",SupCode) + '" "name=' + SupName + '" "rootdir=' + wrkprj + '" "encrkey=1111111111111111"';
    ExecSystem( TheCommand, normal, wait );
  end;

  { construct the PFF file to run application to enter remeasurement }
  function RemeasEntry( capipaper )
    InitPFF();
    FileWrite( piffile, "StartMode=ADD" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + superv + "\" + AppName + ".ent" );
    FileWrite( piffile, "Listing="    + superv + "\" + AppName + ".lst" );
    FileWrite( piffile, "WriteData="  + superv + "\" + AppName + ".wrt" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "RMEASURE="  + temp   + "\R" + xcluster + ".dat" );
    FileWrite( piffile, "INTERV="  + wrkref + "\INTERV.dat" );
    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + edit("9",capipaper) + edit("9999",codebiomarker) + xcluster );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { construct the PFF file to run application to list children remeasured }
  function RemeasLst( )
    InitPFF();
    FileWrite( piffile, "StartMode=ADD" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + superv + "\" + AppName + ".ent" );
    FileWrite( piffile, "Listing="    + superv + "\" + AppName + ".lst" );
    FileWrite( piffile, "WriteData="  + superv + "\" + AppName + ".wrt" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "RMEASURE="   + temp + "\R" + xcluster + ".dat" );
    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + xcluster );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { function used to run and execute the data entry applications }
  function csrun( addmode, questype, savpart, revisit, change, hghtwght )
  {
    Parameters - addmode,  the start mode of a data entry program
                 questype, 1-Household, 2-Women 3: hh reinterview
                 savpart,  if the case was partially saved (1-partial add, 2-partial modify)
                 revisit,  if it is a revisit to an incomplete interview (result code <> 1)
                 change,   advance to the first after the control of visits
                 hghtwght, instructs to advance to the height/ weight section for the household
  }
    genpff( addmode, questype, savpart, revisit, change, hghtwght );
    RunPFFS();
  end;

  { check that there is at least one file of the type needed received for cluster }
  function AnyFiles( thisfile );
    string fletter = "HIB";   // H-Households, I-Individuals, B-Biomarkers
    found = 0;
    do i = 1 while i <= TeamMemb & !found
      if FileExist( receive + "\" + fletter[thisfile:1] + xcluster + TeamShare(i,1) + ".dat" ) then
        found = 1;
      endif;
    enddo;
    AnyFiles = found;
  end;

  { collapses data files from all interviewers for the same cluster }
  function collapse();
    { files: data and partials for households and women }
    FileConcat( TJHH80, temp + "\H" + xcluster + ".dat",                   { households }
               receive + "\H" + xcluster + "????.DAT" );
    FileConcat( temp + "\H" + xcluster + ".dat.sts", 
                   receive + "\H" + xcluster + "????.DAT.sts" );
    FileConcat( TJIN80, temp + "\I" + xcluster + ".dat",                   { individuals }
               receive + "\I" + xcluster + "????.DAT" );
    FileConcat( temp + "\I" + xcluster + ".dat.sts",
               receive + "\I" + xcluster + "????.DAT.sts" );
    FileConcat( temp + "\B" + xcluster + ".dat",                   { biomarkers }
               receive + "\B" + xcluster + "????.DAT" );
  end;
  function string setblank (string instring, recidpos, string str_recid, varpos, varlength);
    // sets a specfied portion of a string to blank 
    // based on presence of record id string
    // assumes record id is length 3
    numeric bctr = 1;
    if instring[recidpos:3] = str_recid then // if is specified record
      do i = varpos until bctr > varlength
        instring[i:1] = " ";
        inc(bctr);
      enddo;
    endif;
    setblank = instring;
  end;

  function cleanpii (string infilename, ftype);
    // remove PII variables from data file
    // used to create anonymized data for upload
    // is done using text file processing in case files
    // are corrupted so they can be seen and repaired
    FILE inTxt;
    FILE outTxt;
    string fline;
    string datfilename = path.GetFileName(infilename);
    numeric recordpos;
    if ftype = 1 then
      recordpos = 9
    else
      recordpos = 11; 
    endif;
    setfile(inTxt, infilename, update);
    setfile(outTxt, piisafe + "\" + datfilename);
    while FileRead(inTxt, fline) do 
      // run functions to remove pii 
      if ftype = 1 then
        fline = setblank(fline, 9, "H00", 22,40); // QHADDRESS
        fline = setblank(fline, 9, "H00", 235,25);// GHLONGITUDE,GHLATITUDE
        fline = setblank(fline, 9, "H1X", 14,24); // AHFIRSTN,AHLASTN
        fline = setblank(fline, 9, "H01", 14,20); // AH02
        fline = setblank(fline, 9, "B01", 143,20);// QCNAME
        fline = setblank(fline, 9, "B02", 100,20);// QWNAME
        fline = setblank(fline, 9, "B03", 97 ,20);// QMNAME
      else
        fline = setblank(fline,11, "W00", 148,36); // QNAME
        fline = setblank(fline,11, "W00", 214,25); // GILONGITUD, GILATITUDE
        fline = setblank(fline,11, "W2B", 19 ,15); // Q218
        fline = setblank(fline,11, "W04", 26 ,20); // Q407
        fline = setblank(fline,11, "W05", 17 ,20); // Q503N
        fline = setblank(fline,11, "W6A", 17 ,20); // Q603N
        fline = setblank(fline,11, "W6B", 16 ,20); // Q635N
        fline = setblank(fline,11, "WEC", 17 ,20); // QECD2N
        fline = setblank(fline,11, "WG2", 18 ,15); // GC11N
        fline = setblank(fline,11, "M02", 38 ,15); // QM215
      endif;
      FileWrite(outTxt, fline);
    enddo;
    close(inTxt);
    close(outTxt);
  end;
  // function resizepics ();
  //   // resize picture files to make them smaller 
  //   list string ListFiles;
  //   image vaccpic;
  //   DirList( ListFiles, pictures, "\P" + xcluster + "*.jpg");
  //   // loop through files
  //   do i = 1 while i <= length(ListFiles)  
  //     errmsg("loading %s", ListFiles(i));
  //     vaccpic.load(ListFiles(i));
  //     vaccpic.resample(width := 800, height := 600); 
  //     vaccpic.save(pictures + "\tn" + path.GetFileName( ListFiles(i) ));
  //   enddo;
  // end;
  { generate all files for cluster to send them later to the central office }
  function alldata();
    numeric e;
    { copy main files from temp to final }
    FileCopy( temp + "\H" + xcluster + ".dat", final );         { hh }
    FileCopy( temp + "\H" + xcluster + ".DAT", final );         { individuals }
    FileCopy( temp + "\I" + xcluster + ".dat", final );         { hh }
    FileCopy( temp + "\I" + xcluster + ".DAT", final );         { individuals }
    // FileCopy( receive + "\?" + xcluster + "*.CSLOG", final );         { paradata requested from Trevor 8.5.2020-he doesn't want it concatenated so we have to send it seperately }
    // FileCopy( receive + "\?" + xcluster + "*.cslog", final );         { paradata requested from Trevor 8.5.2020-he doesn't want it concatenated so we have to send it seperately }
    // !!! zip the cslog and pictures files to reduce # files being moved around
    compress(final + "\CS" + xcluster + ".zip", receive + "\?" + xcluster + "*.cslog");  { paradata requested from Trevor 8.5.2020-he doesn't want it concatenated so we have to send it seperately }
    // compress(final + "\P"     + xcluster + ".zip", pictures + "\tnP" + xcluster + "*.jpg");   { pictures files for vaccinations }

    { concatenate others }
    FileConcat( final + "\O" +  xcluster + ".DAT",
               receive + "\O" + xcluster + "????.DAT" );
    { concatenate note files }
    FileConcat( final + "\N" + xcluster + ".CSNOT",
               receive + "\?" + xcluster + "????.DAT.csnot" );
  end;
  function FileChanged (string filetocheck);
    // uses md5 checksum to determine if a file has changed
    // return values: 0: not changed 1: changed 2: new file
    // requires MD5 file to have been opened prior to calling the function
    numeric md5res = 0;
    string file_path = strip(filetocheck);
    string MD5_Value = diagnostics("md5",file_path); // generate md5 hash for the file
    if FileExist(filetocheck) then // check file exists first !!!
      open(MD5);
      FILE_NAME = path.GetFileName(file_path); // get file name for lookup
      found = loadcase(MD5,FILE_NAME);        // look up file in md5 database
      if !found then  // new file
        md5res = 2;
      elseif MD5CODE <> MD5_Value then  // existing file but changed
        md5res = 1;
      else                             // existing file, not changed
        md5res = 0;
      endif;
      if md5res then // if changed/new we update the MD5 database
        MD5CODE= MD5_Value ;
        writecase(MD5);
      endif;
      close(MD5);
    endif;
    FileChanged = md5res;
  end;
  { receive data from interviewer using bluetooth }
  function recvdata (xint);
    set trace(on);
    numeric pic;
    if isAndroid | useCSBT then
      btserver = edit("9999", xint);
      if SyncConnect( Bluetooth, btserver ) then
        fname = data + "\?" + xfilenum + "*.DAT"; // main data files
        SyncFile( GET, fname, temp );
        fname = data + "\?" + xfilenum + "*.cslog"; // paradata
        SyncFile( GET, fname, temp );
        fname = data + "\?" + xfilenum + "*.csnot"; // notes
        SyncFile( GET, fname, temp );
        fname = data + "\?" + xfilenum + "*dat.sts"; // partial
        SyncFile( GET, fname, temp );
        fname = data + "\?" + xfilenum + "*DAT.sts"; // partial
        SyncFile( GET, fname, temp );
        // get backup pictures 
        do pic = 1 until pic > 3
          fname = pictures + "\P" + xcluster + "????????" + "_" + edit("99",pic) + ".jpg"; // get up to 4 previous pictures !!
          SyncFile( GET, fname, pictures );
        enddo;
        // get FW interview data files
        fname = data + "\F*" + edit("9999", xint) + ".DAT";
        SyncFile( GET, fname, receive );
        // get FW quiz data files
        fname = data + "\Q*" + edit("9999", xint) + ".DAT";
        SyncFile( GET, fname, receive );
        SyncDisconnect();
        fname = receive + "\F*" + edit("9999", xint) + ".DAT";
        if FileChanged(fname) then
          errmsg(tr("Received Fieldworker Questionnaire from interviewer %04d"), xint);
        endif;
        fname = receive + "\Q*" + edit("9999", xint) + ".DAT";
        if FileChanged(fname) then
          errmsg(tr("Received Test file from interviewer %04d"), xint);
        endif;
      endif;
    else
      fpath = utility + "\btserverPC";
      TheCommand = fpath + "\btserverPC.exe " + '"id=' + edit("9999",SupCode) + '" "name=' + SupName + '" "rootdir=' + wrkprj + '" "encrkey=1111111111111111"';
      ExecSystem( TheCommand, normal, wait );
    endif;
  end;
  { interviewer transfer data to supervisor using bluetooth, will return true if successful }
  function getquest( xint )
    set trace(on);
    { if data already in temp directory means that it was previously sent but }
    { supervisor was working with a different interviewer at the time. Since }
    { the data are there interviewers don't have to transfer them again      }
    if xint = SupCode then
      fname = data + "\?" + xfilenum + "*.*";
      FileCopy( fname, temp );    
    else
      recvdata(xint);
    endif;
    ifok = 0;
    { check if either a household or a woman's file arrived at the supervisor machine }
    if FileExist( temp + "\H" + xfilenum + ".DAT" ) |
       FileExist( temp + "\I" + xfilenum + ".DAT" ) then
      { delete empty household/individual files to avoid blank lines }
      if FileEmpty( temp + "\H" + xfilenum + ".DAT" ) then
        FileDelete( temp + "\H" + xfilenum + ".*" );
      endif;
      if FileEmpty( temp + "\I" + xfilenum + ".DAT" ) then
        FileDelete( temp + "\I" + xfilenum + ".*" );
      endif;
      { in some cases FileCopy didn't work when there were files in the target directory }
      FileDelete( receive + "\?" + xfilenum + ".*" );
      { copy files from temporary to receive directory }
      if FileCopy( temp + "\?" + xfilenum + "*.*", receive ) then
        { delete data files belonging to interviewer from temporary directory }
        FileDelete( temp + "\?" + xfilenum + "*.*" );
        ifok = 1;
      else
        errmsg( 019, xfilenum );
      endif;
    else
      errmsg( 017, WCLUSTER, xint );
    endif;
    getquest = ifok;
  end;

  { check if other interviewers sent data concurrently }
  function remainfile()
    do i = 1 while interview(i)
      fname = xcluster + edit("9999", interview(i)) + ".DAT";
      { check if household/woman file arrived at the supervisor machine for interviewer(i) }
      if FileExist( temp + "\H" + fname ) |
         FileExist( temp + "\I" + fname ) |
         FileExist( temp + "\B" + fname ) then               // when Biomarkers collected in tablets
        ICODE = interview(i);
        loadcase( INTERV, ICODE );
        errmsg( 018, WCLUSTER, ICODE, INAME );
      endif;
    enddo;
  end;

  { check version number available for next back-up.  It is a Round-robin system made of up to 10 versions  }
  function backupn()
    numeric n;
    do n = 0 while n <= 9 & FileExist(bkpsup + "\C" + xcluster + "_" + edit("9",n) + ".zip")
    enddo;
    { open space for next back-up }
    x = n + 1;
    if n = 9 then x = 0 endif;
    fname = bkpsup + "\C" + xcluster + "_" + edit("9",x) + ".zip";
    if FileExist( fname ) then
      FileDelete( fname );
    endif;
    backupn = n;
  end;

  { finds the drive letter where the flash memory is located }
  function searchdrive()
    found = 0;
    do i = 1 while i <= 5 & !found
      bkpsup = "DEFGH"[i:1] + ":\BACKUP";     // use FileExist if using CSPro 4.1
      if DirExist(bkpsup) then
        found = 1;
      endif;
    enddo;
    searchdrive = found;
  end;

  // { back-ups final data to supervisor flash memory }
  // function backupf()
    // numeric nextbkp;
    // if !searchdrive() | !DirExist(bkpsup) then
      // errmsg( 070, bkpsup );
      // searchdrive();
    // endif;
    // if DirExist(bkpsup) then
      // { round robin next back-up number }
      // nextbkp = backupn();
      // TheCommand = Utility + "\UpgradePc\7za.exe a -w" + work + " -i!" + final +  "\*" + xcluster + ".dat -pDHS" + xsuperv + " " + bkpsup + "\C" + xcluster + "_" + edit("9",nextbkp) + ".zip";
// {     errmsg( "Command=%s", TheCommand );   }
      // ExecSystem( TheCommand, maximized, wait );
      // errmsg( 072, bkpsup );
    // else
      // errmsg( 071, bkpsup );
    // endif;
  // end;

  { check that files for households and women exist in a given directory }
  function files_in( string directory, string thisfile )
    ifok = 0;
    if FileExist( directory + "\H" + thisfile + ".DAT" ) &
       FileExist( directory + "\I" + thisfile + ".DAT" ) then
      ifok = 1;
    endif;
    files_in = ifok;
  end;

  { check that household file (thisfile) exists in a given directory }
  function files_hh( string directory, string thisfile )
    ifok = 0;
    if FileExist( directory + "\H" + thisfile + ".DAT" ) &
      !FileEmpty( directory + "\H" + thisfile + ".DAT" ) then
      ifok = 1;
    endif;
    files_hh = ifok;
  end;

  { function to send data to central office using CSWeb FTP }
  function SendData_CSW()
    numeric DataOK = 0;
    errmsg( 500 );
    if SyncConnect( CSWeb, CSWebURL, CSWebUser, CSWebPIN ) then
      if SyncFile( PUT, final + "\?" + xcluster + "*.*", CSWebSurvey + "Final" ) then
             SyncFile( PUT, final + "\?" + xcluster + "*.cslog", CSWebSurvey + "Final" );  { paradata requested from Trevor 8.5.2020-he doesn't want it concatenated so we have to send it seperately }
             SyncFile( PUT, wrkref + "\Superv" + xsuperv + "*.dat", CSWebSurvey + "Final" );  
             SyncFile( PUT, wrkref + "\TRANSMITM" + xsuperv + "*.DAT", CSWebSurvey + "Final" );
             SyncFile( PUT, wrkref + "\TransmitM" + xsuperv + "*.DAT", CSWebSurvey + "Final" );
             SyncFile( PUT, wrkref + "\TransmitM" + xsuperv + "*.dat", CSWebSurvey + "Final" );
             SyncFile( PUT, wrkref + "\TRANSMITM" + xsuperv + "*.dat", CSWebSurvey + "Final" );
         SyncFile( PUT, Receive + "\?" + xcluster + "????.*", CSWebSurvey + "Receive" );  {testing to see if was working or not }
      endif;
      syncdisconnect();
    endif;
    if DataOK then 
      errmsg( 501 );
    else
      errmsg( 502 );
    endif;
  end;
  function string extract_UpgrNum (string str_path)
    string str_fname = path.GetFileName(str_path);
    numeric w_start, w_len;
    // get upgrade number from the file name
    // note this assumes the file name minus extension ends in n digits and there are no other numbers in the name
    // 123456789
    // upgdhs1.zip
    w_start = length(upgrname) + 1;
    w_len   = pos(".zip", str_fname) - w_start;
    extract_UpgrNum = str_fname[w_start:w_len];
  end;
  { applying updates coming from cloud into supervisor's machine in directory upgrades }
  {ANDROID}
    function ApplyUpgr()
      numeric cur_version = tonumber(sysver);
      numeric new_version;
      string fmask = upgrname + "*.zip";
      if isAndroid  then
        fpath = PathName(CSEntry) + "TJ81";
      else
        fpath = wrkprj;
      endif;
      // do dir list
      ListUpgrades.clear();
      DirList( ListUpgrades, upgrades, fmask);
      ListUpgrades.sort();
      // loop through files checking if they are new/changed
      if length(ListUpgrades) > 0 then
        do i = 1 while i <= length(ListUpgrades)  
          fname  = ListUpgrades(i);
          fname2 = btupgr + "/" + path.GetFileName(fname);
          new_version = tonumber(extract_UpgrNum(fname));
          if  new_version > cur_version then
            ifok = decompress(fname, fpath); 
            if ifok then
              errmsg( 090, path.GetFileName(fname));
              cur_version = new_version;
              FileCopy(fname, fname2); // !!! copy any new upgrade files to upgrades folder for bt transfer
            else
              errmsg( 092, path.GetFileName(fname));
              FileDelete(fname); // !!! delete the file that can't be extracted in case we need to download another copy
            endif;
          endif;
        enddo;
      endif;
      if cur_version > tonumber(sysver) then
        sysver = edit("999", cur_version);
        SaveSetting( "Version", sysver );
        // clean indexes in case ref files are sent via update !!!
        CleanIndex(wrkref);
        errmsg(91);
        stop(-1);
      endif;
    end;
  function GenSyncLog ();
    { generates sync log file to be uploaded to server }
    { writes : publishdate, date, time, previous upgrade number, current upgrade number }
    string lastfct = loadsetting("LastFCTRun","0");
    setfile(SyncLog, synclogfile, create);
    FileWrite(SyncLog, maketext("%04d,%d,%s,%s,%s,%s", tonumber( loadsetting("Supervisor")), sysdate("YYYYMMDD"), edit("99:99:99",systime()), sysver,lastfct, diagnostics("version_detailed")));
    SyncLog.close();
  end;
  function SendData_SyncCloud()
    GenSyncLog(); // generate sync log file for upload !!!
    set trace;
    SystemApp Sync_App;
    Sync_App.clear();
    if !connection() then
      errmsg( 200 );
      exit;
    endif;
    if isandroid then
      Sync_App.SetArgument("projectid", SyncCloudID_cc81);
      Sync_App.SetArgument("username", "Sup"+xsuperv );
      Sync_App.SetArgument("password", SyncCloudPIN_cc81);
      Sync_App.SetArgument("textlog", IFSSlogFile); 
      x = Sync_App.exec("com.dec.syncclient");
    else
      Sync_App.SetArgument("ProjectId=", SyncCloudID_cc81);
      Sync_App.SetArgument("Username=", "Sup"+xsuperv[1:2]);
      Sync_App.SetArgument("Password=", SyncCloudPIN_cc81);
      Sync_App.SetArgument("log=", IFSSlogFile);
      x = Sync_App.exec(utility + "\SyncCloudClientWin\ScClient.exe");
    endif;
    SendData_SyncCloud = x; // save result
  end;
  {Concat all closed clusters data}
  function concatall(string wdir);
    list string hhlogs, inlogs;
    // Household data
    fdel( wdir + "\AllHH.dat" );
    fdel( wdir + "\AllHH.dat.csidx" );
    fdel( wdir + "\AllHH.dattest.dat" );
    fdel( wdir + "\AllHH.dattest.csidx" );
    FileConcat( TJHH80, wdir + "\AllHH.dat",  wdir + "\H" + "*.dat");         { households for all clusters completed }
    // FileConcat( wdir + "\AllHHtest.dat",  wdir + "\H" + "*.dat");         { households for all clusters completed }
    // Individual data
    fdel( wdir + "\AllInd.dat" );
    fdel( wdir + "\AllInd.dat.csidx" );
    FileConcat( TJIN80, wdir + "\AllInd.dat", wdir + "\I" + "*.dat");         { individuals for all clusters completed }
    // remeasurement data
    fdel( wdir + "\AllRm.dat" );
    fdel( wdir + "\AllRm.dat.csidx" );
    FileConcat( wdir + "\AllRm.dat",  wdir + "\R" + "*.dat");         { remeasurement data for all clusters completed }
    // run function to remove garbage lines
    // fixdata(wdir + "\AllHH.dat",1);
    // fixdata(wdir + "\AllInd.dat",2);

    // list all paradata logs
    dirlist(hhlogs, receive, "\H*.cslog");
    dirlist(inlogs, receive, "\I*.cslog");
    // // concatenate paradata logs into one file
    // if hhlogs.length() & inlogs.length() then
    //   paradata(concat, wdir + "\paradata.cslog", hhlogs, inlogs);
    // endif;
  end;
 { constructs PFF file to run the field check tables input for the team }
  function FCT(string wdir)
    InitPFF();

    FileWrite( piffile, "StartMode=ADD" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + superv + "\" + AppName + ".ent" );
    FileWrite( piffile, "Listing=" + superv + "\" + AppName + ".lst" );
    FileWrite( piffile, "WriteData=" + superv + "\output.csv" );
    FileWrite( piffile, "CommonStore=" + "..\shared.db" );
    FileWrite( piffile, "" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "TJHH80="   + wdir + "\AllHH.dat");
    FileWrite( piffile, "TJIN80="   + wdir + "\AllInd.dat");
    FileWrite( piffile, "CONTSUP="  + wrkref + "\Superv" + edit("9999",SupCode) + ".dat" );
    FileWrite( piffile, "RMEASURE=" + wdir + "\AllRm.dat");

    FileWrite( piffile, "" );
    FileWrite( piffile, "[UserFiles]" );
    FileWrite( piffile, "PartialFile=" );
    FileWrite( piffile, "Sc_HtmlOutput=" );
    FileWrite( piffile, "Sc_XmlOutput=" );
    FileWrite( piffile, "" );
    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + edit("99",steam) );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );

    close( piffile );
  end;

  
  { function to display HTML files }
  function HTML_Display( string thisfile )
   view( thisfile );
  end;

  function getint ();
    numeric ifound = 0;
    // asks user to select an interviewer and sets internal variables 
    ifound = showarray( tr("Select fieldworker "), TeamShare, title(tr("Code"), tr("Name"), tr("Role")) );
    if ifound then
      xfilenum = xcluster + TeamShare(ifound,1);
      intcode  = tonumber(TeamShare(ifound,1));
      introle  = tonumber(TeamShare(ifound,3));
      intname  = TeamShare(ifound,2);
    endif;
    getint = ifound;
  end;

  { make supervisor machine available as server for interviewers to retreive upgrades }
  function sendupgr()
    numeric ctr;
    if isAndroid | useCSBT then
      SyncServer( Bluetooth );
    else
      // get list of upgrades on supervisor device
      if getint() then
        ListUpgrades.clear();
        DirList( ListUpgrades, upgrades, upgrname + "*.zip");
        // delete any old version of file with list of upgrades prior to receiving
        fname = work + ".\TrackUpg.txt";
        FileDelete(fname);
        // connect to interviewer device and receive list of upgrades on that device
        fpath = utility + "\btserverPC";
        TheCommand = fpath + "\btserverPC.exe " + '"id=' + edit("9999",SupCode) + '" "name=' + SupName + '" "rootdir=' + wrkprj + '" "encrkey=1111111111111111"';
        ExecSystem( TheCommand, normal, wait );
        TrackUpg.Open(fname, update);
        TrackUpg.Read(IntUpgrades);
        // remove existing upgrades on interviewer device from list of upgrades to send
        ListUpgrades.RemoveIn(IntUpgrades);

        if ListUpgrades.length() then
          fpath = utility + "\btclientPC";
          setfile( piffile, fpath + "\transfer.xml", create );
          { XML construction for transfering upgrades }
          FileWrite( piffile, '<?xml version="1.0" encoding="utf-8" ?>' );
          FileWrite( piffile, "<transfer>" );
          FileWrite( piffile, "<caption>" + tr("Sending Upgrades") + "</caption>" );
          FileWrite( piffile, '<to name="' + IntName + '" id="' + edit("9999", IntCode) + '" />' );
          { encryption key, auto send parameter and timeout in seconds after which polling for devices is terminated }
          FileWrite( piffile, "<key>1111111111111111</key>" );
          FileWrite( piffile, "<autosend>false</autosend>" );
          FileWrite( piffile, "<timeout>120</timeout>" );
          do ctr = 1 until ctr > ListUpgrades.length()
            FileWrite( piffile, '<file source="' + ListUpgrades(ctr) + '" destdir="' + btupgr + '" />' );        { actual file name }
          enddo;
          FileWrite( piffile, "</transfer>" );
          close( piffile );
          TheCommand = fpath + "\btclientPC.exe ";
          ExecSystem( TheCommand, normal, wait );
        else
          errmsg(093);
        endif;  // listupgrades.length
      endif; // getint
    endif; // isandroid
  end;

  { make supervisor machine availalbe as server for interviewers to retreive household assignment }
  function sendassign()
    if isAndroid | useCSBT  then
      SyncServer( Bluetooth );
    else
        
      fpath = utility + "\btclientPC";
      setfile( piffile, fpath + "\transfer.xml", create );
      { XML construction for transferring upgrades }
      FileWrite( piffile, '<?xml version="1.0" encoding="utf-8" ?>' );
      FileWrite( piffile, "<transfer>" );
      FileWrite( piffile, "<caption>" + tr("Sending Households Assigned") + "</caption>" );
      { restrict sending HH assignemnets to individuals in the same team excluding supervisor & biomarkers }
      do i = 1 while interview(i)
        if SupCode <> interview(i) & interrole(i) <> 3 then
          FileWrite( piffile, '<to name="' + intername(i) + '" id="' + edit("9999",interview(i)) + '" />' );
        endif;
      enddo;
      { encryption key, auto send parameter and timeout in seconds after which polling for devices is terminated }
      FileWrite( piffile, "<key>1111111111111111</key>" );
      FileWrite( piffile, "<autosend>false</autosend>" );
      FileWrite( piffile, "<timeout>120</timeout>" );
      { construct send the file }
      fname = work + "\S" + xcluster + ".DAT";
      if FileExist(fname) then
        FileWrite( piffile, '<file source="' + fname + '" destdir="' + btwork + '" />' );        { actual file name }
        FileWrite( piffile, '<file source="' + fname + '.CSIDX" destdir="' + btwork + '" />' );    { index file }
      endif;
      FileWrite( piffile, "</transfer>" );
      close( piffile );
      TheCommand = fpath + "\btclientPC.exe ";
      ExecSystem( TheCommand, normal, wait );
    endif;
  end;

  { change file setting for household assignment for a cluster }
  function SetEligFile(newfile)
    x = 1;
    { file name for households assigned to interviewers is only known after the cluster is entered. It is set here }
    fname = work + "\eligibles.dat";
    if !FileExist( fname ) then
      errmsg( 035, fname );
      x = 0;
    else
      if newfile & !setfile( ELIGINDV, fname, create ) | 
        !newfile & !setfile( ELIGINDV, fname, update ) then
        errmsg( 035, fname );
        x = 0;
      endif;
    endif;
    SetEligFile = x;
  end;

  function GetPubDate ();
    errmsg("Ver:%d", int( publishdate()/100 ) ) ;
  end;


  function gethh ();
    string header = tr("Select a household to review from the list:");
    fname = work + "\ALLHH.DAT";
    concathh();                { concatenate households }
    concatoth();                { concatenate others }
    hhdups  = FindDups( dirstocheck, xcluster, 1);
    if !hhdups then
      setfile(TJHH80, fname );
      numeric ctr = 0;
      caselist.clear();
      forcase TJHH80 do
        inc(ctr);
        caselist(ctr,1) = edit("9999", QHNUMBER );
        caselist(ctr,2) = QHADDRESS;
        caselist(ctr,3) = getlabel(QHRESULT, QHRESULT);
        caselist(ctr,4) = edit("9999", QHINTNUM );
      enddo;
      x = showarray(header, caselist, title(tr("No."), tr("Address"), tr("Result"), tr("Int")));
      if x then
        QHCLUST = WCLUSTER;
        QHNUMBER = tonumber(caselist(x,1));
        loadcase(TJHH80, QHCLUST, QHNUMBER);
      endif;
      close( TJHH80 );
    else
      x = 0;
    endif;
    gethh = x;
  end;
  
  function review_hh ();
    if !anyfiles(1) then            { check if hh files have been transferred to supervisor }
      errmsg( 080, xcluster );
    else
      if gethh() then
        { review households including incomplete }
        if QHRESULT <> 1 then
          errmsg( 0011, QHRESULT );
        endif;
        xcase  = edit("9999", WCLUSTER) + edit("9999",QHNUMBER);
        xparamet = xparaux + edit("9999",QHNUMBER);
        AppName = "CollectHH";
        { modify, hh, partial, revisit, change, height/weight }
        SaveSetting( "SupSession", "5" );
        csrun( 0, 1, 0, 0, 1, 0 );
      endif;
    endif;
  end;
  
  function review_ind();
    string header;
    if !anyfiles(2) then            { check if ind files have been transferred to supervisor }
      errmsg( 080, xcluster );
    else
      if !hhtoget then
        hhtoget = gethh();
      endif;
      fname = work + "\ALLIND.DAT";
      close(TJIN80);
      concatind();
      concatoth();                { concatenate others }
      if !FindDups( dirstocheck, xcluster, 2) then
        setfile(TJIN80, fname );
        header = maketext (tr("Select an woman to review from household %04d"), hhtoget);
        caselist.clear();
        numeric ctr = 0;
        forcase TJIN80 where QNUMBER = hhtoget do
          inc(ctr);
          caselist(ctr,1) = edit("9999", QNUMBER );
          caselist(ctr,2) = edit("99", QLINE );
          caselist(ctr,3) = QNAME;
          caselist(ctr,4) = getlabel(QRESULT, QRESULT);
          caselist(ctr,5) = edit("9999", QINTNUM );
        enddo;
        x = showarray(header, caselist, title(tr("No."), tr("Line"), tr("Name"), tr("Result"), tr("Int")));
        if x then
          QCLUSTER = WCLUSTER;
          QNUMBER  = tonumber( caselist(x,1));
          QLINE    = tonumber( caselist(x,2));
          if loadcase(TJIN80, QCLUSTER, QNUMBER, QLINE) then
            xcase  = edit("9999", WCLUSTER) + edit("9999",QNUMBER) + edit("99",QLINE);
            xparamet = xparaux + edit("9999",QNUMBER) + edit("99",QLINE);
            AppName = "CollectIN";
            { review households including incomplete }
            if QRESULT <> 1 then
              errmsg( 0011, QRESULT );
            endif;
            close( TJIN80 );
            { modify, hh, partial, revisit, change, height/weight }
            SaveSetting( "SupSession", "6" );
            SaveSetting( "hhtoget", edit("9999", hhtoget));
            csrun( 0, 2, 0, 0, 1, 0 );
          endif;
        endif;
      endif;
    endif;
  end;

  function prep_FCT ();
    // clean working files from temp folder 
    // don't delete remeasurement files because they are stored in temp
    FileDelete(temp + "\H*.*");
    FileDelete(temp + "\I*.*");
    FileDelete(temp + "\*.cslog");
    FileDelete(temp + "\*.csidx");
    // copy files to temp
    FileCopy(receive + "\H????????.DAT", temp);
    FileCopy(receive + "\I????????.DAT", temp);
    FileCopy(receive + "\*.cslog", temp);
    { folder list for checking duplicates }
    dirstocheck.clear();
    dirstocheck.add(temp);
    { check and delete duplicate cases}
    FindDups(dirstocheck, "????", 1,1);
    FindDups(dirstocheck, "????", 2,1);
    // concat files
    concatall(temp);
    // reset folder for duplicates 
    dirstocheck.clear();
    dirstocheck.add(receive);
    // clean working files from temp folder 
    FileDelete(temp + "\H*.*");
    FileDelete(temp + "\I*.*");
    FileDelete(temp + "\*.cslog");
    FileDelete(temp + "\*.csidx");
  end;
  function check_reint ();
    // checks to see if the required criteria for reinterview are present:
    // at least n complete households received 
    // no more than n households selected for reinterview
    numeric e = 0;

    // load case from supervisor control file
    setfile(CONTSUP, wrkref + "\SUPERV" + edit("9999",SupCode) + ".DAT", update);
    SSAMPLE = WCLUSTER;
    loadcase( CONTSUP, SSAMPLE );
    
    // check min and max households
    numeric comphh = count(SALLHH where SNUMBER <> 0 );
    numeric xreint = count(SALLHH where SREINTERV <> 0 );
    if comphh < minhhR then // less than 5 completed households
      e = errmsg(125, comphh, minhhR );
    elseif xreint >= maxhhselR then // already have max number of selected for reinterview
      e = errmsg(127, xreint);
    endif;
    check_reint = !e;
  end;
  function sel_reint();
    // selects households for re-interview
    numeric hhsel, hhidx, choice;
    list hhids;
    seed(systime());
    hhdups  = FindDups( dirstocheck, xcluster, 1);
    if !hhdups then
      concathh();                { concatenate households }
      fname = work + "\ALLHH.DAT";
      setfile(TJHH80, fname, update );
      setfile(CONTSUP, wrkref + "\SUPERV" + edit("9999",SupCode) + ".DAT", update);
      SSAMPLE = WCLUSTER;
      loadcase( CONTSUP, SSAMPLE );
      // count complete hh's and put keys in list
      forcase TJHH80 where QHRESULT = 1 & QHINTNUM <> WSUPER do
        hhids.add(QHNUMBER);
      enddo;
      numeric xreint = count(SALLHH where SREINTERV <> 0 );
      numeric tries = 0;
      if hhids.length() then
        do until xreint = 5 | tries > 20
          hhsel = random(1, hhids.length());
          hhidx = seek(SNUMBER = hhids(hhsel));
          inc(tries);
          if !SREINTERV(hhidx) & !count(SALLHH where SREINTERV & SINTNUM = SINTNUM(hhidx)) then
            SREINTERV(hhidx) = 1;
            choice = errmsg(tr("Household %03d interviewed by interview %04d selected for reinterview\nConfirm selection for this household? (%d households already selected)"), SNUMBER(hhidx), SINTNUM(hhidx), xreint) 
                     select (tr("Yes"), continue, tr("No"), continue, "Cancel Selection", continue);
            if choice = 1 then
              writecase(CONTSUP);
              inc(xreint);
              tries = 0;
              choice = errmsg(tr("Select anothe household for reinterview ? (%d households already selected)"), xreint) 
                       select (tr("Yes"), continue, tr("No"), continue);
              if choice <> 1 then
                break;
              endif;
            elseif choice = 3 then 
              break;
            endif;
          endif;
        enddo;  
        if xreint < 5  & tries > 20 then
          errmsg(tr("No more households available for selection at this time"));
        endif;
      endif;
    endif;
    sel_reint = hhidx;
    close(CONTSUP);
    close(TJHH80);
  end;

    function SetAssignFile()
      x = 1;
      { file name for households assigned to interviewers is only known after the cluster is entered.  It is set here }
      fname = work + "\S" + edit("9999",WCLUSTER) + ".DAT";
      if !FileExist( fname ) then
        errmsg( 095 );
        x = 0;
      else
        if !setfile( HHFORINT, fname ) then
          errmsg( 095);
          x = 0;
        endif;
      endif;
      SetAssignFile = x;
    end;
  { runs wrkelig logic  }
  function WrkEligR()
    { type   1-households, 2-individual, 3: households not including shared }
    alpha(10)  key_HH;                     { !! adjust to the length of the key cluster+hh+line }
    string     fnameHH;              { to extract file name from household and individual dictionaries }

    fnameHH = final + "\V" + edit("9999",WCLUSTER) + xsuperv + ".DAT";

    // check if hh file exists and create empty file if necessary to avoid error message
    if FileExist(fnameHH) then
      setfile(TJHH80, fnameHH, update);
    else
      setfile(TJHH80, fnameHH, create);
    endif;
    while loadcase( TJHH80 ) do
      { households requested }
      key_HH = edit("9999",QHCLUST) + edit("9999",QHNUMBER) + "  ";
      if loadcase( ELIGINDV, key_HH) then
        delcase( ELIGINDV );
      endif;
      ZCLUSTER = QHCLUST;
      ZNUMBER  = QHNUMBER;
      ZLINE    = notappl;
      ZNAME    = " ";
      ZQTYPEA  = " ";
      ZRESULT  = QHRESULT;
      ZOWNER   = QHINTNUM;
      {ZMALE    = QHELIGM;} {No Males selected in TJ}
      if soccurs( TJHH80.QHSEC01X ) then
        ZNAME = strip(QHFIRSTN(1)) + " " + strip(QHLASTN(1));
      endif;
      ZADDRESS = QHADDRESS;
      if length( strip(ZNAME) ) = 0 then ZNAME = ZADDRESS endif;
      if QHRESULT <> 1 then
        // ZSTATUS  = tr("Incomplete") + maketext(" (%1d)", QHRESULT);
        ZSTATUS  = getlabel(QHRESULT, QHRESULT);
        ZSTATUSC = 2;
      elseif partialcs( 1, QHCLUST, QHNUMBER, 0, fnameHH  ) then
        ZSTATUS  = tr("Partial");
        ZSTATUSC = 3;
      else
        ZSTATUS  = tr("Complete");
        ZSTATUSC = 1;
      endif;
      ZQUEST  = 1;
      writecase( ELIGINDV );
    enddo;
    close( TJHH80 );

    // check for reinterviews not yet begun
    setfile(CONTSUP, wrkref + "\SUPERV" + edit("9999",SupCode) + ".DAT", update);
    SSAMPLE = WCLUSTER;
    x = loadcase( CONTSUP, SSAMPLE );
    
    forcase HHFORINT do 
      ZCLUSTER = WCLUSTER;
      ZNUMBER  = VNUMBER;
      if count(SALLHH where SNUMBER = ZNUMBER & SREINTERV = 1) then // selected for reinterview
        ZLINE    = notappl;
        if !loadcase(ELIGINDV, ZCLUSTER, ZNUMBER, ZLINE) then // household assigned but not yet begun
          ZLINE    = notappl;
          ZQTYPEA  = " ";
          ZRESULT  = 0;
          ZOWNER   = SupCode;
          ZNAME    = VNAME;
          ZADDRESS = VADDRESS;
          ZMALE    = VMALE;
          ZSTATUS  = tr("Not Visited");
          ZSTATUSC = 0;
          writecase(ELIGINDV);
        endif;
      endif;
    enddo;
    close(TJHH80);
    close(HHFORINT);
  end;

  function ListRI()
    // lists households eligible for reinterview and shows comparison
    InitPff();
    FileWrite( piffile, "StartMode=ADD" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );

    { Files section }
    FileWrite( piffile, " " );
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + Superv + "\" + AppName + ".ent" );
    FileWrite( piffile, "Listing="     + Superv + "\" + AppName + ".lst" );
    FileWrite( piffile, "WriteData=.\" + AppName + ".wrt" );

    { External Files section }
    FileWrite( piffile, " " );
    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "HHFORINT=" + work   + "\S" + xcluster + ".DAT" );
    FileWrite( piffile, "TJHH80=" + final + "\V" + xcluster + edit("9999",SupCode) + ".DAT" );
    FileWrite( piffile, "CONTSUP="  + wrkref + "\SUPERV" + edit("9999",SupCode) + ".DAT" );
    FileWrite( piffile, "ELIGINDV=" + work + "\eligibles.dat");
    FileWrite( piffile, "[Parameters]" );
    { parameters are: cluster and household number (may include others for sub-samples) }
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + xcluster + edit("9999",SupCode) );
    FileWrite( piffile, "allhh=" + work + "\ALLHH.DAT");
    FileWrite( piffile, "ViewListing=Never" );
    FileWrite( piffile, "ViewResults=No" );
    FileWrite( piffile, "OnExit=.\SupMenu.pff" );
    close( piffile );
  end;
  function CopySampSel ();
    // make copy of sampsel file for upload to server for troubleshooting
    fname = wrkref + "\SAMPSEL";
    FileCopy(fname + ".DAT", fname + xsuperv + ".DAT");
  end;
  function CleanFiles (string tid);
    FileDelete(receive + "\" + "?" + tid + "*.*");
    FileDelete(data + "\" + "?" + tid + "*.*");
    FileDelete(final + "\" + "?" + tid + "*.*");
    FileDelete(temp + "\" + "?" + tid + "*.*");
    FileDelete(work + "\" + "?" + tid + "*.*");
    FileDelete(pictures + "\" + "?" + tid + "*.*");
  end;

  function string OnSyncMessage (string message_name, string message_value);
    // check cluster number is the same on both tablets !!!
    // first check interviewer cluster number = supervisor one
    if message_name = "INTERVIEWER_CLUSTER" then
      if message_value <> xcluster then // if its different display error message and disconnect
        errmsg(050, message_value, xcluster);
        syncdisconnect();
      endif;
    elseif message_name = "SUPERVISOR_CLUSTER" then // send cluster number back to interviewer menu
      exit xcluster;
    endif;
  end;


  function mkpiisafe ();
    // generate files with pii stripped data for all closed clusters
    list string filelist;
    numeric fctr;
    DirList(filelist, final, "H*.dat");
    do fctr = 1 while fctr <= filelist.length()
      if FileChanged(filelist(fctr)) then
       cleanpii(filelist(fctr),1)
      endif;
    enddo;
    DirList(filelist, final, "I*.dat");
    do fctr = 1 while fctr <= filelist.length()
      if FileChanged(filelist(fctr)) then
       cleanpii(filelist(fctr),2)
      endif;
    enddo;
  end;
  function run_VacEntry ();
    // read woman's data and build list of children
    array string list_ch (50,9);
    numeric status;
    if !anyfiles(2) then            { check if ind files have been transferred to supervisor }
      errmsg( 080, xcluster );
      reenter WFINAL;
    else
      if  FindDups( dirstocheck, xcluster, 1) | FindDups( dirstocheck, xcluster, 2) then
        reenter WFINAL;
      else
        concathh();     { concatenate household questionnaires from all interviewers }
        concatind();     { concatenate individual questionnaires from all interviewers }
        fname = work + "\ALLIND.DAT";
        setfile(TJIN80, fname);
        // open facility file for checking status
        fname = final + "\F" + xcluster + ".dat";
        if !FileExist(fname) then
          setfile(FACVACC, fname, create); 
        else
          setfile(FACVACC, fname, update); 
        endif;
        i = 0;
        forcase TJIN80 where QRESULT = 1 & seek(FA01 = 1) do // build list of children
          do j = 1 until j > noccurs(QWSEC05)
            if FA01(j) = 1 then
              inc(i);
              list_ch(i,1) = edit("9999",QCLUSTER);
              list_ch(i,2) = edit("9999", QNUMBER );
              list_ch(i,3) = edit("99",  QLINE );
              list_ch(i,4) = QNAME;
              list_ch(i,5) = edit("99", Q503(j) );
              list_ch(i,6) = Q503N(j);
              if Q508D(j) <> notappl then
                list_ch(i,7) = maketext("%02d-%02d-%04d",Q508D(j), Q508M(j), Q508Y(j));
              else
                list_ch(i,7) = maketext("%02d-%02d-%04d",Q220D(Q503(j)), Q220M(Q503(j)), Q220Y(Q503(j)));
              endif;
              FRCLUST = QCLUSTER;
              FRHNUMBER = QNUMBER;
              FRMLINE = QLINE;
              FRCLINE = Q503(j);
              clear(FACVACC);
              found = loadcase(FACVACC);
              recode found :: FR04    -> string status_str     :: status  ;
                         1 :: notappl -> tr( "Partial" )       ::  2 ;
                         1 :: 1,2     -> tr( "Completed" )     ::  1 ;
                           ::         -> tr( "Not entered" )   ::  0 ;
              endrecode;
              list_ch(i,8) = status_str;
              list_ch(i,9) = edit("9", status);
            endif;
          enddo;
        enddo;
        // show list of children
        numeric childsel = showarray( tr("Select a child for entry"), list_ch,
                           title(tr( "Cluster" ), tr( "Household" ), tr( "Line number" ), tr( "Mother" ), tr( "Child line" ), tr( "Child Name" ), tr( "Date of birth" ), tr( "Status" )));
          if childsel then
            xcase  = strip(list_ch(childsel,1)) + strip(list_ch(childsel,2)) + strip(list_ch(childsel,3)) + strip(list_ch(childsel,5));
            appname = "VacEntry";
            xparamet = xcase + xsuperv;
            status = tonumber ( list_ch(childsel, 9) );
            recode status  -> x   ;
                      0    -> VacEntry( 1,0); { new }
                      2    -> VacEntry( 0,1); { partial }
                      1    -> VacEntry( 0,0); { modify }
                           -> 9; 
            endrecode; 
            RunPFFS();
          endif;
      endif;
    endif;
  end;

PROC FL_MENU
PreProc
  setlanguage("RU");
  if debug then
    // errmsg(  "WARNING: DEBUG MODE ENABLED!" );
    trace(on, ".\debug.app", clear);
//  trace(on);
    set trace;
  endif;
  CSPro = PathName( CSPro );
  
  isAndroid = (getos() = 20);            { get operating system }

  { Operator ID }
  opid="Anyone";                         { this could be an ID set on each machine }

  { set font for value sets }
  setfont( All, "Arial", 18, bold );

  { work project }
    wrkprj = "..";                         { work project in laptop }
    wrkpii = wrkprj + "\PII"; 
  { set up minimal user bar }
  userbase();
  userbar( show );
  { set the language at the start of the program, defaulting to English }
  setlanguage(loadsetting("Language", "EN"));
  setvaluesets( "_" + getlanguage() );
  SameSession = tonumber(loadsetting("SupSession"));
  sysver      = loadsetting("Version", "0");

  entry     = wrkprj + "\Entry";      { data entry programs }
  superv    = wrkprj + "\Superv";     { supervisor programs }
  dicts     = wrkprj + "\Dicts";      { survey's dictionaries }
  utility   = wrkprj + "\Utility";    { all utilities used by the system }
  btupgr    = wrkprj + "\Upgrades";  { place where upgrades for interviewers are stored by IFSS }
  if isAndroid then
    upgrades  = "/storage/emulated/0/Documents/CSPRO_UPGRADES"; { !! }
  else
    upgrades  = wrkprj + "\Upgrades";   { place where upgrades for interviewers are stored by IFSS }
  endif;

  Biomarker = wrkprj + "\Biomarker";  { biomarker applications }
  images    = wrkprj + "\Images";     { images  }
  pictures = wrkpii +  "\Pictures";  { working area to store pictures taken by applications }
  wrkref    = wrkpii + "\Ref";        { reference directory for clusters, sample and teams files  }
  data      = wrkpii + "\Data" ;     { where data is stored }
  receive   = wrkpii + "\Receive";    { data coming from interviewers }
  final     = wrkpii + "\Final";      { to store final files to send to central office }
  temp      = wrkpii + "\Temp";       { to store working data files }
  work      = wrkpii + "\Work";       { working area to store concatenated households }
  piisafe   = wrkpii + "\PIISafe";        { folder for data files with PII data stripped }

  btwork    = "\Work\";                             { last portion of directory where file with assigned households will be copied to interviewer's machine }
  btdata    = "\Data\";                             { last portion of directory where file with remeasurements will be copied to health specialist's machine }
  bkpsup    = "E:\Backup";                          { directory to backup data to supervisor's flash memory }
  zipclust  = "E:\Zipdata";                         { zip files to be sent to central office }
  upgserver = "Upgrades";  // string for location of upgrades on server
  
  { check presence of mandatory directories }
  { ANDROID - see modified ChkDir which creates a folder if it doesn't exist -  }
  ChkDir( entry );
  ChkDir( superv );  
  ChkDir( temp );    
  ChkDir( work );    
  ChkDir( upgrades ); 
  ChkDir( wrkref );  
  ChkDir( receive );
  ChkDir( final );
  ChkDir( images );
  ChkDir( pictures );
  ChkDir( PIISafe );

  { log file}
  IFSSlogFile = PathName(CSEntry) + "TJ81" + "/log.txt";
  { file names for upgrades }
  upgrname = "upgdhs";                          { upgrade name for interviewers DHS }
  { file name for sync log  }
  synclogfile = Path.Concat(wrkprj, maketext("synclog%04d.csv", tonumber( loadsetting("Supervisor") )));
  // check current version of CSEntry for FCT purposes
  // disable running FCT if version < 7.6
  {string csprover = diagnostics("version");
  if csprover = "7.6" | csprover = "7.7" then
    doFCT = 1;
  else
    doFCT = 0;
  endif;
  }
  { folder list for checking duplicates }
  dirstocheck.clear();
  dirstocheck.add(receive);

  setfile( fromckid, superv + "\ERRORS.TXT" );  { file coming from CHECKID }
    { check for upgrades and apply !!! }

  { initialize array of interviewers }
  do i = 1 while i <= 20
    interview(i) = 0;
    intername(i) = "";
  enddo;


  { initialize array of interviewers }
  do i = 1 while i <= 20
    do j = 1 while j <= 3
      TeamShare(i,j) = "";
    enddo;
  enddo;

  // { remove any pffs in .\superv }
  // FileDelete( superv + "/*.pff" );
  // FileDelete( superv + "/*.PFF" );

  { check for any upgrades }
    ApplyUpgr();

  { load cluster file name }
  clustfname = FileName(CLUSTERS);

  { clean files from old phases !!! }
  { do this with care !!! }
  CleanFiles("8");
  CleanFiles("9");
  // clean index files in .ref and receive folders !!1
  // CleanIndex(wrkref);
PROC MENU_LEVEL
PreProc
  // set attributes( MENU_DICT ) assisted off ( variable(title) );
    open( INTERV );
    do j = 1 while loadcase( INTERV )    { load list of interviewers into memory }
      intvwcode(j) = ICODE;
      intvwname(j) = INAME;
      intvwteam(j) = ITEAM;
      intvwsex (j) = ISEX;
      intvwrole(j) = IROLE;
    enddo;
    totintvw = j-1;
    close( INTERV );
    if SameSession then
      advance to WFINAL
    endif;

PostProc
  { PostProc of level 0 }
  stop(-1);

PROC WSUPER
onfocus
  fieldworkers.clear();
  if totintvw then
    do j = 1 while j <= totintvw
      if intvwrole(j) = 2 then            { supervisor }
        fieldworkers.add( intvwname(j), intvwcode(j) );
      endif;
    enddo;
    SetValueSet( $, fieldworkers );
  endif;
  
  $ = tonumber( loadsetting("Supervisor") );

postproc
  SaveSetting( "Supervisor", edit("9999",$) );
  do j = 1 while j <= totintvw & intvwcode(j) <> $ enddo;
  if j <= totintvw then
    steam   = intvwteam(j);
    SupCode = intvwcode(j);
    SupName = intvwname(j);
  endif;

  { get an array of interviewers that belong to the same team }
  j = 0;
  do i = 1 while i <= totintvw
    if intvwteam(i) = steam then
      j = j + 1;
      interview(j) = intvwcode(i);
      intername(j) = intvwname(i);
      interrole(j) = intvwrole(i);
          if intvwrole(i) = 3 then
            codebiomarker = intvwcode(i);
          endif;
    endif;
  enddo;
  { populate array of fieldworkers that belong to the same team }
  j = 0;
  do i = 1 while i <= totintvw
    if intvwteam(i) = steam & intvwrole(i) in 1:3 then
      j = j + 1;
          TeamShare(j,1) = edit("9999",intvwcode(i));
          TeamShare(j,2) = intvwname(i);
          TeamShare(j,3) = edit("9",intvwrole(i));
        endif;
  enddo;        
  TeamMemb = j;
  // skip interviewer code !!
  skip to WCLUSTER;


PROC WCLUSTER
onfocus
  $ = tonumber( loadsetting("Cluster") );

postproc
  // check cluster number is correct
  if FileExist( clustfname ) then
    setFile(ClUSTERS, clustfname, update);
    if !loadcase( CLUSTERS, WCLUSTER ) then
      errmsg( 001, WCLUSTER );
      reenter;
    endif;
    close(CLUSTERS);
    SaveSetting( "Cluster", edit("9999",$) );
  else
    errmsg( 007 );
    stop(-1);
  endif;
  
  {errmsg( "Province=%s, Region=%s, District=%s, Commune=%s, ZD=%s", strip(YPROVINN), strip(YREGIONN), strip(YDISTRICTN), strip(YCOMUNEN), strip(YENUMERN) );}
  WURBRUR    = GetValueLabel( YURBRUR );
  WREGIONN   = YREGIONN;
  WSTATEN    = YSTATEN;
  WDISTRICTN = YDISTRICTN;
  WCITYN     = YCITYN;
  xcluster = edit( "9999", WCLUSTER );                    { cluster number }
  xintnum  = edit( "9999", IntCode );                     { Interviewer }
  if SupCode then
    xsuperv  = edit( "9999", SupCode );                     { Supervisor }
  else
    xsuperv  = edit( "9999", WSUPER );                     { Supervisor }
  endif;


  { 1-Control file for supervisor }
  // check CONTSUP file exists and copy if not found
  fname = wrkref + "\Superv" + xsuperv + ".dat";
  if !FileExist(fname) then
    FileCopy( wrkref + "\SupervXXXX.dat", fname );
  endif;
   
  xparaux  = xintnum + xsuperv + "10100";         { Interviewer, supervisor, access by central office/supervisors, in modify mode }
  xparamet = xparaux;
  { xparamet postions as defined by the data collection applications  }
  {  1:4   - interviewer number                                       }
  {  5:4   - supervisor number                                        }
  {  9:1   - central office, supervisors also use the flag set to 1   }
  { 10:1   - revisit                                                  }
  { 11:1   - modify completed                                         }
  { 12:1   - if case has been saved partially                         }
  { 13:1   - enter height & weight data                               }
  { 14:4   - household number                                         }
  { 18:2   - woman's line number                                      }
  xfilenum = xcluster + xintnum;         { data file names coming from interviewers }

  // check bluetooth id is set to the interviewer code

    if ( isAndroid | useCSBT ) & getbluetoothname() <> edit("9999",SupCode ) then
      if isAndroid then
        setbluetoothname(edit("9999", SupCode));
      else
        // in Windows need to restart app in admin mode
        // to do this we call batch file which in turn calls shortcut file with admin privileges to run dcmenu
  

     if SameSession = 9 then   // if returning into menu with admin privileges set bt name
          setbluetoothname(edit("9999", SupCode));
                  
          SaveSetting( "SupSession", "1" );
          AppName = ".\SupMenu"; // then quit menu and restart with normal user level for security reasons
          runpffS();
        else
          errmsg(014,getbluetoothname(),edit("9999",SupCode ));
          SaveSetting( "SupSession", "9" );                    // save session flag for restart
          TheCommand = MakeText('cmd /c start %s\supmenu.lnk', PathName(Application));
          ExecSystem( TheCommand, maximized, stop );          
        endif;
      endif;
    endif;

  { the system first checks for upgrades available to both supervisors and interviewers }
  { check if connected to CSWeb }
  numeric LastUpLoad = tonumber(loadsetting("LastUpLoad",0));
  if LastUpload < sysdate("YYYYMMDD") then
    CopySampSel();
    if SendData_SyncCloud() then
      savesetting("LastUpLoad", edit("99999999",( sysdate("YYYYMMDD") )));
      // restart Supervisor Menu to check for updates !!!
      AppName = "../SUPMENU";
      runpffS();
    endif;
  endif;

PROC WFINAL
onfocus
  WNUMBER  = notappl;
  WADDRESS = " ";
  WCORRECT = notappl;
  $ = " ";
  noinput;

postproc
// closing cluster 
  if samesession in 3,4 then
    open( fromckid );
    FileRead( fromckid, chkfile );
    if pos( "WITH", chkfile ) then
      errmsg( 060 );
    else
      alldata();
      mkpiisafe();
      errmsg( 109 );
      if doFCT & samesession = 3 & SyncCloud then // concat data and run FC tables app
        prep_FCT();
        SaveSetting( "SupSession", "7" );
        // first remove old FCT output
        FileDelete(superv + "/output.xml" );
        AppName = "FCT";
        FCT(temp);
        runpffS();
      else
        SendData_SyncCloud();
      endif;
    endif;
  elseif samesession = 5 then          // aditional steps after executing WrkElig for households 
    review_hh();
  elseif samesession = 6 then          // aditional steps after executing WrkElig for individuals 
    hhtoget = tonumber(loadsetting("hhtoget",0));
    review_ind();
  elseif samesession = 7 then          // !!! returning after running FCT
    FileCopy(superv + "\output.xml", superv + "\output" + xsuperv + ".xml");// version for upload to server to check !!!
    SendData_SyncCloud();
  endif;
  

  // resizepics();
  
  { set up string to display version numbers at top of menu } 
    versiontxt = maketext(" Ver:%s ", sysver); // version = date + hour + minutes
  if getlanguage() = "EN" then
    heading = maketext("Supervisor %4d: %s: Cluster %s [%s] " , WSUPER, getbluetoothname(), xcluster , versiontxt) ;
    action = accept( heading,
            { 1}  "1 Assign households for cluster",
            { 2}  "2 Send household assignment to interviewers",
            { 3}  "3 Get data from interviewer",
            { 4}  "4 List cluster data ",
            { 5}  "5 Review Household questionnaires",
            { 6}  "6 Review Individual questionnaires",
            { 7}  "7 Close cluster/Status report",
            { 8}  "8 Transfer data to central office",
            { 9}  "9 List cluster's notes",
            {10}  "U Send upgrades to interviewers",
            {11}  "R Height and weight remeasurement",
            {12}  "V Enter vaccination cards from health facility",
            {13}  "I ---Reinterview Menu---",
            {14}  "C Change cluster number",
            {15}  "D ---Other options------",
            {16}  "L- Change language",
            {17}  "E Exit system" );
  else
    heading = maketext("Супервайзер %4d: %s: Кластер %s [%s] " , WSUPER, getbluetoothname(), xcluster , versiontxt) ;
    action = accept( heading,
                        { 1}  "1 Назначение домохозяйства в кластере", 
                        { 2}  "2 Отправить назначенные домохозяйства интервьюерам", 
                        { 3}  "3 Получить данные от интервьюера",  
                        { 4}  "4 Перечислить данные кластера", 
                        { 5}  "5 Просмотреть анкеты домохозяйств", 
                        { 6}  "6 Просмотреть индивидуальные анкеты",   
                        { 7}  "7 Закрытие кластера/Отчет о состоянии", 
                        { 8}  "8 Передача данных в центральный офис",  
                        { 9}  "9 Перечислить заметки к кластера", 
                        {10}  "U Отправка обновлений интервьюерам",  
                        {11}  "R Повторное измерение роста и веса",  
                        {12}  "V Ввести карты прививок из медицинского учреждения",  
                        {13}  "I ---Меню повторного интервью---", 
                        {14}  "C Изменить номер кластера" , 
                        {15}  "D ---Другие опции------",  
                        {16}  "L Поменять язык",
                        {17}  "E Выход из системы");  
  endif;
  if !action | action = 17 then
    fname = superv + "\justone.txt";
    if FileExist( justone ) then
      FileDelete( justone )
    endif;
    SaveSetting( "SupSession", "1" );
    stop(1)
  endif;
  SaveSetting( "SupSession", "2" );
  samesession = 2;
  
  if action = 1 then       { assign households to interviewers }
      close( INTERV );
      AppName = "ASSIGNHH";
      AssignHH();
      RunPFFS();
  elseif action = 2 then  { transfer file with households assigned to interviewers }
      if isAndroid | useCSBT  then
        getint();
      endif;
      sendassign();
  elseif action = 3 then        { get questionnaires from interviewer/biomarker }
    { check if data was previously sent but with wrong interviewer number }
    if getint() then
      found = ( FileExist( temp + "\H" + xfilenum + ".DAT") |
               FileExist( temp + "\I" + xfilenum + ".DAT") );
      if getquest( intcode ) then
        { check duplicates for individuals }
        concatind();     { concatenate individual questionnaires from all interviewers }
        if FindDups( dirstocheck, xcluster, 2) then
          reenter WFINAL;
        endif;
        { next 'if' necessary because CHECKID iterates over the cluster's household file }
        if !FileExist( receive + "\H" + xfilenum + ".DAT" ) |
           FileEmpty( receive  + "\H" + xfilenum + ".DAT" ) then
                  errmsg( 040 ); 
        else
          // create anonymized files
          cleanpii(receive + "\H" + xfilenum + ".DAT", 1);
          cleanpii(receive + "\I" + xfilenum + ".DAT", 2);
          concatpari();    { concatenate individual partials from all interviewers }
          AppName = "CHECKID";
          CheckID( 1 );           // !!!! 1-biomarker in paper 4-Biomarker in CAPI
          RunPFFS();
        endif;
      endif;
      { identify data files sent by other than the current interviewer }
      remainfile();
    endif;
  elseif action = 4 then       { list questionnaires from an interviewer }
    { check duplicates for individuals and biomarkers }
    concatind();     { concatenate individual questionnaires from all interviewers }
    if FindDups( dirstocheck, xcluster, 2) then
      reenter WFINAL;
    endif;
    if getint() then
      if files_hh( receive, xfilenum ) then
        // create anonymized files
        cleanpii(receive + "\H" + xfilenum + ".DAT", 1);
        cleanpii(receive + "\I" + xfilenum + ".DAT", 2);
        concatpari();    { concatenate individual partials from all interviewers }
        AppName = "CHECKID";
        CheckID( 1 );           // !!!! 1-biomarker in paper 4-Biomarker in CAPI
        RunPFFS();
      endif;
    else
      errmsg( 118 );
    endif;
  { Review household questionnaire or individual questionnaire }
 elseif action = 5 then
    review_hh();
 elseif action = 6 then
    hhtoget = 0;
    review_ind();
  elseif action = 7 then       { close or list a cluster }
    if getlanguage() = "EN" then
      option =  accept("Select Action", 
                "1. Report cluster status", 
                "2. Summary report",
                "3: Close Cluster",
                "4: Close Cluster without running FCT",
                "9: Cancel"
                );
    else
      option =  accept("Выберите действие", 
                "1. Сообщить о состоянии кластера", 
                "2. Суммарный отчет",
                                "3: Закрыть кластер",
                                "4: Закрыт кластер без запуска отчета"
                "9: Отмена"
                );
    endif;
    if option in 1:4 then
      if anyfiles(1) then         { check if hh files has been transferred to supervisor }
        { check for duplicated households, individuals and biomarkers }
        collapse();
        hhdups  = FindDups( dirstocheck, xcluster, 1);
        indups  = FindDups( dirstocheck, xcluster, 2);
        if hhdups | indups then
          reenter WFINAL;
        endif;
        AppName = "CHECKID";
        if option = 2 then // do summary report
          CheckID( 2, 1);
        else
          CheckID( 2 ); // close cluster/full report
        endif;
        close( fromckid );
        if option in 3,4 then
          SaveSetting( "SupSession", edit("9", option) );
        endif;
        RunPFFS();
      else
        errmsg( 080, xcluster );
      endif; // anyfiles
    endif;  // option in 1,2
  elseif action = 8 then        { create file to transfer to central office }
    SendData_SyncCloud();
    AppName = "SUPMENU";
    runpffS();
  elseif action = 9 then        { list cluster notes }
    if anyfiles(1) then          { check if hh files has been transferred to supervisor }
      concatnotes();
      AppName = "LISTNOTES";
      ListNotes();
      runpffs();
    else
      errmsg( 080, xcluster );
    endif;
  elseif action = 10 then       { send upgrades to interviewer's machine }
    sendupgr();
  elseif action = 11 then       { options available for height & weight remeasurment }
    if getlanguage() = "EN" then
      option = accept( heading,
               { 1}  "1 Select children for remeasurement",
               { 2}  "2 Enter remeasurements",
               { 3}  "3 List children selected for remeasurement",
               // { 4}  "4 Send remeasurement to health specialist",
               // { 5}  "5 Receive remeasurement from health specialist",
               { 6}  "9 Return to main menu" );
         else 
                option = accept( heading,
               { 1}  "1 Выберите детей для повторного измерения",
               { 2}  "2 Введите повторные измерения",
               { 3}  "3 Список детей, выбранных для повторного измерения",
           //    { 4}  "4 Envoyer la double mesure au Technicien de la santé",
           //    { 5}  "5 Recevoir la double mesure du Technicien de la santé",
               { 6}  "9 Вернуться в главное меню" );
    endif;
        { select children for remeasurement }
    if option = 1 then
      { check for duplicated households }
      collapse();
      hhdups  = FindDups( dirstocheck , xcluster ,1);
      if anyfiles(2) then
        indups  = FindDups( dirstocheck , xcluster ,2);
      endif;            
      if hhdups | indups then
        reenter WFINAL;
      else
        AppName = "RemeasSel";
        RemeasSel();
        RunPFFS();
      endif;
      { enter remeasurement data from paper questionnaires }
    elseif option = 2 then
      fname = temp + "\R" + xcluster + ".dat";
      if FileExist( fname ) & !FileEmpty( fname ) then
        AppName = "RemeasEntry";
        RemeasEntry( 0 );             // 1-Biomarker in CAPI, 0-Biomarker on paper
        RunPFFS();
      else
        errmsg( 110  );
      endif;
  { list children eligible for remeasurement }
    elseif option = 3 then
        fname = temp + "\R" + xcluster + ".dat";
        if FileExist( fname ) & !FileEmpty( fname ) then
          AppName = "RemeasLst";
          RemeasLst();
          RunPFFS();
        else
          errmsg( 110 );
        endif;
  { send children selected for remeasurement to health specialist }
    // elseif option = 4 then
    //   fname = temp + "\R" + xcluster + ".dat";
    //   if FileExist( fname ) & !FileEmpty( fname ) then
    //     SendRemeas();
    //   else
    //     errmsg( 110, fname );
    //   endif;
    //   { receive remeasurement data from health specialist }
    // elseif option = 5 then
    //   ReceiveRemeas();
    //   fname = temp + "\R" + xcluster + ".dat";
    //   if FileExist( fname ) & !FileEmpty( fname ) then
    //     AppName = "RemeasLst";
    //     RemeasLst();
    //     RunPFFS();
    //   else
    //     errmsg( 110, fname );
    //   endif;
    endif;
  elseif action = 12 then      { facility vaccination cards }
    run_VacEntry();
  elseif action = 13 then      { re-interview menu !!! }
    if getlanguage() = "EN" then
         option = accept ("Re-interview menu",
                "1. Select households for re-interview",
                "2  Re-interview households",
                "3. List households for reinterview",
                "9. Main Menu");
         else
         option = accept ("Меню повторного интервью",
                "1. Выберите домохозяйства для повторного интервью",
                "2  Повторный интервью домохозяйств",
                "3. Составьте список домохозяйств для повторного опроса",
                "9. Вернуться в главное меню");
        endif;
     if option = 1 then
       // select households
       if check_reint() then
         sel_reint();
       endif;
     elseif option = 2 then
       // re-interview
       SetAssignFile();
       SetEligFile(1);
       WrkEligR();
       ifok = selcase( tr("Select a household"), ELIGINDV, "", 5 ) include( ZNUMBER, ZADDRESS, ZNAME, ZSTATUS, ZRESULT );
      close(ELIGINDV);
      if ifok then
          advance to WCORRECT;
      endif;
     elseif option = 3 then 
       // list households
      hhdups  = FindDups( dirstocheck, xcluster, 1);
      if !hhdups then
        concathh();                { concatenate households }
        SetAssignFile();
        SetEligFile(1);
        WrkEligR();
        AppName = "LISTRI";
        listri();
        RunPFFS();
       endif;
     endif;
  elseif action = 14 then      { change cluster number }
    reenter WCLUSTER
  // elseif action = 13 then      { change language }
  //   x =  accept(tr("Select Language"), 
  //          "English",
  //          "Français");
  //   recode x -> x;
  //          1 -> setlanguage("EN");
  //          2 -> setlanguage("FR");
  //   endrecode;
  //   savesetting("Language", getlanguage());
  //   reenter;
  elseif action = 15 then      { diagnostic tools to view logs }
    if getlanguage() = "EN" then
                option = accept ("Other options",
                "1. Split a Household",
                "2. View Bluetooth Sync Log",
                "3. View SyncCloud Log",
                "4. Reset upgrades",
                "5. Restore interviewer tablet",
                "6. Remove an interviewer's data files",
                "7. Clean an interviewer's data files",
                "8  Run Field Check tables",
                "9  Remove household from supevisor control file",
                "P  Prepare pictures files for upload to server",
                "M. Main Menu");
                else
                                option = accept ("Другие опции",
                "1. Разделить домохозяйство",
                "2. Просмотр журнала синхронизации Bluetooth",
                "3. Просмотр журнала SyncCloud",
                "4. Сбросить обновления",
                "5. Восстановить планшет интервьюера",
                "6. Удалить файлы данных интервьюера",
                "7. Очистить файлы данных интервьюера",
                "8  Запустить таблицы качество полевых работ",
                "9  Удалить домохозяйство из контрольного файла руководителя",
                "P  Подготовить файлы изображений для загрузки на сервер",
                "M. Вернуться в главное меню");
        endif;
    if option = 1 then
      close( INTERV );
      AppName = "ASSIGNHH";
      AssignHH(1);
      RunPFFS();
    elseif option = 2 then
      fname  = PathName(CSEntry) + "sync.log";
      viewtext(fname);
    elseif option = 3 then
      viewtext(IFSSLogFile);
    elseif option = 4 then
      sysver = "000";
      SaveSetting( "Version", sysver );
    elseif option = 5 then
      SyncServer( Bluetooth );
    elseif option = 6 then
      if getint() then
        x = errmsg(tr("PLease confirm you wish to remove interviewer files for interviewer %04d"), intcode) select (tr("Yes, remove"), continue, tr("No, do not remove"), continue);
        if x = 1 then
          FileDelete(receive + "\H" + xfilenum + ".DAT");
          FileDelete(receive + "\I" + xfilenum + ".DAT");
          errmsg(tr("Files for interviewer %04d removed"), intcode);
        endif;
      endif;
    elseif option = 7 then
      if getint() then
        fname = receive + "\H" + xfilenum + ".DAT";
        if !FileEXist(fname) | FileEmpty(fname) then
          errmsg(tr("File for interviewer %04d not present on tablet"), intcode);
        else
          x = errmsg(tr("PLease confirm you wish to clean interviewer files for interviewer %04d"), intcode) 
          select (tr("Yes, clean"), continue, tr("No, do not clean"), continue);
          if x = 1 then
            fixdata(fname, 1);
            errmsg(tr("Files for interviewer %04d cleaned"), intcode);
          endif;
        endif;
      endif;
    elseif option = 8 then
      mkpiisafe();
      prep_FCT();
      SaveSetting( "SupSession", "7" );
      // first remove old FCT output
      FileDelete(superv + "/output.xml" );
      AppName = "FCT";
      FCT(temp);
      runpffS();
    elseif option = 9 then
      AppName = "Sentry";
      Sentry();
      runpffS();
    elseif option = 10 then
      AppName = "CheckID";
      CheckID( 5 );
      runpffS();
    else
      reenter;
    endif;
  elseif action = 16 then
    x =  accept(tr("Select Language"), 
           "English",
           "Russian");
    recode x -> x;
           1 -> setlanguage("EN");
           2 -> setlanguage("RU");
    endrecode;
    savesetting("Language", getlanguage());
    reenter;
  else
    skip to WNUMBER;
  endif;
  reenter WFINAL;

PROC WNUMBER
preproc 
  $ = 1;
 
PROC WADDRESS
preproc
  if length(strip(ZNAME)) then
    if length(strip(ZADDRESS)) then
      $ = concat( strip(ZNAME), " - ", strip(ZADDRESS) );
    else
      $ = ZNAME;
    endif;
  elseif length(strip(ZADDRESS)) then
    $ = ZADDRESS;
  else
    $ = "";
  endif;
PROC WCORRECT
preproc
  $ = 1;
postproc
  // logic for entering re-interview
  xparaux  = xsuperv + xsuperv + "0" + "0000";
  xparamet = xparaux  + edit("9999",ZNUMBER);
  xcase    = xcluster + edit("9999",ZNUMBER);
  xfilenum = xcluster + xsuperv;         { data file name for supervisor}
  { start data collection for a household }
  numeric partial  = partialcs( 1, ZCLUSTER, ZNUMBER, 0, final + "\V" + xfilenum + ".DAT" );
  AppName = "COLLECTHH";
  // box partial : ZRESULT => x   ;
            // 0 : 0       => csrun( 1, 3, 0, 0, 0, 0 );{ NEW HH: add, hh, !partial, !revisit, !change, !heigth/weight }
         // >= 1 : 0,2-9   => csrun( 0, 3, 1, 1, 0, 0 ); { PARTIAL SAVE, incomplete : modify, hh, partial, revisit, !change, !heigth/weight }
         // >= 1 : 1       => csrun( 0, 3, partial, 1, 0, 0 ); { PARTIAL, result=1: modify, hh, partial, revisit, !change, !height/weight }
            // 0 : 1       => csrun( 0, 3, 0, 0, 1, 0 ); { MODIFY COMPLETE : modify, hh, !partial, !revisit, change, !heigth/weight }
              // :         => 9; 
  // endbox; 
                        
  recode partial :: ZRESULT -> x   ;
            0 :: 0       -> csrun( 1, 3, 0, 0, 0, 0 );{ NEW HH: add, hh, !partial, !revisit, !change, !heigth/weight }
         >= 1 :: 0,2-9   -> csrun( 0, 3, 1, 1, 0, 0 ); { PARTIAL SAVE, incomplete : modify, hh, partial, revisit, !change, !heigth/weight }
         >= 1 :: 1       -> csrun( 0, 3, partial, 1, 0, 0 ); { PARTIAL, result=1: modify, hh, partial, revisit, !change, !height/weight }
            0 :: 1       -> csrun( 0, 3, 0, 0, 1, 0 ); { MODIFY COMPLETE : modify, hh, !partial, !revisit, change, !heigth/weight }
              ::         -> 9; 
  endrecode; 
  if x = 9 then
    errmsg(tr("Partial=%d, result=%d,use option 7 Data Exchange-> 7 Fix result in a household to resolve problem"),partial,vresult);
  endif;
